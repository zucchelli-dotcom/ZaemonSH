#!/usr/bin/env zsh -f

##########################################################################################
#                                                                                        #
#  ZaemonSH created by :                                                                 #
#  Zucchelli Bryan && @N@TOME && Admiral Gr@ss H0pper on Oct 13, 2016.                   #
#  Copyright (c) 2019. All rights reserved.                                              #
#  Inspired by zsh-templates-osx created by :                                            #
#  William Scott on May 11, 2007.                                                        #
#  Copyright (c) 2007. All rights reserved.                                              #
#                                                                                        #
#  This program is free software; you can redistribute it and/or modify it under         #
#  the terms of the GNU General Public License as published by the Free Software         #
#  Foundation; either version 2 of the License, or (at your option) any later version.   #
#                                                                                        #
#  This program is distributed in the hope that it will be useful, but WITHOUT           #
#  ANY WARRANTY ; without even the implied warranty of MERCHANTABILITY or                #
#  FITNESS FOR A PARTICULAR PURPOSE.                                                     #
#  See the GNU General Public License for more details.                                  #
#                                                                                        #
#  You should have received a copy of the GNU General Public License                     #
#  along with this program ; if not, write to the Free Software Foundation,              #
#  Inc., 51 Franklin Street, Fifth Floor, Boston,  MA 02110-1301 USA                     #
#                                                                                        #
#  cf. URL:   http://www.fsf.org/licensing/licenses/gpl.html                             #
#                                                                                        #
##########################################################################################

#----------------------------------------------------------------------------------------#
#                                     DESCRIPTION
#----------------------------------------------------------------------------------------#
# port :
# Script collection to manage MacPorts
# 
# - `Port-Configuration.sh`: Simply run it and it will print some useful information for you.
# - `avidemux-build.sh`: This one does **not** work reliably, but you can try running it to see if it will build avidemux for you...
# - `gen_macports_patches.sh`: I actually do **not** use this one myself, but apparently you give it two directories as arguments, and it will generate patches between the two for use with MacPorts...
# - `install_macports.sh`: If you are installing `macportsscripts` via its port, you probably won't need this script, as you should already have MacPorts installed.
# - `macports_34482_fix.pl`: If you have a broken MacPorts registry, just run this script and it should fix it for you (assuming that it broke in a particular way)
# - `macportstrac.sh`: interact with trac (specifically, query/view trac tickets)
# - `macportsupdate.sh`: Just run this script and it will update your MacPorts stuff for you
# - `port-copy.sh`: I do **not** use this one myself either, but apparently it will make a copy of a port's portfile for diffing against if you are updating it or something...
# - `port-depcheck.sh`: This is probably the script I use the most. You give it the name of an installed port, and then it will scan the files that that port has installed to see what it links against. After finding what it links against, it will match these libraries to the ports that provide them, and then it will output a diff between the ports that the port actually links against, and the ports that the port declares as library dependencies. `+`es in the diff (highlighted as green when uploaded to MacPorts's trac) mark the names of ports that can be added as library dependencies, while `-`es in the diff (marked as red when uploaded to MacPorts's trac) mark the names of ports that can be removed as library dependencies.
# - `port-fetch-all.sh`: This was the original script that originally made up phw's old `macportsscripts` port. It takes the name of a port as an argument, and will fetch all the dependencies of that port.
# - `port-patch.sh`: I do **not** use this one myself either, but apparently it will generate patches for portfiles...
# - `port-unprovided.sh`: This script will scan your MacPorts prefix for stray files in it that are **not** provided by any ports. Pass it the `--help` flag for more info.
# - `testport-script.sh`: a more generalized version of `avidemux-build.sh`. Test-installs a port into a custom prefix.

#----------------------------------------------------------------------------------------#
#                                        TODO
#----------------------------------------------------------------------------------------#
# 2020-07-30 :
# • Finished script.

#----------------------------------------------------------------------------------------#
#                                       CHANGES
#----------------------------------------------------------------------------------------#

#----------------------------------------------------------------------------------------#
#                                       CONFIG
#----------------------------------------------------------------------------------------#
local VERSION

VERSION="0.0.1"
FCT_NAME="$0"

local banner 

#-------------------------------------------------------------------------------------------#
#                                              FUNCTIONS
#-------------------------------------------------------------------------------------------------#
banner () {
  clear
  echo "${NC}"
  echo " ###################################################################################################"
  echo " #                                                                                                 #"
  echo " #     ${GREEN}This is ${RED}$FCT_NAME : ${YEL}$VERSION FOR $OSTYPE ${NC}                                                  #"
  echo " #     CopyL®®v 2019, Zucchelli Bryan                                                              #"
  echo " #                                                                                                 #"
  echo " #     Unless required by applicable law or agreed to in writing, software                         #"
  echo " #     distributed under the License is distributed on an "AS IS" BASIS,                             #"
  echo " #     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                    #"
  echo " #     See the License for the specific language governing pe$RMissions and                                  #"
  echo " #     limitations under the License.                                                              #"
  echo " #                                                                                                 #"
  echo " ###################################################################################################"
  echo ""
} 

#----------------------------------------------------------------------------------------#
#                                       SCRIPT
#----------------------------------------------------------------------------------------#
banner


port_avidemux_build() {
#!/bin/bash
# This script was taken from https://trac.macports.org/wiki/Avidemux/Avidemux_2.6_script_MacOSX_10.6.8

# Build avidemux 2.6 (SVN revision 7891)
#
# Project: avidemux - SVN,
# http://developer.berlios.de/svn/?group_id=1402
#
# see also:
# http://www.avidemux.org/nightly/source/
# 
# SVN 2.6.0 builds for MacOSX
# http://www.avidemux.org/smf/index.php?topic=8034.0
# http://www.avidemux.org/smf/index.php?board=5.0
# http://avidemux.dyndns.org/index.php?lang=en&subject=Avidemux&texttag=Avidemux

unset CDPATH IFS LC_ALL PATH MP_PREFIX

# set a different prefix from the normal one because this script installs a new MacPorts there
MP_PREFIX='/opt/macports-avidemux'
IFS=$' \t\n'
LC_ALL=C
PATH="${MP_PREFIX}/bin:/bin:/sbin:/usr/bin:/usr/sbin"

export IFS LC_ALL PATH MP_PREFIX

# tell tar command not to archive extended attributes (e.g. resource forks) to ._* archive members
export COPYFILE_DISABLE=true                   
# ditto; for pre Mac OS X 10.5 systems
export COPY_EXTENDED_ATTRIBUTES_DISABLED=true  

declare -rx avidemux_tmp_dir='/tmp/avidemux-svn-build' || exit 1
declare -rx avidemux_src_dir='/tmp/avidemux-svn-build/avidemux_2.6_branch_mean' || exit 1

# make sure a root shell is used
if [[ $(id -u) -ne 0 ]] || [[ "${HOME}" != '/var/root' ]]; then
   echo 'This script must be run in a root shell to prevent sudo timeout!' 1>&2
   echo 'Use: sudo -H -i' 1>&2
   exit 1
fi

# prevent idle sleep
pmset -a force sleep 0 displaysleep 0 disksleep 0

rm -rf "${avidemux_tmp_dir}"

mkdir "${avidemux_tmp_dir}" || { echo "Could not make directory: ${avidemux_tmp_dir}"; exit 1; }

cd "${avidemux_tmp_dir}" || exit 1

# do some clean-up to avoid search path issues 
# (such as linking to wrong .dylib files, including incompatible .h files, ...)
rm -rf /usr/local-avidemux
[[ -d '/opt/local' ]] && mv -iv /opt/local /opt/local-off
[[ -d '/usr/local' ]] && mv -iv /usr/local /usr/local-off
[[ -d "${MP_PREFIX}-off" ]] && { echo "directory already exists: ${MP_PREFIX}-off"; exit 1; }
[[ -d "${MP_PREFIX}" ]] && sudo mv -iv "${MP_PREFIX}" "${MP_PREFIX}-off"

# additional option to add /usr/local to valid search paths
#ln -isv /opt/macports-avidemux /usr/local  

# build custom MacPorts in ${MP_PREFIX}
# cf. http://guide.macports.org/#installing.macports.source.multiple
unset PATH
export PATH='/bin:/sbin:/usr/bin:/usr/sbin'
curl -L -O https://distfiles.macports.org/MacPorts/MacPorts-2.0.4.tar.bz2
tar -xjf MacPorts-2.0.4.tar.bz2
cd MacPorts-2.0.4 || exit 1
./configure --prefix="${MP_PREFIX}" --with-tclpackage=${MP_PREFIX}/tcl --with-applications-dir="${MP_PREFIX}/Applications"
make
make install

# dscl . -read /Users/macports
dscl . -change /Users/macports NFSHomeDirectory /opt/local/var/macports/home "${MP_PREFIX}/var/macports/home"

cd "${avidemux_tmp_dir}" || exit 1

unset PATH
export PATH="${MP_PREFIX}/bin:/bin:/sbin:/usr/bin:/usr/sbin"

port -v selfupdate

port -f install gawk
#port -f install llvm-3.1
port -f install clang-3.1
port -f install avidemux +aac+dts+lame+ogg+x264+xvid
port -f install qt4-mac
port -f install libarchive +lzma
port -f install opencore-amr

port -f uninstall avidemux

port -f uninstall gtk2
port -f install gtk3

sleep 3

cd "${avidemux_tmp_dir}" || exit 1

# download avidemux 2.6 SVN revision 7891
# cf. http://developer.berlios.de/svn/?group_id=1402
svn checkout -r 7891 http://svn.berlios.de/svnroot/repos/avidemux/branches/avidemux_2.6_branch_mean || 
   { echo "svn checkout failed (see http://developer.berlios.de/svn/?group_id=1402)."; exit 1; }


cd "${avidemux_src_dir}" || exit 1


# change owner & group of ffmpeg package to root:wheel
cd "${avidemux_src_dir}"/avidemux_core/ffmpeg_package || exit 1
for ffmpegfile in ffmpeg-0.10.2.tar.bz2; do
   ls -l "$ffmpegfile" || { echo "No ffmpeg file: ${ffmpegfile}"; exit 1; }
   tar -xf "$ffmpegfile"
   rm -f "$ffmpegfile"
   sleep 1
   chown -R root:wheel .
   sleep 1
   tar -cjf "$ffmpegfile" ffmpeg-0.10.2 || exit 1
   rm -rf ffmpeg-0.10.2
   ls -l "$ffmpegfile" || { echo "No ffmpeg file: ${ffmpegfile}"; exit 1; }
done


cd "${avidemux_tmp_dir}" || exit 1

chown -R root:wheel .

cd "${avidemux_src_dir}" || exit 1


# make sure we have: CMAKE_SYSTEM_PROCESSOR: x86_64
cat <<-'EOF' | sed '/^#/d' | ed -s avidemux_core/CMakeLists.txt
H
1a

if (CMAKE_SIZEOF_VOID_P MATCHES "8")
set(CMAKE_SYSTEM_PROCESSOR "x86_64")
set(arch "x86_64")
else()
set(CMAKE_SYSTEM_PROCESSOR "i386")
set(arch "i386")
endif()

.
wq
EOF


# edit bootStrapOsx.bash

cat <<-'EOF' | sed -e '/^#/d' -e 's/^ #/#/' | ed -s bootStrapOsx.bash
H
/\(-DCMAKE_EDIT_COMMAND\)/s|| -DCMAKE_PREFIX_PATH=/opt/macports-avidemux -DCMAKE_LIBRARY_PATH=/opt/macports-avidemux/lib -DCMAKE_INCLUDE_PATH=/opt/macports-avidemux/include \1|
/export BASE_INSTALL_DIR="opt\/local"/a

unset BASE_INSTALL_DIR
export BASE_INSTALL_DIR=/usr/local-avidemux
# use clang
#export CC="clang-mp-3.1"
#export CXX="clang++-mp-3.1"
# use verbose clang
export CC="clang-mp-3.1 -v"
export CXX="clang++-mp-3.1 -v"
export CMAKE_PREFIX_PATH=/opt/macports-avidemux
export CMAKE_LIBRARY_PATH=/opt/macports-avidemux/lib
export CMAKE_INCLUDE_PATH=/opt/macports-avidemux/include
export LDFLAGS="-arch x86_64 -L/opt/macports-avidemux/lib -headerpad_max_install_names -Wl,-framework,Cocoa"
#export LDFLAGS="-arch x86_64 -L/opt/macports-avidemux/lib -headerpad_max_install_names -framework Cocoa"
export CFLAGS="-arch x86_64 -I/opt/macports-avidemux/include -I/opt/macports-avidemux/include/gtk-3.0 -I/opt/macports-avidemux/include/glib-2.0 -I/opt/macports-avidemux/lib/glib-2.0/include -I/opt/macports-avidemux/include/cairo -I/opt/macports-avidemux/include/pango-1.0 -I/opt/macports-avidemux/include/gtk-3.0/gdk -I/opt/macports-avidemux/include/gtk-3.0/unix-print -I/opt/macports-avidemux/include/gdk-pixbuf-2.0 -I/opt/macports-avidemux/include/atk-1.0 -I/opt/macports-avidemux/include/gio-unix-2.0"
export CXXFLAGS="${CFLAGS}"

.
/cmake \$PKG/a

sleep 1
 # replace gcc option ' -shared ' with ' -dynamiclib ' in link.txt files
egrep -Ilsr -Z -e ' -shared ' . | 
   xargs -0 -n 1 /bin/sh -c 'printf "%s\n" H "g/ -shared /s// -dynamiclib /g" wq | /bin/ed -s "${1}"' argv0

sleep 1

 # edit cmake_install.cmake files:  "lib..*\.dylib"  -->  "${CMAKE_INSTALL_PREFIX}/lib/lib..*\.dylib"
printf '\n\n%s\n\n' "${BUILDDIR}: install_name_tool search & replace:   \"lib..*.dylib\"   -->   \"\${CMAKE_INSTALL_PREFIX}/lib/lib..*.dylib\""
egrep -Ilsr -Z -e 'install_name_tool' . | xargs -0 egrep -Ils '"lib..*\.dylib"' 
echo

egrep -Ilsr -Z -e 'install_name_tool' . | 
   xargs -0 egrep -Ils -Z '"lib..*\.dylib"' |
   xargs -0 -n 1 /bin/sh -c 'printf "%s\n" H "g/\"\(lib..*\.dylib\)\"/s||\"\${CMAKE_INSTALL_PREFIX}/lib/\1\"|g" wq | /bin/ed -s "${1}"' argv0

sleep 1

.
/Process buildPluginsGtk/i

 # fix:
 #   Undefined symbols for architecture x86_64:
 #     "flyASharp::download()", referenced from:
 #         vtable for flyASharp in DIA_flyAsharp.cpp.o
 #   ld: symbol(s) not found for architecture x86_64
 # see:
 # http://stackoverflow.com/questions/1693634/undefined-symbols-vtable-for-and-typeinfo-for
 # http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.10

cat <<-'EDSCRIPT' | sed '/^#/d' | ed -s avidemux_plugins/ADM_videoFilters6/asharp/DIA_flyAsharp.h
H
/\([[:blank:]]*\)uint8_t.*download.*void.*/s//\1 virtual uint8_t    download(void) = 0;/
/\([[:blank:]]*\)uint8_t.*upload.*void.*/s//\1 virtual uint8_t    upload(void) = 0;/
wq
EDSCRIPT

.
/Process buildPluginsGtk/a

 # undo again
cd $TOP
cat <<-'EDSCRIPT' | sed '/^#/d' | ed -s avidemux_plugins/ADM_videoFilters6/asharp/DIA_flyAsharp.h
H
/\([[:blank:]]*\)uint8_t.*download.*void.*/s//\1uint8_t    download(void);/
/\([[:blank:]]*\)uint8_t.*upload.*void.*/s//\1uint8_t    upload(void);/
wq
EDSCRIPT

.
wq
EOF


chmod +x bootStrapOsx.bash

#./bootStrapOsx.bash
#./bootStrapOsx.bash --debug --without-qt4 --without-gtk --with-cli                # cli
#./bootStrapOsx.bash --debug --without-qt4 --with-gtk --with-plugins --with-cli    # gtk
#./bootStrapOsx.bash --debug --without-gtk --with-qt4 --with-plugins --with-cli    # qt

./bootStrapOsx.bash --debug --with-gtk --with-qt4 --with-cli --with-plugins       # cli & gtk & qt


# manual install of missing .dylib files

printf '\n%s\n\n' 'manual install of missing .dylib files'

(
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/muxers
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/audioDecoder
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/audioDevices
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/audioEncoders
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/demuxers
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/videoEncoders
mkdir -p /usr/local-avidemux/lib/ADM_plugins6/videoFilters
#mkdir -p /usr/local-avidemux/lib/ADM_plugins6/videoDecoders
)

(
cd "${avidemux_src_dir}" || exit 1
find . -name "*.dylib" | grep -i _muxers | grep -i _mx_ | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/muxers
find . -name "*.dylib" | grep -i _audioDecoders | grep -i _ad_ | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/audioDecoder
find . -name "*.dylib" | grep -i Device | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/audioDevices
find . -name "*.dylib" | grep -i _audioEncoders | grep -i _ae_ | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/audioEncoders
find . -name "*.dylib" | grep -i _demuxers | grep -i _dm_ | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/demuxers
find . -name "*.dylib" | grep -i _videoEncoder | grep -i _ve_ | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/videoEncoders
find . -name "*.dylib" | grep -i _videoFilters | grep -E -i '_hf_|_vf_' | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/videoFilters
find . -name "*.dylib" | grep -i ffmpeg | xargs -I{} cp -v {} /usr/local-avidemux/lib
#find . -name "*.dylib" | grep -i videoDecoders | grep -iv _core | xargs -I{} cp -v {} /usr/local-avidemux/lib/ADM_plugins6/videoDecoders
)


echo

# sanitize .dylib install names
find /usr/local-avidemux -type f -name "*.dylib" -print0 | while IFS="" read -r -d "" dylibpath; do
   echo install_name_tool -id "$dylibpath" "$dylibpath"
   install_name_tool -id "$dylibpath" "$dylibpath"
done | nl

echo


if [[ ! -x '/opt/macports-avidemux/bin/gsettings' ]] || [[ ! -d '/opt/macports-avidemux/include/gsettings-desktop-schemas' ]]; then

   # fix: 
   # GLib-GIO-ERROR **: No GSettings schemas are installed on the system
   curl -L -O http://ftp.gnome.org/pub/GNOME/sources/gsettings-desktop-schemas/3.4/gsettings-desktop-schemas-3.4.1.tar.xz || exit 1
   bsdtar -xf gsettings-desktop-schemas-3.4.1.tar.xz || exit 1
   cd gsettings-desktop-schemas-3.4.1
   ./configure --prefix=/opt/macports-avidemux
   make 
   make install

else

   printf '\n%s\n\n' 'gsettings-desktop-schemas already installed!'

fi


echo
echo "print missing dylibs:  ... make sure there is no dylib missing in install directory /usr/local-avidemux ..."
find /usr/local-avidemux "${avidemux_src_dir}" -iname "*.dylib" | xargs basename | sort | uniq -u


#cd /tmp
#rm -rf "${avidemux_tmp_dir}"


[[ -d '/opt/local-off' ]] && mv -iv /opt/local-off /opt/local
[[ -d '/usr/local-off' ]] && mv -iv /usr/local-off /usr/local

dscl . -change /Users/macports NFSHomeDirectory "${MP_PREFIX}/var/macports/home" /opt/local/var/macports/home 

exit 0


  
}

port_configuration() {
  #!/bin/bash
# Script for users to use to report information that might be relevant when reporting 
# tickets on trac.
# Inspired by Homebrew's `brew --config`

# TODO: set stuff to variables so commands do NOT have to be run twice
if [ -z "$(which port)" ]; then
  echo "MacPorts not found; this script is primarily for use with MacPorts."
  exit 0
fi

if [ -x "$(which clear)" ]; then
  clear
else
  echo ""
fi

echo "Configuration:"
echo ""

if [ -x "$(which port)" ]; then
  sleep 1
  echo "\"port\" command found at $(which port)"
else
  sleep 1
  echo "Warning: No \"port\" executable found."
fi
if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname "$(dirname ${REAL_PORT})")
  echo "Assuming your MacPorts prefix is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname "$(dirname $(which port))")
  echo "Your MacPorts prefix is ${MP_PREFIX}"
fi
if [ -x "$(which tclsh)" ]; then
  echo "First Tcl in path found at $(which tclsh)"
  echo "All \"tclsh\"-es in your PATH:"
  # TODO: find a way to print line-by-line that actually works (see also below)
  for line in $(which -a tclsh); do
    printf "${line}\n"
  done
  unset line
else
  echo "Warning: No \"tclsh\" executable found."
fi
if [ ! -z "$(port version)" ]; then
  echo "MacPorts is at $(port version | tr V v)"
else
  echo "Warning: could not determine the version of MacPorts."
fi
# This one takes a while so we will NOT bother testing it before
# actually running it
echo "You have $(port -q installed | wc -l | tr -d [:blank:]) ports installed."
if [ ! -z "$(port platform)" ]; then
  echo "\"port platform\" reports: $(port platform)"
else
  echo "Warning: cannot determine platform."
fi
if [ ! -z "$(uname -m)" ]; then
  echo "Computer hardware architecture (uname -m) is $(uname -m)"
else
  echo "Warning: cannot determine architecture."
fi
if [ ! -z "$(uname -v)" ]; then
  echo "OS kernel version is: $(uname -v)"
else
  echo "Warning: cannot determine kernel version."
fi
echo ""
sleep 1
if [ -z "$(which xcodebuild)" ]; then
  echo "Xcode CLT not found, please install them."
else
  echo "xcodebuild found at $(which xcodebuild)"
  echo "Xcode is $(xcodebuild -version)"
  echo "The following Xcode sdks were found:"
  echo ""
  sleep 1
  for line in "$(xcodebuild -showsdks)\n"; do
    printf "%s\n" "${line}"
    sleep 1
  done
  unset line
fi
sleep 1
if [ -x "$(which clear)" ]; then
  clear
else
  echo ""
fi

echo "Environment:"
echo ""
sleep 1
# The pipe through sed is for security (among other reasons)
for line in "$(env | sort | uniq | sed "s|$HOME|\\~|")"; do
  printf "%s\n" "${line}"
done
unset line
echo ""
sleep 1
echo "This script was run as \"$0\" by user \"$(whoami)\" in $(pwd)"
}

port-copy () {
# This script was taken from https://trac.macports.org/wiki/howto/AdvancedDailyAdm

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi


#!${MP_PREFIX}/bin/bash

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/macports
# "/macports" was what was originally used in this script
fi

declare prefix=${2:-"$MP_PREFIX"}

#!${prefix}/bin/bash

(   cd  $( dirname ${0} )

if [ -z "$1" ]; then
  echo "Usage: $(basename ${0}) portname"
  exit 1
fi
if [ -z "$(port list ${1})" ]; then
  echo "Error: port $1 not found"
  exit 1
fi

declare -a info=( $( find "${prefix}"/var/macports/sources/rsync.macports.org/release/ports -iname "${1}" | tr '/' ' ' ) )
declare portName=${info[$(( ${#info[@]}-1 ))]}
declare portCategory=${info[$(( ${#info[@]}-2 ))]}

mkdir -p portfiles/${portCategory}/${portName}
cp ${prefix}/var/macports/sources/rsync.macports.org/release/ports/${portCategory}/${portName}/Portfile \
   portfiles/${portCategory}'/'${portName}/'Portfile.orig'

) ; wait
}

port_depcheck (){
  #!/bin/bash
# A script to check the dependencies of a port against which libraries the port actually 
# links against.
# `otool` is an OS X thing (from cctools), so do NOT go expecting to run this on 
# other platforms

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 1
fi
if [ -z "$1" ]; then
  echo "Usage: $(basename $0) portname"
  exit 1
fi
if [ -z "$(port list $1)" ]; then
  echo "Error: port $1 not found"
  exit 1
fi
if [ "$(port installed $1)" = "None of the specified ports are installed." ]; then
  echo "$(port installed $1)"
  exit 1
fi

tempfoo=$(basename $0)
# I added the suffix stuff before I knew that `mktemp` already added one for you;
# I left them in anyway though because why not
# TODO:
# -[ ] Handle other special timezones besides EDT
# -[ ] Actually, just handle the output of `date` better in general
if [ "$(date | cut -d\  -f5)" != "EDT" ]; then
  SUFFIX_PT1=$(date | cut -d\  -f5 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f7)
else
  SUFFIX_PT1=$(date | cut -d\  -f4 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f6)
fi

SUFFIX=${SUFFIX_PT1}${SUFFIX_PT2}

# The first few times I tried this script I had some trouble with my $TMPDIR;
# that is why I am making sure it exists and is set here.
if [ -z "$TMPDIR" ]; then
  export TMPDIR=/tmp
fi
# This might be a paradox, but I cannot think of a better way to make sure that
# this call to mkdir will actually succeed...
if [ ! -d $TMPDIR -a -w ${TMPDIR}/.. ]; then
  mkdir -p $TMPDIR
fi

# TODO: 
# -[ ] Make a function (or use a loop) to do this so I do not have to
#      copy-n-paste as much
TMPFILE0=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}0.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create zeroth temp file, exiting..."
  exit 1
fi
TMPFILE1=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}1.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create first temp file, exiting..."
  exit 1
fi
TMPFILE2=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}2.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create second temp file, exiting..."
  exit 1
fi
TMPFILE3=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}3.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create third temp file, exiting..."
  exit 1
fi
TMPFILE4=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}4.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create fourth temp file, exiting..."
  exit 1
fi

delete_tmpfiles() {
    for TMPFILE_TO_DELETE in "${TMPFILE0}" "${TMPFILE1}" "${TMPFILE2}" "${TMPFILE3}" "${TMPFILE4}"; do
      if [ -w "${TMPDIR}" -a -w "${TMPFILE_TO_DELETE}" ]; then
          rm -f "${TMPFILE_TO_DELETE}"
      fi
    done
}

# This one gets a special case because there are more reasons to delete it:
delete_tmpfile3() {
    if [ -w "${TMPDIR}" -a -w "${TMPFILE3}" ]; then
        rm -f "${TMPFILE3}"
    fi
}

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/opt/local
fi

# TODO:
# -[ ] Figure out if it is safe to remove the dependencies that are probably due
#      to libtool overlinking
# -[ ] Actually do the removing

echo "Finding MacPorts libraries that ${1} links against..."
# I should find a way to not have to pipe so much stuff through `cut` here...
# http://trac.macports.org/ticket/38428
MACH_O_FILES=$(port -q contents $1 | xargs /usr/bin/file | grep Mach-O | cut -d\: -f1 | cut -d\  -f1 | uniq)
if [ ! -z "${MACH_O_FILES}" ]; then
  LINKED_AGAINST_LIBS=$(echo "${MACH_O_FILES}" | xargs otool -L | grep "\ version\ " | grep "${MP_PREFIX}" | sort | uniq | cut -d\  -f1) 
  echo "${LINKED_AGAINST_LIBS}" >> "${TMPFILE0}"
  SYMBOLS=$(for macho in ${MACH_O_FILES}; do if [ ! -z "${macho}" ]; then nm -m "${macho}" 2>/dev/null && echo ""; fi && echo ""; done && echo "")
  echo "${SYMBOLS}" >> "${TMPFILE4}"
  echo "" >> "${TMPFILE4}"
  if [ ! -z "$LINKED_AGAINST_LIBS" ]; then
    # This is the part where we actually get the ports linked against:
    echo $(cat "${TMPFILE0}" | xargs port -q provides 2>/dev/null | grep "is provided by" | tee -a /dev/tty | cut -d\: -f2 | sort | uniq) | sed "s|${1} ||" | tr \  \\n >> "${TMPFILE1}"
    if [ ! -z "${SYMBOLS}" -a -e "${TMPFILE4}" ]; then
      if [ -z "${PORT_DEPCHECK_SKIP_NM_SYMBOL_CHECK}" ]; then
        echo "Checking symbols in linked-against libraries..."
        for MP_LIBRARY in $(echo "${LINKED_AGAINST_LIBS}" | uniq | xargs basename | uniq | cut -d. -f1 | uniq | cut -d\- -f1 | uniq); do
          printf "Checking to see if %s actually uses symbols from %s... " "${1}" "${MP_LIBRARY}"
          if [ ! -z "$(grep ${MP_LIBRARY} ${TMPFILE4})" ]; then
            echo "yes"
          else
            PORT_TO_REMOVE="$(cat ${TMPFILE0} | uniq | sort | uniq | xargs port -q provides 2>/dev/null | uniq | sort | uniq | grep ${MP_LIBRARY} | uniq | sort | uniq | cut -d\: -f2 | uniq | sort | uniq | tr -d [:blank:])"
            if [ -z "${PORT_DEPCHECK_KEEP_PORTS_THAT_FAIL_SYMBOL_CHECK}" ]; then
              echo "no (TODO: use sed properly to remove \"${PORT_TO_REMOVE}\" from list of dependencies)"
            else
              echo "no (an environment variable is set; remove \"${PORT_TO_REMOVE}\" from the list of dependencies manually)"
            fi
          fi
        done
      else
        echo "The environment variable to skip the symbol check is set."
      fi
    else
      echo "Warning: libraries have no symbols... (how did that happen?)"
    fi
  else
    echo "${1} does not actually link against any MacPorts libraries, exiting..."
    delete_tmpfiles
    exit 1
  fi
else
  echo "${1} does not actually contain any mach-o binaries, exiting..."
  delete_tmpfiles
  exit 1
fi

if [ "$(port -q version | cut -d: -f2 | cut -d. -f1)" -eq 2 -a "$(port -q version | cut -d: -f2 | cut -d. -f2)" -lt 2 ]; then
  if [ ! -z "$(port -q installed libtool)" ];then
    echo "Finding which linkages might be due to libtool over-linking..."
    LIBTOOL_ARCHIVES=$(port -q contents $1 | xargs file | grep "libtool library file" | cut -d\: -f1 | cut -d\  -f1 | uniq)
    if [ ! -z "$LIBTOOL_ARCHIVES" ]; then
      DEPENDENCY_LIBS=$(cat "${LIBTOOL_ARCHIVES}" | grep "dependency_libs" | tr \  \\n | grep "$MP_PREFIX" | grep \.la)
      # TODO:
      # -[ ] Handle the dangling single-quotes in a way that does not
      #      confuse the syntax highlighting in my text editor...
      if [ ! -z "$DEPENDENCY_LIBS" ]; then
        echo "${DEPENDENCY_LIBS}"
        echo "Checking which ports provide dependency_libs entries in these libtool archives..."
        DEPENDENCY_PROVIDERS=$(echo "${DEPENDENCY_LIBS}" | xargs port -q provides | cut -d\: -f2 | uniq | sort | uniq | tr -d '[:blank:]' | sed "s|${1}||" | tr -d '[:blank:]' | uniq | tee -a /dev/tty)
        echo "${DEPENDENCY_PROVIDERS}" >> "${TMPFILE3}"
      else
        echo "libtool archives have already been cleared of dependency_libs; libtool over-linking likely is not a problem..."
        delete_tmpfile3
      fi
    else
      echo "Actually, no libtool archives were found, so never mind."
      delete_tmpfile3
    fi
  else
    echo "You do not have the libtool port installed; no need to check for libtool over-linking."
    delete_tmpfile3
  fi
else
  echo "Checking libtool archives for overlinking should not be necessary for your MacPorts version ($(port -q version)), unless you have NOT rebuilt everything since you updated..."
  echo "This script does NOT know whether or not you have rebuilt as such though, so we shall assume the best of you and skip the libtool-archives check."
  echo "(the libtool-archives check was just a back-up check in case the check with \`nm(1)\` failed, anyways, so skipping it should be harmless)"
  delete_tmpfile3
fi

echo "Finding the libraries that $(port file ${1}) lists as dependencies..."
ACTIVE_VARIANTS=$(port -q installed "${1}" | grep \(active\) | cut -d\  -f4)
echo "${1} is installed with the following active variants: ${ACTIVE_VARIANTS}"
echo "So we shall find the dependencies for those variants..."
# I would like there to be a `lib_depof:` type of pseudo-portname to use here: 
# https://trac.macports.org/ticket/38381
port info --line --depends_lib "${1}" "${ACTIVE_VARIANTS}" | tr ',' '\n' | tee -a /dev/tty | awk -F ':' '{ print $NF; }' | sort | uniq >> "${TMPFILE2}"

echo "Comparing the list of library linkages with the list of library dependencies..."
DIFF_CONTENTS=$(diff -iwBu --strip-trailing-cr "${TMPFILE2}" "${TMPFILE1}")
if [ -z "${DIFF_CONTENTS}" ]; then
  echo "No difference in dependencies, exiting."
  delete_tmpfiles
  exit 1
else
  DIFF_FILE=${TMPDIR}/${1}-deps.${SUFFIX}.diff
  echo "$DIFF_CONTENTS" | tee "${DIFF_FILE}"
  echo "Output a diff file to ${DIFF_FILE}"
fi
}

port_gen_patches (){
#
# Copyright (C) 2009 Roy Liu
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    * Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the author nor the names of any contributors may be
#      used to endorse or promote products derived from this software without
#      specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# taken from https://trac.macports.org/ticket/21640

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

if [[ ! -d "$1" || ! -d "$2" ]]; then

    echo "Please specify two directories."
    exit 1
fi

CURRENT=$PWD
WORK_DIR=$HOME/.cache/gen_macports_patches

rm -f patch.tgz
rm -rf $WORK_DIR/files-patch $WORK_DIR/files-add

mkdir -p $WORK_DIR
mkdir -p $WORK_DIR/files-patch
mkdir -p $WORK_DIR/files-add
rsync -r --delete --exclude=.svn --exclude=/.git --exclude=.DS_Store "$1"/ $WORK_DIR/src
rsync -r --delete --exclude=.svn --exclude=/.git --exclude=.DS_Store "$2"/ $WORK_DIR/dst

cd $WORK_DIR && diff -u -r src dst > tmp-diff; cd "$CURRENT"

# Create patch files.

rm -rf $WORK_DIR/tmp-dir
mv $WORK_DIR/dst $WORK_DIR/tmp-dir

cd $WORK_DIR && patch -p0 --dry-run < tmp-diff | sed \
    -e "s/^patching file src\\/\\(.*\\)\$/\\1/g" \
    -e "s/^patching file 'src\\/\\(.*\\)'\$/\\1/g" \
    > tmp-list-patch; cd "$CURRENT"
cd $WORK_DIR && patch -p0 -b -z ".orig" < tmp-diff; cd "$CURRENT"
cd $WORK_DIR/src && cat ../tmp-list-patch | xargs -I{} sh -c "diff -u \"{}\".orig \"{}\" > ../files-patch/patch-\"\$(basename \"{}\")\".diff"; cd "$CURRENT"

mv $WORK_DIR/tmp-dir $WORK_DIR/dst

# Create add files.

cd $WORK_DIR && cat tmp-diff | sed -n -e "s/^Only in dst\\(\\/\\{0,1\\}\\)\\(.*\\): \\(.*\\)\$/\\2\\1\\3/gp" > tmp-list-add; cd "$CURRENT"
cd $WORK_DIR && cat tmp-list-add | xargs -I{} echo "adding file 'dst/{}'"
cd $WORK_DIR && rsync -r --files-from=tmp-list-add dst files-add; cd "$CURRENT"

tar -C $WORK_DIR -c -z -f patch.tgz files-patch files-add
}


port_install () {

#!/bin/bash
# This script was taken from https://trac.macports.org/wiki/howto/AdvancedDailyAdm
# If you are using the copy of this that came with the "macportsscripts" port,
# then you probably will NOT need to use this, as that should mean that you
# already have MacPorts installed

################################################################################
# copyright Bjarne D Mathiesen
#           København ; Danmark ; Europa
#           macintosh .at. mathiesen .dot. info
# date      04/07-2007
# revised   02/12-2007  implemented automatic patching of Portfiles
#           28/12-2009  fixed the download link
#                       modified source/build directory
#                       removed sudo from commands
#           18/06-2011  added default values for the parameters
#                       updated path values for XCode4
#
# this script is released under the BSD license
# the author welcomes feedback and improvements
# 

usage() {
cat <<EOT
purpose : to automate the whole install process
\${1} : action                 [ install (default) , paths ]
\${2} : install prefix         ( default /macports )
\${3} : macports base version  ( default 2.2.1 )
EOT
}

declare action=${1:-"install"}
# Leaving this alternate prefix as-is, as we are installing a new MacPorts there
declare prefix=${2:-"/macports"}
declare version=${3:-"2.2.1"}

case ${action} in
########################
# setup the system paths
'paths')

mkdir -p  /etc/paths.d
cp    -np /etc/paths /etc/paths.orig
mv    -n  /etc/paths /etc/paths.d/999macosx
touch     /etc/paths

echo "${prefix}/bin"        >  /etc/paths.d/000macports
echo "${prefix}/sbin"       >> /etc/paths.d/000macports

echo "/Developer/usr/bin"   >  /etc/paths.d/888developer
echo "/Developer/usr/sbin"  >> /etc/paths.d/888developer

mkdir -p  /etc/manpaths.d
cp    -np /etc/manpaths /etc/manpaths.orig
mv    -n  /etc/manpaths /etc/manpaths.d/999macosx
touch     /etc/manpaths

echo "${prefix}/share/man"  > /etc/manpaths.d/000macports
echo "/Developer/usr/share/man"     >  /etc/manpaths.d/888developer
echo "/Developer/usr/X11/share/man" >> /etc/manpaths.d/888developer

# path_helper is buggy under 10.5
# however, messing with system stuff is a bad idea

;;
##################
# install macports
'install')

export OLDPWD=$(pwd)
if [ ! -z "$TMPDIR" ]; then
  cd $TMPDIR
  echo "cd $(pwd)"
else
  export TMPDIR=/tmp
  cd $TMPDIR
  echo "cd $(pwd)"
fi

if [ ! -e MacPorts-${version}.tar.gz ]
then
    curl -O --url "http://distfiles.macports.org/MacPorts/MacPorts-${version}.tar.gz"
fi

rm  -rf  ./MacPorts-${version}
tar -zxf   MacPorts-${version}.tar.gz

if [ -d /Developer/SDKs/MacOSX10.6.sdk/usr/X11/lib ]; then
  export MP_LDFLAGS=-L/Developer/SDKs/MacOSX10.6.sdk/usr/X11/lib
fi

set -e

cd MacPorts-${version}
./configure LDFLAGS=${MP_LDFLAGS} --prefix=${prefix}
make
make install

# update MacPorts itself
${prefix}/bin/port -d selfupdate

# let us get gawk
${prefix}/bin/port install gawk

# let us get bash
${prefix}/bin/port install bash

;;
# default
*)
usage
esac

}

port_strac (){
  #!/bin/bash
# TODO: remember where this came from

if [ $# -lt 2 ]; then
  echo "Usage:"
  echo "macportstrac.sh query 'port name'"
  echo "macportstrac.sh viewticket 'ticket number'"
  exit
fi

INPUT=($@)
unset INPUT[0]

if [ $1 == "query" ]; then
  for PORT in ${INPUT[*]}; do
    echo "Port: ${PORT}"
    curl -s "http://trac.macports.org/query?status=!closed&port=~${PORT}" | grep ' assigned\| closed\| new\| reopened\|href.*/ticket/' | sed -e 's|<[^>]*>||g'
  done
fi

if [ $1 == "viewticket" ]; then
  for TICKET in ${INPUT[*]}; do
    echo "Ticket: #${TICKET}"
    open "http://trac.macports.org/ticket/${TICKET}"
  done
fi


}

port_update () {
#!/bin/bash
# This script was taken from https://trac.macports.org/wiki/howto/AdvancedDailyAdm

#
# usage:
# ${1}: the macports install path
#

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi


#!${MP_PREFIX}/bin/bash

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/macports
# "/macports" was what was originally used in this script
fi

(   cd  $( dirname ${0} )

printf  "\n"
echo        '+----------------+'
echo        '| macportsupdate |'
echo        '+----------------+'

declare prefix=${1:-"$MP_PREFIX"}

#!${prefix}/bin/bash

set -e

declare rsyncMacportsOrg='/var/macports/sources/rsync.macports.org/release/ports'

echo    "selfupdating & syncing all repositories in ${prefix}"
installPath=${prefix}
${installPath}/bin/port -d selfupdate
if [ -d newPorts/_resources ]; then
  cp -Rv  newPorts/_resources \
          ${installPath}${rsyncMacportsOrg}
fi

printf    "\ncopy additional files to the ports \n"
for filesDir in $(find portfiles -type d -name 'files')
do
    mkdir -p ${installPath}${rsyncMacportsOrg}/${filesDir#*portfiles/}
    cp -Rv ${filesDir}/* \
           ${installPath}${rsyncMacportsOrg}/${filesDir#*portfiles/}
done

printf    "\npatching the portfiles \n"
for portPatch in $(find portfiles -type f -name 'patch-Portfile')
do
    patchFile=$( sed -En -e '1,1p' ${portPatch} | tr -s "\t" " " | cut -f2 -d ' ' )
    patch -u <${portPatch} ${patchFile}
done

echo ''
${installPath}/bin/port outdated

printf    "\nupgrading the outdated ports \n"
for outDated in $(${installPath}/bin/port outdated | sed -e '1,1d' | tr -s " \t" | cut -f 1 -d ' ')
do 
    ${installPath}/bin/port -cuRp upgrade ${outDated}
done


printf    "\nremoving macport saved files \n"
# shellcheck and `find(1)`'s own warning messages conflict here w.r.t. what
# to do with the argument to `find -iname` here...
find ${installPath} -iname "*.mpsaved" -delete
find ${installPath} -iname "*.mp_*" -delete

printf    "\nremoving inactive ports \n"
${installPath}/bin/port installed | sed -e '1,1d' -e '/active/d' | xargs -n2 ${installPath}/bin/port uninstall

) ; wait


}


port_mp_trac_category_ports () {
# Taken from https://trac.macports.org/wiki/KDEProblems/KDETickets/KDE4-Category
# There is a separate one for localization ones at:
# https://trac.macports.org/wiki/KDEProblems/KDETickets/KDE4-Category/KDE4-l10n
# (TODO: make a more generalizable version?)


echo "||'''Port'''||'''Category'''||'''Repository'''||'''Tickets'''||"; \
for name in $(port echo "category:(\W|^)$1(\W|$)"); do \
    port file $name 2>&1 \
    | grep 'tarballs' \
    | sed -E \
        -e 's|/opt/local/var/macports/sources/rsync.macports.org/release/tarballs/ports/||' \
        -e 's|^(.*)/Portfile$|trunk/dports/\1|' \
    | awk -v NAME=$name 'BEGIN \
        { FS = "/" } ; \
        { printf "||[source:"$0" "NAME"]||[source:" } ; \
        { \
            for (x=1; x<NF; x++) { \
                printf "%s", $x ; \
                if (x != NF-1) printf "/" \
            } \
        } ; \
        { printf " "$(NF-1)"]||[source:" } ; \
        { \
            for (x=1; x<NF-1; x++) { \
                printf "%s", $x ; \
                if (x != NF-2) printf "/" \
            } \
        } ; \
        { printf " "$(NF-3)"]||||[[TicketQuery(port="NAME"&status=new|assigned|reopened)]]||\n" } ; \
        ' ;
done

}

port_Point_Cloud_Library_1.5.1 (){
#!/bin/bash
# This script was taken from https://trac.macports.org/wiki/Scripts/Point_Cloud_Library_1.5.1_script

# references:
# - http://www.pointclouds.org/about.html
# - http://www.pointclouds.org/downloads/
# - http://pointclouds.org/downloads/macosx.html
# - http://dev.pointclouds.org/projects/pcl/wiki/How_to_create_DMG_installers
# - http://pointclouds.org/documentation/tutorials/compiling_pcl_macosx.php
# - http://pointclouds.org/documentation/tutorials/building_pcl.php#building-pcl
# - http://www.kammerl.de/pcl/

# To reduce heat generation consider to increase fan rpm values by using smcFanControl 2.3, http://www.eidac.de/?p=207.
# smcFanControl is just an application.
# smcFanControl installs no permanent background processes or daemons.
# smcFanControl does NOT let you set a minimum speed to a value below Apple's defaults.
# To uninstall it, just drag it into the trash.

if [ "$(whoami)" != "root" ]; then
  sudo -H -i
fi

if [ ! -x /usr/local/bin/testport ]; then
    echo "This script requires the testport script to be installed as /usr/local/bin/testport"
    exit 1
fi

# cf. https://trac.macports.org/wiki/Scripts/testport_script
/usr/local/bin/testport -p -l /opt/macports-test-universal
export PATH="/opt/macports-test-universal/bin:/opt/macports-test-universal/sbin:/usr/bin:/bin:/usr/sbin:/sbin"
alias testport='/usr/local/bin/testport'

export LC_ALL=C 

# clang-3.2 +universal
testport -l /opt/macports-test-universal clang-3.2 +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'


# MacPorts: tar: Write error: Broken pipe
# --->  Installing llvm-3.0 @3.0_4+universal
# Error: Target org.macports.install returned: shell command failed (see log for details)
# Error: Failed to install llvm-3.0
# Log for llvm-3.0 is at: /opt/macports-test-universal/var/macports/logs/_opt_macports-test-universal_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_llvm-3.0/llvm-3.0/main.log
#
# port log llvm-3.0
#    ...
#    :info:install bzip2/libbzip2: internal error number 1007.
#    ...
#    :info:install *** A special note about internal error number 1007 ***
#    ...
#    :info:install tar: Write error: Broken pipe
#    :info:install shell command " cd "/opt/macports-test-universal/var/macports/build/_opt_macports-test-universal_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_llvm-3.0/llvm-3.0/work/destroot" && /usr/bin/tar -cvf - . | /usr/bin/bzip2 -c9 > /opt/macports-test-universal/var/macports/software/llvm-3.0/llvm-3.0-3.0_4+universal.darwin_10.i386-x86_64.tbz2 " returned error 3
#    :error:install Target org.macports.install returned: shell command failed (see log for details)
#    ...

cd "$(port dir llvm-3.0)"/work/destroot
/usr/bin/tar -cvf - . | /usr/bin/bzip2 -c9 > /opt/macports-test-universal/var/macports/software/llvm-3.0/llvm-3.0-3.0_4+universal.darwin_10.i386-x86_64.tbz2 

# redo: clang-3.2 +universal
testport -l /opt/macports-test-universal clang-3.2 +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'


# MacPorts: tar: Write error: Broken pipe  (when installing llvm-3.2)
# ...
#cd "$(port dir llvm-3.2)"/work/destroot
#/usr/bin/tar -cvf - . | /usr/bin/bzip2 -c9 > /opt/macports-test-universal/var/macports/software/llvm-3.2/llvm-3.2-3.2-r157234_0+assertions+universal.darwin_10.i386-x86_64.tbz2 
#
# alternative to tar ... | bzip2 ...
#llvmdir='/opt/macports-test-universal/var/macports/software/llvm-3.2'
#tar -cvf "${llvmdir}/llvm-3.2.tar" .
#/usr/bin/bzip2 -c9 "${llvmdir}/llvm-3.2.tar" > "${llvmdir}/llvm-3.2-3.2-r157234_0+assertions+universal.darwin_10.i386-x86_64.tbz2"
#rm -v "${llvmdir}/llvm-3.2.tar"
#
# redo: clang-3.2 +universal
#testport -l /opt/macports-test-universal clang-3.2 +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'


# glib2 +universal
testport -l /opt/macports-test-universal glib2 +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'


# apple-gcc42 +universal
# gcc47 +universal
# gcc48 +universal
[[ -L '/usr/include/malloc.h' ]] && sudo mv -iv /usr/include/malloc.h /usr/include/malloc.h.moved
testport -l /opt/macports-test-universal apple-gcc42 +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'
testport -l /opt/macports-test-universal gcc47 +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'
testport -l /opt/macports-test-universal gcc48 +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'



# cmake +universal
testport -l /opt/macports-test-universal cmake +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'

# boost +universal
testport -l /opt/macports-test-universal boost +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'


# doxygen +universal
testport -l /opt/macports-test-universal doxygen +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'


# Error: You cannot install gd2 for the architecture(s) x86_64 i386 because
# Error: its dependency fontconfig only contains the architecture(s) x86_64.
# cf. "Error: Failed to install fontconfig", https://trac.macports.org/ticket/30329
# Non-fat file: /opt/macports-test-universal/lib/libfontconfig.dylib is architecture: x86_64
# Architectures in the fat file: /opt/macports-test-universal/lib/libfontconfig.dylib are: i386 x86_64 
# lipo -info /opt/macports-test-universal/lib/*.dylib | grep -i 'Non-fat file'
port -v installed pkgconfig libiconv expat freetype libiconv fontconfig
lipo -info /opt/macports-test-universal/lib/libfontconfig.dylib
port -n upgrade --force fontconfig +universal


# gd2 +universal
port clean --all gd2
testport -l /opt/macports-test-universal gd2 +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'

# netpbm +universal
testport -l /opt/macports-test-universal netpbm +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'

# graphviz +universal
port clean --all graphviz
testport -l /opt/macports-test-universal graphviz +universal configure.cc='/usr/bin/gcc-4.2' configure.cxx='/usr/bin/g++-4.2'


# redo: doxygen +universal
#testport -c -l /opt/macports-test-universal doxygen +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'
testport -l /opt/macports-test-universal doxygen +universal configure.cc='/usr/bin/llvm-gcc-4.2' configure.cxx='/usr/bin/llvm-g++-4.2'



# flann (not universal!)
testport -l /opt/macports-test-universal  flann  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'


# py27-sphinx +universal
testport -l /opt/macports-test-universal  py27-sphinx +universal  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'


# google-test +universal
# port info google-test
# google-test @1.5.0 (devel) (May 2012)
# googletest version >= 1.6.0 (http://code.google.com/p/googletest/)
# Google's framework for writing C++ tests on a variety of platforms. Used to build test units.
# testport -l /opt/macports-test-universal  google-test +universal  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'


# eigen3 +universal
# qhull +universal
# libusb-devel +universal

export IFS=$' \t\n'
for portname in eigen3 qhull libusb-devel; do
   printf '\n\n%s\n\n' "testport -l /opt/macports-test-universal  ${portname} +universal  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'"
   testport -l /opt/macports-test-universal  "${portname}" +universal  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'
done



# vtk5 +universal+x11
port variants vtk5
testport -l /opt/macports-test-universal  vtk5 +universal+x11  configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'

# sudo port select --set python python27
# sudo port load rsync



# opencv +universal+python27
#testport -l /opt/macports-test-universal ffmpeg +universal
testport -l /opt/macports-test-universal ffmpeg-devel +universal configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'
testport -l /opt/macports-test-universal opencv +universal+python27 configure.cc='/opt/macports-test-universal/bin/clang-mp-3.2' configure.cxx='/opt/macports-test-universal/bin/clang++-mp-3.2'



# OpenNI
# install OpenNI in /usr/local-pcl
# https://github.com/OpenNI/OpenNI/

export PATH="/opt/macports-test-universal/bin:/opt/macports-test-universal/sbin:/usr/bin:/bin:/usr/sbin:/sbin"
cd /Users/${SUDO_USER}/Downloads || exit
[[ ! -f OpenNI.zip ]] && { curl -L -o OpenNI.zip https://github.com/OpenNI/OpenNI/zipball/master || exit; }
rm -rf ./*OpenNI-*
unzip -qq OpenNI.zip
cd ./*OpenNI-*/Platform/Linux*/CreateRedist/
chmod +x RedistMaker 
export CC='/opt/macports-test-universal/bin/clang-mp-3.2' CXX='/opt/macports-test-universal/bin/clang++-mp-3.2'
export CFLAGS='-I/opt/macports-test-universal/include' LDFLAGS='-L/opt/macports-test-universal/lib'  
./RedistMaker 
cd ../Redist/OpenNI*
export X86_CXX=/opt/macports-test-universal/bin/clang++-mp-3.2
export X86_STAGING=/usr/local-pcl
chmod +x install.sh

cat <<-'EOF' | ed -s install.sh
H
/printf "copying shared libraries..."/a
mkdir -p $INSTALL_LIB
.
/printf "copying executables..."/a
mkdir -p $INSTALL_BIN
.
wq
EOF

./install.sh -c "${X86_STAGING}"


# sanitize .dylib install names
otool -L /usr/local-pcl/usr/lib/*
find /usr/local-pcl -type f -name "*.dylib" -print0 | while IFS="" read -r -d "" dylibpath; do
   echo install_name_tool -id "$dylibpath" "$dylibpath"
   install_name_tool -id "$dylibpath" "$dylibpath"
done | nl


otool -L /usr/local-pcl/usr/bin/* /usr/local-pcl/usr/lib/*
find /usr/local-pcl/usr/bin /usr/local-pcl/usr/lib -type f -print0 | xargs -0 otool -L | grep '\.\./\.\./' | sort -u

find /usr/local-pcl/usr/bin /usr/local-pcl/usr/lib -type f -print0 | while IFS="" read -r -d "" file; do
   old='../../Bin/x64-Release/libOpenNI.dylib'
   new='/usr/local-pcl/usr/lib/libOpenNI.dylib'
   sudo install_name_tool -change "$old" "$new" "$file"
done



dos2unixdir() {

crchar="$(printf "\r")"
grep -Ilsr -m 1 -Z -e "${crchar}" . | 
   xargs -0 -n 1 /bin/sh -c '
      crchar="$(printf "\r")"
      echo "crchar: ${1}"
      printf "%s\n" H ",g/${crchar}*$/s///g" wq | /bin/ed -s "${1}"
   ' argv0

return 0

}


# Sensor
# PrimeSensor Modules for OpenNI
# https://github.com/PrimeSense/Sensor

export PATH='/opt/macports-test-universal/bin:/opt/macports-test-universal/sbin:/usr/local-pcl/bin:/usr/bin:/bin:/usr/sbin:/sbin'

cd /Users/${SUDO_USER}/Downloads || exit
[[ ! -f Sensor.zip ]] && { curl -L -o Sensor.zip https://github.com/PrimeSense/Sensor/zipball/master || exit; }
rm -rf ./*Sensor-*
unzip -qq Sensor.zip
cd PrimeSense-Sensor-*
dos2unixdir
cd ../PrimeSense-Sensor-*/Platform/Linux/CreateRedist
export CC='/opt/macports-test-universal/bin/clang-mp-3.2' CXX='/opt/macports-test-universal/bin/clang++-mp-3.2'
export CFLAGS='-I/usr/include -I/opt/macports-test-universal/include -I/usr/local-pcl/usr/include -I/usr/local-pcl/usr/include/ni' LDFLAGS='-L/opt/macports-test-universal/lib -L/usr/local-pcl/usr/lib'  
xattr -d com.apple.quarantine RedistMaker

# remove -j option to make command in RedistMaker file
printf '%s\n' H '/-j$(calc_jobs_number)/s///' wq | ed -s RedistMaker

./RedistMaker 

cd ../Redist/Sensor-Bin-MacOSX-*
export X86_CXX=/opt/macports-test-universal/bin/clang++-mp-3.2
export X86_STAGING=/usr/local-pcl
chmod +x install.sh
./install.sh -c "${X86_STAGING}"


# sanitize .dylib install names

otool -L /usr/local-pcl/usr/bin/* /usr/local-pcl/usr/lib/*
find /usr/local-pcl/usr/lib /usr/local-pcl/usr/bin -type f -print0 | xargs -0 otool -L | grep '\.\./\.\./' | sort -u

find /usr/local-pcl/usr/lib /usr/local-pcl/usr/bin -type f -print0 | while IFS="" read -r -d "" file; do

   old1='../../Bin/x64-Release/libOpenNI.dylib'
   new1='/usr/local-pcl/usr/lib/libOpenNI.dylib'

   old2='../../Bin/x64-Release/libXnCore.dylib'
   new2='/usr/local-pcl/usr/lib/libXnCore.dylib'

   old3='../../Bin/x64-Release/libXnDDK.dylib'
   new3='/usr/local-pcl/usr/lib/libXnDDK.dylib'

   old4='../../Bin/x64-Release/libXnDeviceFile.dylib'
   new4='/usr/local-pcl/usr/lib/libXnDeviceFile.dylib'

   old5='../../Bin/x64-Release/libXnDeviceSensorV2.dylib'
   new5='/usr/local-pcl/usr/lib/libXnDeviceSensorV2.dylib'

   old6='../../Bin/x64-Release/libXnFormats.dylib'
   new6='/usr/local-pcl/usr/lib/libXnFormats.dylib'

   sudo install_name_tool -change "$old1" "$new1" -change "$old2" "$new2" -change "$old3" "$new3" -change "$old4" "$new4" -change "$old5" "$new5" -change "$old6" "$new6" "$file"

done


# sanitize .dylib install names
find /usr/local-pcl -type f -name "*.dylib" -print0 | while IFS="" read -r -d "" dylibpath; do
   echo install_name_tool -id "$dylibpath" "$dylibpath"
   install_name_tool -id "$dylibpath" "$dylibpath"
done | nl


otool -L /usr/local-pcl/usr/bin/* /usr/local-pcl/usr/lib/*


# not needed anymore
# cminpack 1.2.2 (in /usr/local-pcl)
# http://devernay.free.fr/hacks/cminpack/index.html
curl -L -O http://devernay.free.fr/hacks/cminpack/cminpack-1.2.2.tar.gz
rm -rf cminpack-1.2.2
tar -xf cminpack-1.2.2.tar.gz
cd cminpack-1.2.2
mkdir build
cd build
cmake -DUSE_FPIC=ON -DSHARED_LIBS=ON -DBUILD_EXAMPLES=OFF -DCMAKE_INSTALL_PREFIX=/usr/local-pcl ..
make
sudo make install
otool -L /usr/local-pcl/lib/libcminpack.dylib
sudo install_name_tool -id /usr/local-pcl/lib/libcminpack.1.0.90.dylib /usr/local-pcl/lib/libcminpack.1.0.90.dylib


# PCL 1.5.1 (2012.02.22)
# http://www.pointclouds.org/downloads/
cd /Users/${SUDO_USER}/Downloads
[[ ! -f 'PCL-1.5.1-Source.tar.bz2' ]] && curl -L -O http://www.pointclouds.org/assets/files/1.5.1/PCL-1.5.1-Source.tar.bz2
rm -rf PCL-1.5.1-Source
tar -xf PCL-1.5.1-Source.tar.bz2
cd PCL-1.5.1-Source
#dos2unixdir
export PATH='/opt/macports-test-universal/bin:/opt/macports-test-universal/sbin:/usr/local-pcl/bin:/usr/local-pcl/sbin:/usr/bin:/bin:/usr/sbin:/sbin'
mkdir build
cd build

# error: no member named 'at' in namespace 'pcl::io::ply' fixed in PCL 1.6
# see: http://www.pcl-users.org/Couldn-t-install-with-Homebrew-td4000766.html and 
#        http://dev.pointclouds.org/projects/pcl/repository/revisions/4918

# all three variants below did cause build / compiler (gcc) errors in the make build phase on Mac OS X 10.6.8
###env CC=/opt/macports-test-universal/bin/clang-mp-3.2 CXX=/opt/macports-test-universal/bin/clang++-mp-3.2 \
###env CC=/opt/macports-test-universal/bin/gcc-mp-4.7 CXX=/opt/macports-test-universal/bin/g++-mp-4.7 \
###env CC=/opt/macports-test-universal/bin/gcc-mp-4.8 CXX=/opt/macports-test-universal/bin/g++-mp-4.8 \

#env CC=/usr/bin/gcc-4.2 CXX=/usr/bin/g++-4.2 \
env CC=/opt/macports-test-universal/bin/gcc-apple-4.2 CXX=/opt/macports-test-universal/bin/g++-apple-4.2 \
  cmake -DCMAKE_PREFIX_PATH='/opt/macports-test-universal:/usr/local-pcl/usr' -DOPENNI_INCLUDE_DIR=/usr/local-pcl/usr/include/ni \
         -DOPENNI_LIBRARY=/usr/local-pcl/usr/lib/libOpenNI.dylib -DCMAKE_INSTALL_PREFIX=/usr/local-pcl ..


# edit cmake_install.cmake files:  "lib..*\.dylib"  -->  "${CMAKE_INSTALL_PREFIX}/lib/lib..*\.dylib"
printf '\n\n%s\n\n' "${PWD}: install_name_tool search & replace:   \"lib..*.dylib\"   -->   \"\${CMAKE_INSTALL_PREFIX}/lib/lib..*.dylib\""
egrep -Ilsr -Z -e 'install_name_tool' . | xargs -0 egrep -Ils '"lib..*\.dylib"' | nl

egrep -Ilsr -Z -e 'install_name_tool' . | 
   xargs -0 egrep -Ils -Z '"lib..*\.dylib"' |
   xargs -0 -n 1 /bin/sh -c 'printf "%s\n" H "g/\"\(lib..*\.dylib\)\"/s||\"\${CMAKE_INSTALL_PREFIX}/lib/\1\"|g" wq | /bin/ed -s "${1}"' argv0

# for use with gcc-mp-4.7 / g++-mp-4.7 and gcc-mp-4.8 / g++-mp-4.8 only
###egrep -Ilsr -Z -e ' \-Wl ' . | xargs -0 -n 1 /bin/sh -c 'printf "%s\n" H "g/ \-Wl /s|| |g" wq | /bin/ed -s "${1}"' argv0

make 
make install


find -x /usr/local-pcl/usr/bin /usr/local-pcl/usr/lib /usr/local-pcl/bin /usr/local-pcl/lib -type f -print0 | xargs -0 otool -L 2>/dev/null | less
find /usr/local-pcl/usr/bin /usr/local-pcl/usr/lib /usr/local-pcl/bin /usr/local-pcl/lib -type f -print0 | xargs -0 otool -L | grep '\.\./\.\./' | sort -u



}

port_configuration() {
#!/bin/bash
# Script for users to use to report information that might be relevant when reporting 
# tickets on trac.
# Inspired by Homebrew's `brew --config`

# TODO: set stuff to variables so commands do NOT have to be run twice
if [ -z "$(which port)" ]; then
  echo "MacPorts not found; this script is primarily for use with MacPorts."
  exit 0
fi

if [ -x "$(which clear)" ]; then
  clear
else
  echo ""
fi

echo "Configuration:"
echo ""

if [ -x "$(which port)" ]; then
  sleep 1
  echo "\"port\" command found at $(which port)"
else
  sleep 1
  echo "Warning: No \"port\" executable found."
fi
if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname "$(dirname ${REAL_PORT})")
  echo "Assuming your MacPorts prefix is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname "$(dirname $(which port))")
  echo "Your MacPorts prefix is ${MP_PREFIX}"
fi
if [ -x "$(which tclsh)" ]; then
  echo "First Tcl in path found at $(which tclsh)"
  echo "All \"tclsh\"-es in your PATH:"
  # TODO: find a way to print line-by-line that actually works (see also below)
  for line in $(which -a tclsh); do
    printf "${line}\n"
  done
  unset line
else
  echo "Warning: No \"tclsh\" executable found."
fi
if [ ! -z "$(port version)" ]; then
  echo "MacPorts is at $(port version | tr V v)"
else
  echo "Warning: could not determine the version of MacPorts."
fi
# This one takes a while so we will NOT bother testing it before
# actually running it
echo "You have $(port -q installed | wc -l | tr -d [:blank:]) ports installed."
if [ ! -z "$(port platform)" ]; then
  echo "\"port platform\" reports: $(port platform)"
else
  echo "Warning: cannot determine platform."
fi
if [ ! -z "$(uname -m)" ]; then
  echo "Computer hardware architecture (uname -m) is $(uname -m)"
else
  echo "Warning: cannot determine architecture."
fi
if [ ! -z "$(uname -v)" ]; then
  echo "OS kernel version is: $(uname -v)"
else
  echo "Warning: cannot determine kernel version."
fi
echo ""
sleep 1
if [ -z "$(which xcodebuild)" ]; then
  echo "Xcode CLT not found, please install them."
else
  echo "xcodebuild found at $(which xcodebuild)"
  echo "Xcode is $(xcodebuild -version)"
  echo "The following Xcode sdks were found:"
  echo ""
  sleep 1
  for line in "$(xcodebuild -showsdks)\n"; do
    printf "%s\n" "${line}"
    sleep 1
  done
  unset line
fi
sleep 1
if [ -x "$(which clear)" ]; then
  clear
else
  echo ""
fi

echo "Environment:"
echo ""
sleep 1
# The pipe through sed is for security (among other reasons)
for line in "$(env | sort | uniq | sed "s|$HOME|\\~|")"; do
  printf "%s\n" "${line}"
done
unset line
echo ""
sleep 1
echo "This script was run as \"$0\" by user \"$(whoami)\" in $(pwd)"


}

port_copy (){
  #!/bin/bash
# This script was taken from https://trac.macports.org/wiki/howto/AdvancedDailyAdm

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi


#!${MP_PREFIX}/bin/bash

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/macports
# "/macports" was what was originally used in this script
fi

declare prefix=${2:-"$MP_PREFIX"}

#!${prefix}/bin/bash

(   cd  $( dirname ${0} )

if [ -z "$1" ]; then
  echo "Usage: $(basename ${0}) portname"
  exit 1
fi
if [ -z "$(port list ${1})" ]; then
  echo "Error: port $1 not found"
  exit 1
fi

declare -a info=( $( find "${prefix}"/var/macports/sources/rsync.macports.org/release/ports -iname "${1}" | tr '/' ' ' ) )
declare portName=${info[$(( ${#info[@]}-1 ))]}
declare portCategory=${info[$(( ${#info[@]}-2 ))]}

mkdir -p portfiles/${portCategory}/${portName}
cp ${prefix}/var/macports/sources/rsync.macports.org/release/ports/${portCategory}/${portName}/Portfile \
   portfiles/${portCategory}'/'${portName}/'Portfile.orig'

) ; wait

}

port_depcheck (){
  #!/bin/bash
# A script to check the dependencies of a port against which libraries the port actually 
# links against.
# `otool` is an OS X thing (from cctools), so do NOT go expecting to run this on 
# other platforms

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 1
fi
if [ -z "$1" ]; then
  echo "Usage: $(basename $0) portname"
  exit 1
fi
if [ -z "$(port list $1)" ]; then
  echo "Error: port $1 not found"
  exit 1
fi
if [ "$(port installed $1)" = "None of the specified ports are installed." ]; then
  echo "$(port installed $1)"
  exit 1
fi

tempfoo=$(basename $0)
# I added the suffix stuff before I knew that `mktemp` already added one for you;
# I left them in anyway though because why not
# TODO:
# -[ ] Handle other special timezones besides EDT
# -[ ] Actually, just handle the output of `date` better in general
if [ "$(date | cut -d\  -f5)" != "EDT" ]; then
  SUFFIX_PT1=$(date | cut -d\  -f5 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f7)
else
  SUFFIX_PT1=$(date | cut -d\  -f4 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f6)
fi

SUFFIX=${SUFFIX_PT1}${SUFFIX_PT2}

# The first few times I tried this script I had some trouble with my $TMPDIR;
# that is why I am making sure it exists and is set here.
if [ -z "$TMPDIR" ]; then
  export TMPDIR=/tmp
fi
# This might be a paradox, but I cannot think of a better way to make sure that
# this call to mkdir will actually succeed...
if [ ! -d $TMPDIR -a -w ${TMPDIR}/.. ]; then
  mkdir -p $TMPDIR
fi

# TODO: 
# -[ ] Make a function (or use a loop) to do this so I do not have to
#      copy-n-paste as much
TMPFILE0=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}0.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create zeroth temp file, exiting..."
  exit 1
fi
TMPFILE1=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}1.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create first temp file, exiting..."
  exit 1
fi
TMPFILE2=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}2.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create second temp file, exiting..."
  exit 1
fi
TMPFILE3=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}3.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create third temp file, exiting..."
  exit 1
fi
TMPFILE4=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}4.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create fourth temp file, exiting..."
  exit 1
fi

delete_tmpfiles() {
    for TMPFILE_TO_DELETE in "${TMPFILE0}" "${TMPFILE1}" "${TMPFILE2}" "${TMPFILE3}" "${TMPFILE4}"; do
      if [ -w "${TMPDIR}" -a -w "${TMPFILE_TO_DELETE}" ]; then
          rm -f "${TMPFILE_TO_DELETE}"
      fi
    done
}

# This one gets a special case because there are more reasons to delete it:
delete_tmpfile3() {
    if [ -w "${TMPDIR}" -a -w "${TMPFILE3}" ]; then
        rm -f "${TMPFILE3}"
    fi
}

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/opt/local
fi

# TODO:
# -[ ] Figure out if it is safe to remove the dependencies that are probably due
#      to libtool overlinking
# -[ ] Actually do the removing

echo "Finding MacPorts libraries that ${1} links against..."
# I should find a way to not have to pipe so much stuff through `cut` here...
# http://trac.macports.org/ticket/38428
MACH_O_FILES=$(port -q contents $1 | xargs /usr/bin/file | grep Mach-O | cut -d\: -f1 | cut -d\  -f1 | uniq)
if [ ! -z "${MACH_O_FILES}" ]; then
  LINKED_AGAINST_LIBS=$(echo "${MACH_O_FILES}" | xargs otool -L | grep "\ version\ " | grep "${MP_PREFIX}" | sort | uniq | cut -d\  -f1) 
  echo "${LINKED_AGAINST_LIBS}" >> "${TMPFILE0}"
  SYMBOLS=$(for macho in ${MACH_O_FILES}; do if [ ! -z "${macho}" ]; then nm -m "${macho}" 2>/dev/null && echo ""; fi && echo ""; done && echo "")
  echo "${SYMBOLS}" >> "${TMPFILE4}"
  echo "" >> "${TMPFILE4}"
  if [ ! -z "$LINKED_AGAINST_LIBS" ]; then
    # This is the part where we actually get the ports linked against:
    echo $(cat "${TMPFILE0}" | xargs port -q provides 2>/dev/null | grep "is provided by" | tee -a /dev/tty | cut -d\: -f2 | sort | uniq) | sed "s|${1} ||" | tr \  \\n >> "${TMPFILE1}"
    if [ ! -z "${SYMBOLS}" -a -e "${TMPFILE4}" ]; then
      if [ -z "${PORT_DEPCHECK_SKIP_NM_SYMBOL_CHECK}" ]; then
        echo "Checking symbols in linked-against libraries..."
        for MP_LIBRARY in $(echo "${LINKED_AGAINST_LIBS}" | uniq | xargs basename | uniq | cut -d. -f1 | uniq | cut -d\- -f1 | uniq); do
          printf "Checking to see if %s actually uses symbols from %s... " "${1}" "${MP_LIBRARY}"
          if [ ! -z "$(grep ${MP_LIBRARY} ${TMPFILE4})" ]; then
            echo "yes"
          else
            PORT_TO_REMOVE="$(cat ${TMPFILE0} | uniq | sort | uniq | xargs port -q provides 2>/dev/null | uniq | sort | uniq | grep ${MP_LIBRARY} | uniq | sort | uniq | cut -d\: -f2 | uniq | sort | uniq | tr -d [:blank:])"
            if [ -z "${PORT_DEPCHECK_KEEP_PORTS_THAT_FAIL_SYMBOL_CHECK}" ]; then
              echo "no (TODO: use sed properly to remove \"${PORT_TO_REMOVE}\" from list of dependencies)"
            else
              echo "no (an environment variable is set; remove \"${PORT_TO_REMOVE}\" from the list of dependencies manually)"
            fi
          fi
        done
      else
        echo "The environment variable to skip the symbol check is set."
      fi
    else
      echo "Warning: libraries have no symbols... (how did that happen?)"
    fi
  else
    echo "${1} does not actually link against any MacPorts libraries, exiting..."
    delete_tmpfiles
    exit 1
  fi
else
  echo "${1} does not actually contain any mach-o binaries, exiting..."
  delete_tmpfiles
  exit 1
fi

if [ "$(port -q version | cut -d: -f2 | cut -d. -f1)" -eq 2 -a "$(port -q version | cut -d: -f2 | cut -d. -f2)" -lt 2 ]; then
  if [ ! -z "$(port -q installed libtool)" ];then
    echo "Finding which linkages might be due to libtool over-linking..."
    LIBTOOL_ARCHIVES=$(port -q contents $1 | xargs file | grep "libtool library file" | cut -d\: -f1 | cut -d\  -f1 | uniq)
    if [ ! -z "$LIBTOOL_ARCHIVES" ]; then
      DEPENDENCY_LIBS=$(cat "${LIBTOOL_ARCHIVES}" | grep "dependency_libs" | tr \  \\n | grep "$MP_PREFIX" | grep \.la)
      # TODO:
      # -[ ] Handle the dangling single-quotes in a way that does not
      #      confuse the syntax highlighting in my text editor...
      if [ ! -z "$DEPENDENCY_LIBS" ]; then
        echo "${DEPENDENCY_LIBS}"
        echo "Checking which ports provide dependency_libs entries in these libtool archives..."
        DEPENDENCY_PROVIDERS=$(echo "${DEPENDENCY_LIBS}" | xargs port -q provides | cut -d\: -f2 | uniq | sort | uniq | tr -d '[:blank:]' | sed "s|${1}||" | tr -d '[:blank:]' | uniq | tee -a /dev/tty)
        echo "${DEPENDENCY_PROVIDERS}" >> "${TMPFILE3}"
      else
        echo "libtool archives have already been cleared of dependency_libs; libtool over-linking likely is not a problem..."
        delete_tmpfile3
      fi
    else
      echo "Actually, no libtool archives were found, so never mind."
      delete_tmpfile3
    fi
  else
    echo "You do not have the libtool port installed; no need to check for libtool over-linking."
    delete_tmpfile3
  fi
else
  echo "Checking libtool archives for overlinking should not be necessary for your MacPorts version ($(port -q version)), unless you have NOT rebuilt everything since you updated..."
  echo "This script does NOT know whether or not you have rebuilt as such though, so we shall assume the best of you and skip the libtool-archives check."
  echo "(the libtool-archives check was just a back-up check in case the check with \`nm(1)\` failed, anyways, so skipping it should be harmless)"
  delete_tmpfile3
fi

echo "Finding the libraries that $(port file ${1}) lists as dependencies..."
ACTIVE_VARIANTS=$(port -q installed "${1}" | grep \(active\) | cut -d\  -f4)
echo "${1} is installed with the following active variants: ${ACTIVE_VARIANTS}"
echo "So we shall find the dependencies for those variants..."
# I would like there to be a `lib_depof:` type of pseudo-portname to use here: 
# https://trac.macports.org/ticket/38381
port info --line --depends_lib "${1}" "${ACTIVE_VARIANTS}" | tr ',' '\n' | tee -a /dev/tty | awk -F ':' '{ print $NF; }' | sort | uniq >> "${TMPFILE2}"

echo "Comparing the list of library linkages with the list of library dependencies..."
DIFF_CONTENTS=$(diff -iwBu --strip-trailing-cr "${TMPFILE2}" "${TMPFILE1}")
if [ -z "${DIFF_CONTENTS}" ]; then
  echo "No difference in dependencies, exiting."
  delete_tmpfiles
  exit 1
else
  DIFF_FILE=${TMPDIR}/${1}-deps.${SUFFIX}.diff
  echo "$DIFF_CONTENTS" | tee "${DIFF_FILE}"
  echo "Output a diff file to ${DIFF_FILE}"
fi
#!/bin/bash
# A script to check the dependencies of a port against which libraries the port actually 
# links against.
# `otool` is an OS X thing (from cctools), so do NOT go expecting to run this on 
# other platforms

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 1
fi
if [ -z "$1" ]; then
  echo "Usage: $(basename $0) portname"
  exit 1
fi
if [ -z "$(port list $1)" ]; then
  echo "Error: port $1 not found"
  exit 1
fi
if [ "$(port installed $1)" = "None of the specified ports are installed." ]; then
  echo "$(port installed $1)"
  exit 1
fi

tempfoo=$(basename $0)
# I added the suffix stuff before I knew that `mktemp` already added one for you;
# I left them in anyway though because why not
# TODO:
# -[ ] Handle other special timezones besides EDT
# -[ ] Actually, just handle the output of `date` better in general
if [ "$(date | cut -d\  -f5)" != "EDT" ]; then
  SUFFIX_PT1=$(date | cut -d\  -f5 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f7)
else
  SUFFIX_PT1=$(date | cut -d\  -f4 | tr -d :)
  SUFFIX_PT2=$(date | cut -d\  -f6)
fi

SUFFIX=${SUFFIX_PT1}${SUFFIX_PT2}

# The first few times I tried this script I had some trouble with my $TMPDIR;
# that is why I am making sure it exists and is set here.
if [ -z "$TMPDIR" ]; then
  export TMPDIR=/tmp
fi
# This might be a paradox, but I cannot think of a better way to make sure that
# this call to mkdir will actually succeed...
if [ ! -d $TMPDIR -a -w ${TMPDIR}/.. ]; then
  mkdir -p $TMPDIR
fi

# TODO: 
# -[ ] Make a function (or use a loop) to do this so I do not have to
#      copy-n-paste as much
TMPFILE0=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}0.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create zeroth temp file, exiting..."
  exit 1
fi
TMPFILE1=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}1.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create first temp file, exiting..."
  exit 1
fi
TMPFILE2=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}2.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create second temp file, exiting..."
  exit 1
fi
TMPFILE3=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}3.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create third temp file, exiting..."
  exit 1
fi
TMPFILE4=$(mktemp -q ${TMPDIR}/${tempfoo}.${SUFFIX}4.XXXXXX)
if [ $? -ne 0 ]; then
  echo "$0: Cannot create fourth temp file, exiting..."
  exit 1
fi

delete_tmpfiles() {
    for TMPFILE_TO_DELETE in "${TMPFILE0}" "${TMPFILE1}" "${TMPFILE2}" "${TMPFILE3}" "${TMPFILE4}"; do
      if [ -w "${TMPDIR}" -a -w "${TMPFILE_TO_DELETE}" ]; then
          rm -f "${TMPFILE_TO_DELETE}"
      fi
    done
}

# This one gets a special case because there are more reasons to delete it:
delete_tmpfile3() {
    if [ -w "${TMPDIR}" -a -w "${TMPFILE3}" ]; then
        rm -f "${TMPFILE3}"
    fi
}

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/opt/local
fi

# TODO:
# -[ ] Figure out if it is safe to remove the dependencies that are probably due
#      to libtool overlinking
# -[ ] Actually do the removing

echo "Finding MacPorts libraries that ${1} links against..."
# I should find a way to not have to pipe so much stuff through `cut` here...
# http://trac.macports.org/ticket/38428
MACH_O_FILES=$(port -q contents $1 | xargs /usr/bin/file | grep Mach-O | cut -d\: -f1 | cut -d\  -f1 | uniq)
if [ ! -z "${MACH_O_FILES}" ]; then
  LINKED_AGAINST_LIBS=$(echo "${MACH_O_FILES}" | xargs otool -L | grep "\ version\ " | grep "${MP_PREFIX}" | sort | uniq | cut -d\  -f1) 
  echo "${LINKED_AGAINST_LIBS}" >> "${TMPFILE0}"
  SYMBOLS=$(for macho in ${MACH_O_FILES}; do if [ ! -z "${macho}" ]; then nm -m "${macho}" 2>/dev/null && echo ""; fi && echo ""; done && echo "")
  echo "${SYMBOLS}" >> "${TMPFILE4}"
  echo "" >> "${TMPFILE4}"
  if [ ! -z "$LINKED_AGAINST_LIBS" ]; then
    # This is the part where we actually get the ports linked against:
    echo $(cat "${TMPFILE0}" | xargs port -q provides 2>/dev/null | grep "is provided by" | tee -a /dev/tty | cut -d\: -f2 | sort | uniq) | sed "s|${1} ||" | tr \  \\n >> "${TMPFILE1}"
    if [ ! -z "${SYMBOLS}" -a -e "${TMPFILE4}" ]; then
      if [ -z "${PORT_DEPCHECK_SKIP_NM_SYMBOL_CHECK}" ]; then
        echo "Checking symbols in linked-against libraries..."
        for MP_LIBRARY in $(echo "${LINKED_AGAINST_LIBS}" | uniq | xargs basename | uniq | cut -d. -f1 | uniq | cut -d\- -f1 | uniq); do
          printf "Checking to see if %s actually uses symbols from %s... " "${1}" "${MP_LIBRARY}"
          if [ ! -z "$(grep ${MP_LIBRARY} ${TMPFILE4})" ]; then
            echo "yes"
          else
            PORT_TO_REMOVE="$(cat ${TMPFILE0} | uniq | sort | uniq | xargs port -q provides 2>/dev/null | uniq | sort | uniq | grep ${MP_LIBRARY} | uniq | sort | uniq | cut -d\: -f2 | uniq | sort | uniq | tr -d [:blank:])"
            if [ -z "${PORT_DEPCHECK_KEEP_PORTS_THAT_FAIL_SYMBOL_CHECK}" ]; then
              echo "no (TODO: use sed properly to remove \"${PORT_TO_REMOVE}\" from list of dependencies)"
            else
              echo "no (an environment variable is set; remove \"${PORT_TO_REMOVE}\" from the list of dependencies manually)"
            fi
          fi
        done
      else
        echo "The environment variable to skip the symbol check is set."
      fi
    else
      echo "Warning: libraries have no symbols... (how did that happen?)"
    fi
  else
    echo "${1} does not actually link against any MacPorts libraries, exiting..."
    delete_tmpfiles
    exit 1
  fi
else
  echo "${1} does not actually contain any mach-o binaries, exiting..."
  delete_tmpfiles
  exit 1
fi

if [ "$(port -q version | cut -d: -f2 | cut -d. -f1)" -eq 2 -a "$(port -q version | cut -d: -f2 | cut -d. -f2)" -lt 2 ]; then
  if [ ! -z "$(port -q installed libtool)" ];then
    echo "Finding which linkages might be due to libtool over-linking..."
    LIBTOOL_ARCHIVES=$(port -q contents $1 | xargs file | grep "libtool library file" | cut -d\: -f1 | cut -d\  -f1 | uniq)
    if [ ! -z "$LIBTOOL_ARCHIVES" ]; then
      DEPENDENCY_LIBS=$(cat "${LIBTOOL_ARCHIVES}" | grep "dependency_libs" | tr \  \\n | grep "$MP_PREFIX" | grep \.la)
      # TODO:
      # -[ ] Handle the dangling single-quotes in a way that does not
      #      confuse the syntax highlighting in my text editor...
      if [ ! -z "$DEPENDENCY_LIBS" ]; then
        echo "${DEPENDENCY_LIBS}"
        echo "Checking which ports provide dependency_libs entries in these libtool archives..."
        DEPENDENCY_PROVIDERS=$(echo "${DEPENDENCY_LIBS}" | xargs port -q provides | cut -d\: -f2 | uniq | sort | uniq | tr -d '[:blank:]' | sed "s|${1}||" | tr -d '[:blank:]' | uniq | tee -a /dev/tty)
        echo "${DEPENDENCY_PROVIDERS}" >> "${TMPFILE3}"
      else
        echo "libtool archives have already been cleared of dependency_libs; libtool over-linking likely is not a problem..."
        delete_tmpfile3
      fi
    else
      echo "Actually, no libtool archives were found, so never mind."
      delete_tmpfile3
    fi
  else
    echo "You do not have the libtool port installed; no need to check for libtool over-linking."
    delete_tmpfile3
  fi
else
  echo "Checking libtool archives for overlinking should not be necessary for your MacPorts version ($(port -q version)), unless you have NOT rebuilt everything since you updated..."
  echo "This script does NOT know whether or not you have rebuilt as such though, so we shall assume the best of you and skip the libtool-archives check."
  echo "(the libtool-archives check was just a back-up check in case the check with \`nm(1)\` failed, anyways, so skipping it should be harmless)"
  delete_tmpfile3
fi

echo "Finding the libraries that $(port file ${1}) lists as dependencies..."
ACTIVE_VARIANTS=$(port -q installed "${1}" | grep \(active\) | cut -d\  -f4)
echo "${1} is installed with the following active variants: ${ACTIVE_VARIANTS}"
echo "So we shall find the dependencies for those variants..."
# I would like there to be a `lib_depof:` type of pseudo-portname to use here: 
# https://trac.macports.org/ticket/38381
port info --line --depends_lib "${1}" "${ACTIVE_VARIANTS}" | tr ',' '\n' | tee -a /dev/tty | awk -F ':' '{ print $NF; }' | sort | uniq >> "${TMPFILE2}"

echo "Comparing the list of library linkages with the list of library dependencies..."
DIFF_CONTENTS=$(diff -iwBu --strip-trailing-cr "${TMPFILE2}" "${TMPFILE1}")
if [ -z "${DIFF_CONTENTS}" ]; then
  echo "No difference in dependencies, exiting."
  delete_tmpfiles
  exit 1
else
  DIFF_FILE=${TMPDIR}/${1}-deps.${SUFFIX}.diff
  echo "$DIFF_CONTENTS" | tee "${DIFF_FILE}"
  echo "Output a diff file to ${DIFF_FILE}"
fi

}

port_fetch_all (){

  #!/bin/bash
# Fetches all the dependencies of a port
# This was the original script that made up phw's original macportsscripts port.

if [ $# -ne 1 ]
then
  echo "Usage: $(basename ${0}) PORTNAME"
  echo "(fetches all dependencies for a port)"
  exit 1
fi

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

# The ${MP_PREFIX} variable is NOT actually currently used here yet, but it is there
# in case I decide to use it in this script in the future.
if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/opt/local
fi

for i in $(port -q rdeps ${1} | tr -d [:blank:] | tr \\n \ )
do
  port -v checksum "${i}"
# The call to "sleep" is to prevent this script from becoming a forkbomb
  sleep 1
done

}

port_patch () {
#!/bin/bash
# This script was taken from https://trac.macports.org/wiki/howto/AdvancedDailyAdm

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 0
fi

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi


#!${MP_PREFIX}/bin/bash

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/macports
# "/macports" was what was originally used in this script
fi

declare prefix=${1:-"$MP_PREFIX"}

#!${prefix}/bin/bash

declare rsyncMacportsOrg="/var/macports/sources/rsync.macports.org/release/ports"

(   cd $( dirname ${0} )

declare outputFile
declare patchFile

for port in $(find portfiles -name 'Portfile')
do
    outputFile=${port%/*}/patch-${port##*/}
    rm ${outputFile} 2>/dev/null
    diff -u \
        ${prefix}${rsyncMacportsOrg}/${port#*/} \
        ${port} \
    > ${outputFile}
    echo "created patch for ${port}"
    mv ${port} ${port}.OK
done

) ; wait


}

port_tap() {
  #!/bin/sh

if [ -z "$1" ]; then 
  echo usage: $0 url
  exit
fi

URL = $1
echo $URL #statement for debugging
prefix="$(type -p port)"; prefix="${prefix%/bin/port}"
portdir = "${url##*/}" #The end part of the url, used as a folder to put the sources in
FILE_PATH = {$prefix}/var/macports/sources/{$portdir}

#The comments here are just placeholders until I figure out how to parse URLs in shell scripts
if #the URL is a git url (git://)
  git clone $URL $FILE_PATH
elif #the URL is an hg url
  hg clone $URL $FILE_PATH
elif #the URL is an svn url
  svn co $URL $FILE_PATH
else #curl should be able to handle pretty much anything else
  curl $URL $FILE_PATH
fi

#edit {$PREFIX}/etc/macports/sources.conf to include file://$FILE_PATH (not sure how to do this -- I'm guessing sed?)

}

port_unprovided() {
  #!/bin/bash
# Lists unprovided files in your MacPorts prefix
#TODO: Add better support for different prefixes

if [ -z "(which port)" ]; then
    echo "MacPorts not found, this script is primarily for use with MacPorts."
    exit 0
fi

#TODO: Add support for multiple flags (learn how to do `case` syntax)
if [ "$1" == "--help" ]; then
  echo "Usage:"
  echo ""
  echo "--help          use this flag to display this help."
  echo "-v          use this flag to be verbose (does NOT actually work yet)."
  echo "-r          use this flag to recurse deep into your prefix."
  echo "--prefix=/placeholder/path/to/prefix  use this flag to select which prefix to use (defaults to /opt/local) (not actually implemented yet)."
  echo ""
  echo "Warning: only the first flag specified is actually recognized so far"
  echo ""
  exit 0
fi

# This tempfile creation part is mainly taken from port-depcheck.sh
#TODO: put this part in a common thing that can be `source`-ed
tempfoo=$(basename $0)

# The first few times I tried this script I had some trouble with my $TMPDIR;
# that is why I am making sure it exists and is set here.
if [ -z "$TMPDIR" ]; then
    export TMPDIR=/tmp
fi
if [ ! -d "${TMPDIR}" ]; then
    mkdir -p "${TMPDIR}"
fi

# The "XXXX"es that `mktemp` replaces only work if they are at the very end
# i.e. they do NOT get replaced when there is a file extension at the end like
# I have here
if [ "$(date | cut -d\  -f5)" != "EDT" ]; then
    SUFFIX_PT1=$(date | cut -d\  -f5 | tr -d :)
    SUFFIX_PT2=$(date | cut -d\  -f7)
else
    SUFFIX_PT1=$(date | cut -d\  -f4 | tr -d :)
    SUFFIX_PT2=$(date | cut -d\  -f6)
fi

SUFFIX=${SUFFIX_PT1}${SUFFIX_PT2}

TMPFILE1=$(mktemp -q $TMPDIR/${tempfoo}.${SUFFIX}.log)
if [ $? -ne 0 ]; then
    echo "${0}: Cannot create temp file, exiting..."
    exit 1
fi

if [ -L "$(which port)" ]; then
  REAL_PORT=$(readlink "$(which port)")
  echo "Warning: $(which port) is a symlink to ${REAL_PORT}."
  export MP_PREFIX=$(dirname $(dirname ${REAL_PORT}))
  echo "Assuming MP_PREFIX is actually ${MP_PREFIX}."
else
  export MP_PREFIX=$(dirname $(dirname "$(which port)"))
fi

if [ -z "$MP_PREFIX" ]; then
  export MP_PREFIX=/opt/local
fi

#TODO:
# - Set list of unprovided files to a machine-readable variable
# - read symlinks among files (delete broken ones?)
# - grep for .mp_#### files; these are ones that MacPorts has moved aside
# - when .mp_#### files are unprovided, that usually means they are safe to delete
#   (so do so?)

if [ -d $MP_PREFIX ]; then
  if [ "$1" == "-r" ]; then
    echo "Generating list files in prefix, this might take a while..."
        echo "(Also make sure you have a large scrollback buffer)"
    for directory in $(find $MP_PREFIX/* \( -path $MP_PREFIX/var/macports -prune \) -o -print 2>/dev/null); do
      if [ -d ${directory} ]; then
        if [ -z "$(port provides ${directory}/* | grep "is not provided by a MacPorts port.")" ]; then
          echo "${directory}: no unprovided files found here"
        else
          port provides ${directory}/* | grep "is not provided by a MacPorts port." | tee -a "${TMPFILE1}"
        fi
      fi
    done
  else
    for directory in ${MP_PREFIX}/*; do
      if [ -z "$(port provides ${directory}/* | grep "is not provided by a MacPorts port.")" ]; then
        echo "${directory}: no unprovided files found here"
      else
        port provides ${directory}/* | grep "is not provided by a MacPorts port." | tee -a "${TMPFILE1}"
      fi
    done
  fi
fi
if [ ! -z "$(cat ${TMPFILE1})" ]; then
    echo "List of unprovided files output to $TMPFILE1"
elif [ -w "${TMPDIR}" -a -w "${TMPFILE1}" ]; then
    rm -f "${TMPFILE1}"
fi

}

port_testport(){
  #!/bin/bash

# testport  --  test install a specified port in /opt/macports-test (default)
# Taken from:
# https://trac.macports.org/wiki/Scripts/testport_script

# 1. move the /opt/local MacPorts system to ${opt_local_off} to make sure
#    it is not interfering with the custom ${MP_PREFIX} MacPorts build process
# 2. move /usr/local to ${usr_local_off} to make sure it is not interfering
#    with the custom ${MP_PREFIX} MacPorts build process
# 3. install a fresh MacPorts 2.0.4 system to "${MP_PREFIX}"
# 4. install the specified port to the custom ${MP_PREFIX} MacPorts system

# Small getopts tutorial, 
# http://wiki.bash-hackers.org/howto/getopts_tutorial

# usage:
# testport gawk
# testport -n -l /opt/macports-gnu gawk
# testport -r clang-3.1
# testport -c -e -v clang-3.1
# testport -s clang-3.1
# testport -r openal
# testport -c openal configure.cc='/opt/macports-test/bin/clang-mp-3.1' configure.cxx='/opt/macports-test/bin/clang++-mp-3.1'
# testport -c -u -l /opt/macports-test-universal


show_usage() {
   echo
   echo "$(basename ${0})  --  test install a specified port in /opt/macports-test (default)"
   echo
   echo "Usage: $(basename ${0}) [-c] [-d] [-e] [-h] [-n] [-p] [-r] [-s] [-u] [-v] [-l dir] portname"
   echo '
-c: clean all installed ports
-d: enable debug mode
-e: fetch & extract the distribution files for portname
-h: help
-n: delete /opt/macports-test (default) & perform a new MacPorts install from scratch
-p: print PATH variable value
-r: remove / uninstall specified port and exit
-s: build and install from source only
-u: update MacPorts system, upgrade outdated ports and exit (cleans work directories)
-v: enable verbose mode
-l dir: specify dir as location of MacPorts system (otherwise defaults to /opt/macports-test)
'
   return 0
}


trapcount=0
# cf. http://fvue.nl/wiki/Bash:_Error_handling
on_exit() {
   #set -xv
   trapcount=$((trapcount + 1))
   if [[ $trapcount -eq 1 ]]; then
      cd    # avoid: sudo: cannot get working directory
      #find -x "${tmpDir}" -ls 1>&2
      echo
      [[ -d "${tmpDir}" ]] && rm -rf "${tmpDir}"
      [[ -d "${usr_local_off}" ]] && sudo mv -iv "${usr_local_off}" /usr/local
      [[ -d "${opt_local_off}" ]] && sudo mv -iv "${opt_local_off}" /opt/local
      printf "\n\n\n"
      echo dscl . -change /Users/macports NFSHomeDirectory "${MP_PREFIX}/var/macports/home" "${dsclHome}"
      current_dscl_home="$(dscl . -read /Users/macports NFSHomeDirectory | sed 's/^NFSHomeDirectory: *//')"
      if [[ "${current_dscl_home}" != "${dsclHome}" ]]; then
         dscl . -change /Users/macports NFSHomeDirectory "${MP_PREFIX}/var/macports/home" "${dsclHome}"
      fi
      printf '\n\n%s\n\n\n' "export PATH=\"${MP_PREFIX}/bin:${MP_PREFIX}/sbin:/usr/bin:/bin:/usr/sbin:/sbin\""
  fi
   exit
}


do_clean_all() {
   [[ $(port installed | wc -l) -gt 1 ]] && port -f clean --all installed
   [[ $(port list inactive | wc -l) -gt 0 ]] && port -f uninstall inactive
   find -x "${MP_PREFIX}/var/macports/build" -maxdepth 3 -type d -name work -print0 | while IFS="" read -r -d "" dirpath; do
      portname="$( basename "$(dirname "${dirpath}")" )"
      echo port -f -v clean --all "${portname}"
      port -f -v clean --all "${portname}"
   done
   return 0
}

do_clean_work() {
  [[ $(port installed | wc -l) -gt 1 ]] && port -f clean --work installed
   find -x "${MP_PREFIX}/var/macports/build" -maxdepth 3 -type d -name work -print0 | while IFS="" read -r -d "" dirpath; do
      portname="$( basename "$(dirname "${dirpath}")" )"
      echo port -f -v clean --work "${portname}"
      port -f -v clean --work "${portname}"
   done
   return 0
}


do_update() {
   [[ $clean_all -eq 0 ]] && do_clean_work
   port selfupdate
   port outdated
   [[ $(port outdated | wc -l) -gt 1 ]] && port upgrade -R -u outdated
   return 0
}



unset CDPATH PATH IFS LC_ALL MP_PREFIX all_new 
IFS=$' \t\n'
LC_ALL=C
PATH='/sbin:/usr/bin:/bin:/usr/sbin:/sbin'
export IFS LC_ALL PATH


MP_PREFIX=""
all_new=0
update=0
remove=0
verbose=0
debug=0
printpath=0
extract=0
build_source=0
clean_all=0


while getopts ":cdehl:nprsuv" opt; do
  case "$opt" in
    c) 
      clean_all=1
      ;;
    d) 
      debug=1
      ;;
    e) 
      extract=1
      ;;
    h) 
      show_usage
      exit
      ;;
    l) 
      MP_PREFIX="$OPTARG"
      ;;
    n)
      all_new=1
      ;;
    p)
      printpath=1
      ;;
    r)
      remove=1
      ;;
    s) 
      build_source=1
      ;;
    u)
      update=1
      ;;
    v)
      verbose=1
      ;;
    \?)
      echo "Invalid option: -$OPTARG" 1>&2
      show_usage 1>&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." 1>&2
      show_usage 1>&2
      exit 1
      ;;
  esac
done


shift $((OPTIND-1))

if [[ -z "$MP_PREFIX" ]]; then
   MP_PREFIX='/opt/macports-test'
fi

if [[ "$MP_PREFIX" == '/opt/local' ]]; then
   echo 'Use of /opt/local is not allowed!' 1>&2
   exit 1
fi

if [[ "$MP_PREFIX" == '/' ]]; then
   echo 'Use of / is not allowed!' 1>&2
   exit 1
fi

if [[ $(dirname "${MP_PREFIX}") != '/opt' ]]; then
   echo 'Use: /opt/somedir' 1>&2
   exit 1
fi

if [[ ! -d "$MP_PREFIX" ]]; then
   all_new=1
fi

if [[ $all_new -eq 1 ]]; then
   clean_all=0
   remove=0
   update=0
fi


declare -rx MP_PREFIX

unset PATH
PATH="${MP_PREFIX}/bin:${MP_PREFIX}/sbin:/usr/bin:/bin:/usr/sbin:/sbin"
export PATH


if [[ $(id -u) -ne 0 ]] || [[ "${HOME}" != '/var/root' ]]; then
   echo 'This script must be run in a root shell to prevent sudo timeout!' 1>&2
   echo 'Use: sudo -H -i' 1>&2
   exit 1
fi


if [[ $printpath -eq 1 ]]; then
   printf '\n\n%s\n\n\n' "export PATH=\"${MP_PREFIX}/bin:${MP_PREFIX}/sbin:/usr/bin:/bin:/usr/sbin:/sbin\""
   printf '%s\n\n\n' "alias testport='/usr/local/bin/testport'"
   exit
fi

if [[ $all_new -ne 1 ]] && [[ ! -x "${MP_PREFIX}/bin/port" ]]; then
   echo "No port command found at: ${MP_PREFIX}/bin/port" 1>&2
   exit 1
fi


# make sure the current working directory exists
pwd -P 1>/dev/null || exit 1

# prevent idle sleep
pmset -a force sleep 0 displaysleep 0 disksleep 0


sleep 1
unset usr_local_off opt_local_off tmpDir
usr_local_off="/usr/local-off-$(date '+%Y-%m-%d-%H_%M_%S')"
opt_local_off="/opt/local-off-$(date '+%Y-%m-%d-%H_%M_%S')"

tmpDir="$(mktemp -d /tmp/macports.XXXXXX)" || exit 1

declare -rx usr_local_off opt_local_off tmpDir

trap on_exit EXIT TERM HUP INT QUIT

dsclHome="$(dscl . -read /Users/macports NFSHomeDirectory | sed 's/^NFSHomeDirectory: *//')"
dscl . -change /Users/macports NFSHomeDirectory "${dsclHome}" "${MP_PREFIX}/var/macports/home"

echo

# make sure /usr/local is not interfering with MacPorts build processes for ${MP_PREFIX}
[[ -d '/usr/local' ]] && sudo mv -iv /usr/local "${usr_local_off}"

# make sure /opt/local is not interfering with MacPorts build processes for ${MP_PREFIX}
[[ -d '/opt/local' ]] && sudo mv -iv /opt/local "${opt_local_off}"

echo


if [[ $# -eq 0 ]]; then
   if [[ $clean_all -eq 1 ]] && [[ $update -eq 1 ]]; then
      do_clean_all
      do_update
      exit
   elif [[ $clean_all -eq 1 ]]; then
      do_clean_all
      exit
   elif [[ $update -eq 1 ]]; then
      do_update
      exit
   else
      echo
      echo 'No port to install (or remove) given!'
      show_usage 1>&2
      exit 1
   fi
fi


if [[ $all_new -eq 1 ]]; then

   if [[ -x "${MP_PREFIX}/bin/port" ]]; then
      [[ $(port installed | wc -l) -gt 1 ]] && port -f uninstall installed
   fi

   # since "rm -rf" is a dangerous command, we restrict its use to /opt/somedir
   if [[ -d "${MP_PREFIX}" ]] && [[ $(dirname "${MP_PREFIX}") == '/opt' ]]; then
      rm -rf "${MP_PREFIX}"
   fi

   # get a fresh MacPorts 2.0.4 install in ${MP_PREFIX} 

   cd "${tmpDir}" || exit 1

   # cf. http://guide.macports.org/#installing.macports.source.multiple
   unset PATH
   export PATH='/bin:/sbin:/usr/bin:/usr/sbin'
   curl -L -O https://distfiles.macports.org/MacPorts/MacPorts-2.0.4.tar.bz2 || exit 1
   tar -xjf MacPorts-2.0.4.tar.bz2
   cd MacPorts-2.0.4 || exit 1
   # --enable-werror --with-install-user=$owner --with-install-group=$group --with-directory-mode=$perms"
   ./configure --prefix="${MP_PREFIX}" --with-tclpackage="${MP_PREFIX}/tcl" --with-applications-dir="${MP_PREFIX}/Applications"

   make
   make install

   # get the Portfiles and update the system
   "${MP_PREFIX}/bin/port" selfupdate

fi  # all_new


cd "${tmpDir}" || exit 1

unset PATH
PATH="${MP_PREFIX}/bin:${MP_PREFIX}/sbin:/usr/bin:/bin:/usr/sbin:/sbin"
export PATH

echo

# clean up previous "${MP_PREFIX}" directory
if [[ $all_new -eq 0 ]] && [[ $remove -eq 0 ]] && [[ $build_source -eq 0 ]] && [[ -x "${MP_PREFIX}/bin/port" ]]; then
   if [[ $clean_all -eq 1 ]]; then
      do_clean_all
   elif [[ -d "$(port dir "$@")/work" ]]; then
      #port -f -v clean --all "$@"
      port -f -v clean --work "$@"
   fi
fi


if [[ $update -eq 1 ]]; then
   do_update
   exit
fi


if [[ $remove -eq 1 ]]; then
   if [[ $(port installed "$@" | wc -l) -gt 1 ]]; then
      printf '\n\n%s\n\n\n' "Uninstalling: $@"
      port -f clean --all "$@"
      port -f -v uninstall "$@"
   elif [[ -d "$(port dir "$@")/work" ]]; then
      printf '\n\n%s\n\n\n' "Removing: $(port dir "$@")/work"
      port -f -v clean --all "$@"
   else
      printf '\n\n%s\n\n\n' "Force uninstalling: $@"
      port -f -v clean --all "$@" || true
      port -f -v uninstall "$@" || true
   fi
   exit
fi


if [[ $extract -eq 1 ]] && [[ $verbose -eq 1 ]]; then
   port -f clean --all "$@"
   port -f -v extract "$@"
elif [[ $extract -eq 1 ]] && [[ $debug -eq 1 ]]; then
   port -f clean --all "$@"
   port -f -d extract "$@"
elif [[ $extract -eq 1 ]]; then
   port -f clean --all "$@"
   port -f extract "$@"
elif [[ $build_source -eq 1 ]] && [[ $verbose -eq 1 ]]; then
   port -f -s -v install "$@"
elif [[ $build_source -eq 1 ]] && [[ $debug -eq 1 ]]; then
   port -f -s -d install "$@"
elif [[ $build_source -eq 1 ]]; then
   port -f -s install "$@"
elif [[ $verbose -eq 1 ]]; then
   port -f -v install "$@"
elif [[ $debug -eq 1 ]]; then
   port -f -d install "$@"
else
   port -f install "$@"
fi


exit 0

}

port_recursive_port_binary_distributable.tcl (){
  #!/bin/sh

# usage: supply a port name as an argument

if [ -z "$(which port)" ]; then
  echo "MacPorts not found, this script is primarily for use with MacPorts."
  exit 1
fi
if [ -z "$1" ]; then
  echo "Usage: $(basename $0) portname"
  exit 1
fi
if [ -z "$(port list $1)" ]; then
  echo "Error: port $1 not found"
  exit 1
fi

echo "checking to see if any of the rdeps of $1 will have to be built from source..."

for depport in `port -q rdeps $1`; do
  echo "checking distributability of ${depport}... \c"
  #TODO: stop hardcoding this path:
  tclsh /opt/local/var/macports/sources/rsync.macports.org/release/tarballs/base/portmgr/jobs/port_binary_distributable.tcl -v ${depport}
done
}
