# Funktion sys_conf, verschiedenen Funktionen,# {{{
# um das OS zu administrieren.
#
# usage: sys_conf ausfuehren und dann eine der folgenden Funktionen
# Beispiele:
# VAR=$(check_memory)
# no_memory_msg
# 
# am besten den Header der Funktion oder die Dokumentation dazu lesen.
#
# globale Variablen sind z.B.:
# gv_LineAnz
#
#######################################
# TODO:
# gerade bei Passwoertern
#  >&3- bla?
#######################################
#
sys_conf() {
	### alle Dialogboxen ### {{{
	# Funktion (calendarbox), zum einstellen des Datums (calendarbox){{{
	#
	# usage: calendarbox (DATE)
	#		 DATE - Datum, Format yyyymmdd oder yyyy-mm-dd (optional).
	#
	calendarbox() {
		local Anz Date
		unset -- Anz
		TITLE=$(gettext 'Kalender')
		MSG=$(gettext 'Stellen Sie bitte Ihr Datum ein und bestaetigen Sie dies.')
		if [ "$#" -le 1 ] ; then
			if [ "${(c)#1}" -eq 8 ] ; then
				Date="`date -d $1 +%d.%m.%Y`"
			fi
        fi

		# Berechnung der Fenstergroesse (Zeilen).
		count_display_line -l 4 "$MSG"
		
		DialogTitle="--title \"${gv_ScriptName}::${TITLE}\" $DialogBackTitle"
		DialogPara="--clear --calendar \"$MSG\" $DisplayLines 0 `print ${(s:.:)${Date}}`"
		eval $Dialog $DialogTitle $DialogPara $DialogReDirect
		
		return_check
	}
	#}}}
	# Funktion (checklist), mehrfach Auswahl{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: checklist "DEFAULT-ITEM" "$TITLE" "$MSG" "$ARRAY" [ VAR ]
	#        DEFAULT-ITEM - Item auf welches bei der Anzeige gesprungen werden soll.
	#        TITLE - Der TITLE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        MSG - Die MESSAGE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen,
	#              oder aus der Funktion script_init.
	#        ARRAY - Array mit Werten die man auswaehlen kann.
	#        VAR - Variable die den vorherigen Wert enthaelt.
	#              wird benoetigt, falls man schon Werte hat
	#              und diese erhalten will, z.B. beim Abbrechen.
	#			   Ist optional
	#
	checklist() {
		unset -- V_WERT
		if [[ ${#argv} -ge 4 ]] ; then
			# vorherige Werte speichern.
			if [[ ${#argv} == 5 ]] ; then
				V_WERT="$5"
			fi
			# Fenstergroesse (Zeilen) berechnen.
			count_display_line -m 7 "$4"
			# Fenstergroesse (Spalten) berechnen.
            count_display_col "$4"
			# Laenge des Titel berechnen
			count_title_string "$2" "$DisplayColumns"

			DialogLabel="--help-button --default-item \"$1\""
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --separate-output --checklist \"$3\" $DisplayLines $DisplayColumns $Elemente $4"

			eval $Dialog $DialogLabel $DialogTitle $DialogPara $DialogReDirect
			
			return_check
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (dselect), Verzeichnis auswaehlen{{{
	#
	# usage: dselect [ "$VERZ" | nichts ]
	# Bei nichts wird das HOME verzeichnis genommen.
	#
	dselect() {
		unset -- Tmp_Dir
		Tmp_Dir="${1/\~/$HOME}"
		if [ -d "$Tmp_Dir" ] ; then
			W_DIR="${(qq)Tmp_Dir}"
		else
			W_DIR="${(qq)HOME}"
		fi
		#
		TITLE=$(gettext 'Waehlen Sie bitte das Verzeichnis aus.')
		DialogTitle="--title \"$TITLE\" $DialogBackTitle"
		DialogPara="--clear --dselect "$W_DIR" $[$LINES-16] 48"
		eval $Dialog $DialogTitle $DialogPara $DialogReDirect
		if [ "$?" = 0 ] ; then
			V="`< ${DialogReDirect##*>}`"
			if [ "$V" != / ] ; then
				VERZ="${V%/}"
			else
				VERZ="$V"
			fi
		else
			unset -- VERZ
		fi	
	}
	#}}}
	# Funktion (editbox), eine Eingabebox anzeigen{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: editbox "$TITLE" "$FILE"
	#        TITLE - Der TITLE wird aus 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        FILE -  /Path/to/file
	#
	editbox() {
		unset -- Old_File
		local Old_File
		if [ "$#" -eq 2 ] ; then
            Old_File="$2"
            create_file -d "${Old_File%/*}"
            create_file "$Old_File"
			(( DisplayLines = LINES-7 ))
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --cr-wrap --no-collapse --editbox "$Old_File" $DisplayLines $DisplayColumns"
			eval $Dialog $DialogTitle $DialogPara $DialogReDirect
		
			if [ "$?" = 0 ] ; then
				if ! diff -c ${DialogReDirect#*>} $Old_File >/dev/null ; then
					prog_exec mv "${DialogReDirect#*>} $Old_File" &>/dev/null
				fi
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (fselect), Verzeichnis/Datei auswaehlen{{{
	#
	# usage: fselect [ "/Pfad/Datei" | nichts ]
	# Bei nichts wird das HOME verzeichnis genommen.
	#
	# Wird dieser Funktion eine /Pfad/Datei uebergeben
	# wird dieser Wert in der Variable V_WERT gespeichert.
	# Diese Variable wird von der Funktion return_check
	# ausgewertet (vorheriger Wert).
	#
	fselect() {
		unset -- Tmp_File
		# vorherigen Wert speichern.
		if [ -n "$1" ] ; then
			V_WERT="$1"
		fi
		Tmp_File="${1/\~/$HOME}"
		if [ -f "$Tmp_File" -o -d "${Tmp_File}" ] ; then
			F_DIR="${(qq)Tmp_File}"
		else
			F_DIR="${(qq)HOME}"
		fi
		#
		TITLE=$(gettext 'Waehlen Sie bitte das Verzeichnis und dann die Datei aus.')
		DialogTitle="--title \"$TITLE\" $DialogBackTitle"
		DialogPara="--clear --fselect "$F_DIR" $[$LINES-16] $[$COLUMNS-10]"
		eval $Dialog $DialogTitle $DialogPara $DialogReDirect

        return_check
	}
	#}}}
	# Funktion (gauge), einen Fortschrittsbalken anzeigen{{{
	#
	# usage: echo $PERCENT |  gauge TITLE MSG
	#
	# Mit dieser funktion koennen Sie einen Prozessbalken erzeugen.
	# Die Variable "PERCENT" muss der Funktion uebergeben werden!
	# echo $PERCENT | gauge TITLE_NAME NACHRICHT
	# TITLE - Variable die den Titel der Dialogbox enthaelt
	# MSG - Variable die eine Nachricht/Datei oder so enthaelt. Dient zur 
	# 	Statusanzeige.
	#
	gauge() {
		if [[ $# -ge 2 ]] && [[ ! -z "$PERCENT" ]] ; then
			TITLE="$1"
			MSG="$2"
	
			if [ -n "$3" -a "$3" -gt 0 ] ; then
                local Anz
                integer Anz
				Anz="$3"
				Overhead=7
				if [ "$[Anz+Overhead]" -lt "$LINES" ]; then
				    (( DisplayLines = Anz+Overhead ))
				else
					(( DisplayLines = LINES-4 ))
				fi
            else
                DisplayLines=7
            fi
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"

			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--gauge \"$MSG\" $DisplayLines $DisplayColumns ${PERCENT%.*}"
			eval $Dialog $DialogTitle $DialogPara
		else
			no_para_msg $0
			if [ -n "$BREAK" ] ; then
				break "$BREAK"
				unset -- BREAK
			fi
		fi
	}
	#}}}
	# Funktion (infobox), eine Infobox, nach Zeit anzeigen# {{{
	#
	# usage: infobox TITLE MSG SECOND
    #        TITLE - Titel der Nachricht
    #        MSG - Nachricht die angezeigt werden soll
	#        SECOND - Zahl in Sekunden, wie lange die Nachricht angezeigt werden soll
	#
	infobox() {
		unset -- Anz
		local Anz
		integer Anz
		if [ "$#" -eq 3 ] ; then
			UNIT=$(gettext 'Sekunden')
			UNIT1=$(gettext 'Sekunde')
	
			SEC=$3
            # Berechnung der uebergebenen Zeichen der Nachricht und
            # dementsprechend die Zeilengroesse einstellen.
            count_char_to_line "$2"
			Overhead=8
			if [ "$[gv_LineAnz+Overhead]" -lt "$LINES" ]; then
			    (( DisplayLines = gv_LineAnz+Overhead ))
			else
				(( DisplayLines = LINES-4 ))
			fi
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
			DialogTitle="--sleep 1 --title \"$T_String\" $DialogBackTitle"
			while test $SEC != 0 ; do
				DialogPara="--clear --infobox \"$2\n$SEC $UNIT ...\" $DisplayLines $DisplayColumns"
				eval $Dialog $DialogTitle $DialogPara
				(( SEC-- ))
				test $SEC = 1 && UNIT="$UNIT1"
			done
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (inputbox), eine Eingabebox anzeigen{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: inputbox "$TITLE" "$MSG" ["$INIT"]
	#        TITLE - Der TITLE wird aus 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        MSG - Die MESSAGE wird aus
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen,
	#              oder aus der Funktion script_init.
	#        Wenn $INIT mit uebergeben wird, kann dieser Wert
	#        bei einem Abbruch erhalten werden.
	#
	inputbox() {
		unset -- V_WERT
		if [ "${#argv}" -ge 2 ] ; then
			# vorherige Werte speichern.
			if [[ ${#argv} == 3 ]] ; then
				V_WERT="$3"
			fi
            # Berechnung der uebergebenen Zeichen der Nachricht und
            # dementsprechend die Zeilengroesse einstellen.
            count_char_to_line "$2"
			Overhead=8
			if [ "$[gv_LineAnz+Overhead]" -lt "$LINES" ]; then
			    (( DisplayLines = gv_LineAnz+Overhead ))
			else
				(( DisplayLines = LINES-4 ))
			fi
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
	
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --inputbox \"$2\" $DisplayLines $DisplayColumns \"$3\""
			eval $Dialog $DialogTitle $DialogPara $DialogReDirect
		
			return_check
		else
			no_para_msg $0
		fi
		unset -- V_WERT
	}
	#}}}
	# Funktion (inputmenu), eine Menubox mit Eingabe anzeigen{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: inputmenu "$DEFAULT-ITEM" "$TITLE" "$MSG" "$ARRAY"
	#        DEFAULT-ITEM - Item auf welches bei der Anzeige gesprungen werden soll.
	#                       Kann auch "" leer sein, es muessen aber die beiden Apostrophe
	#                       mit/oder ohne Variable (Bsp.:$1) sein.
	#        TITLE - Der TITLE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        MSG - Die MESSAGE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen,
	#              oder aus der Funktion script_init.
	#        ARRAY - Array mit Werten die man auswaehlen kann.
	#
	inputmenu() {
		if [ "${#argv}" -ge 4 ] ; then
			# Fenstergroesse (Zeilen) berechnen.
			#count_display_line -o 7 "$4"
			count_display_line -o 15 "$4"
			# Fenstergroesse (Spalten) berechnen.
            count_display_col "$4"
			# Laenge des Titel berechnen
			count_title_string "$2" "$DisplayColumns"

			DialogLabel="--help-button --nook --cancel-label "$gv_Back" --default-item \"$1\""
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --inputmenu \"$3\" $DisplayLines $DisplayColumns $Elemente $4"
			eval $Dialog $DialogLabel $DialogTitle $DialogPara $DialogReDirect
			
			return_check
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (menubox), eine Menuebox anzeigen{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: menubox "DEFAULT-ITEM" "$TITLE" "$MSG" "$ARRAY" [ $VAR ]
	#        DEFAULT-ITEM - Item auf welches bei der Anzeige gesprungen werden soll.
	#                       Kann auch "" leer sein, es muessen aber die beiden Apostrophe
	#                       mit/oder ohne Variable (Bsp.:$1) sein.
	#        TITLE - Der TITLE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        MSG - Die MESSAGE wird aus der 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen,
	#              oder aus der Funktion script_init.
	#        ARRAY - Array mit Werten die man auswaehlen kann.
	#        VAR - Variable die den vorherigen Wert enthaelt.
	#              wird benoetigt, falls man schon Werte hat
	#              und diese erhalten will, z.B. beim Abbrechen.
	#			   Ist optional.
	#
	#####################################################
	# TODO: evtl. DEFAULT-ITEM auch als VAR deklarierien?
	# Ist ja beides gleich.
	#####################################################
	menubox() {
		unset -- V_WERT
		if [ "${#argv}" -ge 4 ] ; then
			if [[ ${#argv} == 5 ]] ; then
				V_WERT="$5"
			fi
			# Fenstergroesse (Zeilen) berechnen.
			count_display_line -o 7 "$4"
			# Fenstergroesse (Spalten) berechnen.
            count_display_col "$4"
			# Laenge des Titel berechnen
			count_title_string "$2" "$DisplayColumns"

			DialogLabel="--help-button --default-item \"$1\""
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --menu \"$3\" $DisplayLines $DisplayColumns $Elemente $4"

			eval $Dialog $DialogLabel $DialogTitle $DialogPara $DialogReDirect
			
			return_check
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (mixedform), ein mixedform Box anzeigen{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: mixedform [ -i ] "$TITLE" "$MSG" "$ARRAY"
	# -i - insecure
	#
	mixedform() {
		if [ "$#" -ge 3 ] ; then
			if [ "$1" = -i ] ; then
				# Fenstergroesse (Zeilen) berechnen.
				count_display_line -f 12 "$4"
				# Fenstergroesse (Spalten) berechnen.
	            count_display_col "$4"
				# Laenge des Titel berechnen
				count_title_string "$2" "$DisplayColumns"

				DialogTitle="--title \"$T_String\" $DialogBackTitle"
				DialogLabel="--help-button"
				DialogPara="--clear --insecure --mixedform \"$3\" $DisplayLines $DisplayColumns $Elemente $4"
			else
				# Fenstergroesse (Zeilen) berechnen.
				count_display_line -f 12 "$3"
				# Fenstergroesse (Spalten) berechnen.
	            count_display_col "$3"
				# Laenge des Titel berechnen
				count_title_string "$1" "$DisplayColumns"

				DialogTitle="--title \"$T_String\" $DialogBackTitle"
				DialogLabel="--help-button"
				DialogPara="--clear --mixedform \"$2\" $DisplayLines $DisplayColumns $Elemente $3"
			fi

			eval $Dialog $DialogLabel $DialogTitle $DialogPara $DialogReDirect
			
			return_check
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (mixed_password), Passphrase eingeben# {{{
	# usage: mixed_password -o TITLE MSG [ MIN_ZAHL ] [ MAX_ZAHL ]
	#        -o - mit alten Passwort angeben
    #        TITLE - Titel der Nachricht
    #        MSG - Nachricht die angezeigt werden soll
	#        MIN_ZAHL - Wieviel Zeichen soll das Passwort mindestens haben.
	#        MAX_ZAHL - Wieviel Zeichen darf das Passwort hoechstens haben.
	#
	mixed_password() {
		unset -- MinChar MaxChar Opt_Anz gv_Pass gv_Old_Pass
		local MinChar MaxChar OPW NPW NNPW Title Msg
		if [ "${#argv}" -ge 2 ] ; then
			# Variablen Auswertung# {{{
			case "${#argv}" in
				5)
					Opt_Anz="3"
					Title="$2"
					Msg="$3"
					MinChar=$4
					MaxChar=$5
					;;
				4)
					if [ "$1" = "-o" ] ; then 
						Opt_Anz="3"
						Title="$2"
						Msg="$3"
						MinChar=$4
					else
						Opt_Anz="2"
						Title="$1"
						Msg="$2"
						MinChar=$3
						MaxChar=$4
					fi
					;;
				3)
					if [ "$1" = "-o" ] ; then 
						Opt_Anz="3"
						Title="$2"
						Msg="$3"
						MinChar=6
					else
						Opt_Anz="2"
						Title="$1"
						Msg="$2"
						MinChar="$3"
					fi
					;;
				2)
					Opt_Anz="2"
					Title="$1"
					Msg="$2"
					;;
			esac
			## }}}
			# Funktion (mixed_password_menu)# {{{
			mixed_password_menu() {
				if [ "$Opt_Anz" = 3 ] ; then
					PASSWD_MENU=(\"$gv_Old_Passwd\" "1 1 \"\" 1 20 22 0 1"
					\"$gv_New_Passwd\" "2 1 \"\" 2 20 22 0 1"
					\"$gv_New_Passwd\" "3 1 \"\" 3 20 22 0 1")
				else
					PASSWD_MENU=(\"$gv_New_Passwd\" "1 1 \"\" 1 20 22 0 1"
					\"$gv_New_Passwd\" "2 1 \"\" 2 20 22 0 1")
				fi
				mixedform -i "$Title" "$Msg" "$PASSWD_MENU"
			}
			## }}}
			#
			mixed_password_menu
			while [[ -n $gv_Auswahl ]] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/password_help
						mixed_password_menu
						;;
					*)	# Auswahl uebernehmen
						Anz="${(w)#gv_Auswahl}"
						if [ "$Anz" -eq "$Opt_Anz" ] ; then
							if [ "$Opt_Anz" = 3 ] ; then
								OPW="${${(ws: :)${=gv_Auswahl}}[1]}"
								NPW="${${(ws: :)${=gv_Auswahl}}[2]}"
								NNPW="${${(ws: :)${=gv_Auswahl}}[3]}"
							else
								NPW="${${(ws: :)${=gv_Auswahl}}[1]}"
								NNPW="${${(ws: :)${=gv_Auswahl}}[2]}"
							fi
							if [ "$NPW" = "$NNPW" ] ; then
								Char="${(c)#NPW}"
								if [ -n "$MaxChar" ] ; then
									if [ "$Char" -lt "$MinChar" -o "$Char" -gt "$MaxChar" ] ; then
										# falsche Password Laenge
										MSG=$(gettext 'Die Laenge des/der Passworts/Passphrase muss mindestens $MinChar und hoechstens $MaxChar Zeichen sein.\nSoll die Eingabe der Passphrase wiederholt werden (ja/nein)?')
										yesno "$gv_Attention" "$MSG" ""
										if [ "$gv_Auswahl" = yes ] ; then
											mixed_password_menu
										else
											unset -- OPW NPW NNPW gv_Pass gv_Old_Pass
				    						break
										fi
									else
										# richtige Password Laenge
										gv_Old_Pass="$OPW"
										gv_Pass="$NPW"
										unset -- OPW NPW NNPW
										break
									fi	
								elif [ "$Char" -lt "$MinChar" ] ; then
									# falsche Password Laenge
							        MSG=$(gettext 'Die Laenge des/der Passworts/Passphrase muss mindestens $MinChar Zeichen sein.\nSoll die Eingabe der Passphrase wiederholt werden (ja/nein)?')
									yesno "$gv_Attention" "$MSG" ""
									if [ "$gv_Auswahl" = yes ] ; then
										mixed_password_menu
									else
										unset -- OPW NPW NNPW gv_Pass gv_Old_Pass
			    						break
									fi
								else
									# richtige Password Laenge
									gv_Old_Pass="$OPW"
									gv_Pass="$NPW"
				                    unset -- OPW NPW NNPW
			    					break
								fi
							else
								# Passwoerter sind verschieden.
								different_passwd
								mixed_password_menu
							fi
						else
							# Nachricht das alle Felder belegt sein muessen.
							input_all_field_msg
							mixed_password_menu
						fi
						;;
				esac
			done
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (msgbox), Nachricht anzeigen{{{
	#
	# usage: msgbox TITLE MSG
	#        TITLE - Der TITLE wird aus
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen.
	#        MSG - Die MSG wird aus 
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen, oder
	#               aus der Funktion script_init.
	#
	msgbox() {
		if [ "$#" -eq 2 ] ; then
            # Berechnung der uebergebenen Zeichen der Nachricht und
            # dementsprechend die Zeilengroesse einstellen.
            count_char_to_line "$2"
			count_display_col "$2"
			Overhead=8
			if [ "$[gv_LineAnz+Overhead]" -lt "$LINES" ]; then
			    (( DisplayLines = gv_LineAnz+Overhead ))
			else
				(( DisplayLines = LINES-4 ))
			fi
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --msgbox \"$2\" $DisplayLines $DisplayColumns"
			eval $Dialog $DialogTitle $DialogPara
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (number_input), verschiedene Zahleneingaben (Tage, Byte, ...){{{
	#
	# benoetigt die Funktionen check_integer, check_number und no_input_msg
	#
	# usage: number_input [ -b | -d | -h | -i | -m | -s | -w ] ${VAR%?}
	#        number_input $1 $2 $3
	#        number_input -a $1 $2 $3
	#        number_input -D $1 $2 $3
	#        number_input -z $1 $2 $3
	#
	# -a - alle Zeiten, Sekunde, Minute, Stunde, Tag, Woche + eig. Nachricht
	# -b - Byte
	# -d - Tag
	# -D - Laufwerks Groessen (K|k|M|m|G|g|T|t.... beachten.
	# -h - Stunde
	# -i - integer Zahl
	# -m - Minute
	# -s - Sekunde
	# -w - Woche
	# -z - dezimal
	# nichts - fuer Eingaben die selber TITLE und MSG uebergeben
	# $VAR - vorheriger Wert
	#
	number_input() {
		unset -- NUMBER
		TITLE=$(gettext 'Konfiguration::Zahlen')
		case $1 in
			-a)
				# Alle Zeiten mit Sekunde, Minute, Stunde, Tag, Woche und.# {{{
				# eigener Nachricht.
				inputbox "$2" "$3" "$4"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl%[smhdw]}" "${gv_Auswahl##*[0-9]}"
				else
					no_input_msg
				fi
				## }}}
				;;
			-b)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Byte ein (Bsp. 51200) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}"
				else
					no_input_msg
				fi
				;;
			-d)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Tagen (Bsp. 5) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}" d
				else
					no_input_msg
				fi
				;;
			-h)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Stunden (Bsp. 4) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}" h
				else
					no_input_msg
				fi
				;;
			-i)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl (Bsp. 3) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}"
				else
					no_input_msg
				fi
				;;
			-m)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Monaten (Bsp. 1) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}" m
				else
					no_input_msg
				fi
				;;
			-s)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Sekunden (Bsp. 300) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}" s
				else
					no_input_msg
				fi
				;;
			-w)
				MSG=$(gettext 'Geben Sie hier bitte eine Zahl, in Wochen (Bsp. 3) ein.')
				inputbox "$TITLE" "$MSG" "$2"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "${gv_Auswahl// /}" w
				else
					no_input_msg
				fi
				;;
			-z)
				inputbox "$2" "$3" "$4"
				if [[ -n $gv_Auswahl ]] ; then
					check_number -z "${gv_Auswahl// /}"
				else
					no_input_msg
				fi
				;;
			-D)
				# Laufwerkes Groessen beachten# {{{
				inputbox "$2" "$3" "$4"
				if [[ -n $gv_Auswahl ]] ; then
					case "$gv_Auswahl" in
						*[0-9])
							check_number "$gv_Auswahl"
							;;
						*)
							case "${gv_Auswahl##*[0-9]}" in
								kb|KB|Kb|gb|GB|Gb|mb|MB|Mb|tb|TB|Tb|pb|PB|Pb|eb|EB|Eb)
#								kb|KB|Kb|gb|GB|Gb|mb|MB|Mb|tb|TB|Tb|pb|PB|Pb|eb|EB|Eb|zb|ZB|Zb|yb|YB|Yb)
									check_number -z "${gv_Auswahl%[kKmMgGtTpPeEzZyY]*}" "${gv_Auswahl##*[0-9]}"
									;;
								kib|KiB|Kib|gib|GiB|Gib|mib|MiB|Mib|tib|TiB|Tib|pib|PiB|Pib|eib|EiB|Eib)
#								kib|KiB|Kib|gib|GiB|Gib|mib|MiB|Mib|tib|TiB|Tib|pib|PiB|Pib|eib|EiB|Eib|zib|ZiB|Zib|yib|YiB|Yib)
									check_number -z "${gv_Auswahl%[kKmMgGtTpPeEzZyY]*}" "${gv_Auswahl##*[0-9]}"
									;;
								*)
									MSG=$(gettext 'Sie haben eine falsche Masseinheit angegeben. Es gehen nur die Masseinheiten kb|KB|Kb - KiloByte...eb|EB|Eb - ExaByte oder kib|KiB|Kib KibiByte...eib|EiB|Eib ExbiByte.')
									msgbox "$gv_Attention" "$MSG"
									;;
							esac
							;;
					esac
				else
					no_input_msg
				fi
				## }}}
				;;
			*)
				inputbox "$1" "$2" "$3"
				if [[ -n $gv_Auswahl ]] ; then
					check_number "$gv_Auswahl"
				else
					no_input_msg
				fi
				;;
		esac
	}
	#}}}
	# Funktion (password), Passwordeingabe{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: password TITLE MSG [ MIN_ZAHL ] [ MAX_ZAHL ]
    #        TITLE - Titel der Nachricht
    #        MSG - Nachricht die angezeigt werden soll
	#        MIN_ZAHL - Wieviel Zeichen soll das Passwort mindestens haben.
	#        MAX_ZAHL - Wieviel Zeichen darf das Passwort hoechstens haben.
	#
	# Das Passwort muss mindestens 6 Zeichen lang sein.
	#
	password() {
		unset -- MinChar MaxChar
		local MinChar MaxChar
		if [ "$#" -ge 2 ] ; then
			if [ -n "$3" -a -n "$4" ] ; then 
				MinChar=$3
				MaxChar=$4
			elif [ -n "$3" ] ; then 
				MinChar=$3
			else
				MinChar=6
			fi
            # Berechnung der uebergebenen Zeichen der Nachricht und
            # dementsprechend die Zeilengroesse einstellen.
            count_char_to_line "$2"
            Overhead=8
			if [ "$[gv_LineAnz+Overhead]" -lt "$LINES" ]; then
			    (( DisplayLines = gv_LineAnz+Overhead ))
			else
				(( DisplayLines = LINES-4 ))
			fi
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --insecure --passwordbox \"$2\" $DisplayLines $DisplayColumns"
			eval $Dialog $DialogTitle $DialogPara $DialogReDirect
			
			return_check
			
			Char="${(c)#gv_Auswahl}"
			if [ -n "$MaxChar" ] ; then
				if [ "$gv_Auswahl" -a "$Char" -ge "$MinChar" -a "$Char" -le "$MaxChar" ] ; then
					PASSPHRASE="$gv_Auswahl"
				else
					# falsche Password Laenge
					MSG=$(gettext 'Die Laenge des/der Passworts/Passphrase muss mindestens $MinChar und hoechstens $MaxChar Zeichen sein.')
					msgbox "$gv_Attention" "$MSG"
					unset -- gv_Auswahl PASSPHRASE
				fi	
			else
				if [ "$gv_Auswahl" -a "$Char" -ge "$MinChar" ] ; then
					PASSPHRASE="$gv_Auswahl"
				else
					# falsche Password Laenge
					MSG=$(gettext 'Die Laenge des/der Passworts/Passphrase muss mindestens $MinChar Zeichen sein.')
					msgbox "$gv_Attention" "$MSG"
					unset -- gv_Auswahl PASSPHRASE
				fi	
			fi
			unset -- gv_Auswahl
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (progressbox)# {{{
	#
	# Man kann die Funktion prog_exec benutzen - untersucht ob PROG_NAME
	# existiert bzw. ausfuehrbar ist. Siehe Header der Funktion prog_exec
	#
	# usage: prog_exec PROG_NAME PROG_OPT | progressbox TITLE [MSG]
	#        MSG ist optional.
	#
	progressbox() {
		if [ "$#" -ge 1 ] ; then
            Overhead=7
			(( DisplayLines = LINES-Overhead ))
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
			
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--progressbox \"$2\" $DisplayLines $DisplayColumns"
			eval $Dialog $DialogTitle $DialogPara
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (radiolist), einfache Auswahl{{{
	#
	# benoetigt die Funktion return_check
	#
	# usage: radiolist "DEFAULT-ITEM" "$TITLE" "$MSG" "$ARRAY" [ VAR ]
	#        DEFAULT-ITEM - Item auf welches bei der Anzeige gesprungen werden soll.
	#        TITLE - Der TITLE wird aus der
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen
	#        MSG - Die MESSAGE wird aus der
	#        	*/locale/${LANGUAGE}/LC_MESSAGES/gv_ScriptName.mo gelesen,
	#              oder aus der Funktion script_init.
	#        ARRAY - Array mit Werten die man auswaehlen kann.
	#        VAR - Variable die den vorherigen Wert enthaelt.
	#              wird benoetigt, falls man schon Werte hat
	#              und diese erhalten will, z.B. beim Abbrechen.
	#			   Ist optional
	#
	radiolist() {
		unset -- V_WERT
		if [[ ${#argv} -ge 4 ]] ; then
			# vorherige Werte speichern.
			if [[ ${#argv} == 5 ]] ; then
				V_WERT="$5"
			fi
			# Fenstergroesse (Zeilen) berechnen.
			count_display_line -m 7 "$4"
			# Fenstergroesse (Spalten) berechnen.
            count_display_col "$4"
			# Laenge des Titel berechnen
			count_title_string "$2" "$DisplayColumns"

			DialogLabel="--help-button --default-item \"$1\""
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --radiolist \"$3\" $DisplayLines $DisplayColumns $Elemente $4"

			eval $Dialog $DialogLabel $DialogTitle $DialogPara $DialogReDirect
			
			return_check
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (script_backtitle)# {{{
	script_backtitle() {
		local Now_Year
		Now_Year="`date +%Y`"
		DialogBackTitle="--backtitle \"$gv_ScriptName, $gv_Firm Netzworkk - $gv_MyName (C) 2002-$Now_Year\""
	}
	## }}}
	# Funktion (script_help), Hilfe anzeigen{{{
	#
	# usage: script_help "HELPFILE" oder bei kwadmin den Anfang der Hilfedatei
	# Die Hilfe liegt unter ../share/kwtools/help/HELPFILE oder
	#  ../share/kwtools/help/share/HELPFILE
	#
	# Beispiele:
	#       scrip_help "HELPFILE HELPFILE"
	#       scrip_help share/HELPFILE
	#       scrip_help Menuepunkt
	# 
	# Bei kwadmin muss der Dateiname, der Hilfe, das Format 
	# "Menuepunkt_Scriptname_help" besitzen.
	# Menuepunkte sind graphic, multi, net, sys und utils
	#
	script_help() {
		if [ "$#" -eq 1 ] ; then
			unset -- Elemente
			# Hilfe fuer kwadmin
			if [ $gv_ScriptName = kwadmin -a $1 = help ] ; then
				if [ -f ${HELP_PATH}/${gv_ScriptName}/${1} ] ; then
					. ${HELP_PATH}/${gv_ScriptName}/${1}
					> "${gv_WorkDir}/help$$" <<< "`print $MSG`"
					textbox "$TITLE" "${gv_WorkDir}/help$$"
				else
					no_help_msg
				fi
				# Hilfe von allen installierten Scripts.
			elif [ $gv_ScriptName = kwadmin ] ; then
				if [ -f ${HELP_PATH}/${gv_ScriptName}/${1}_help ] ; then
					. ${HELP_PATH}/${gv_ScriptName}/${1}_help
					> "${gv_WorkDir}/help$$" <<< "`print $MSG`
"
					# restliche Hilfe anzeigen - falls installiert.
					for i in ${HELP_PATH}/${gv_ScriptName}/${1}_*_help(N) ; {
						. $i
						>> "${gv_WorkDir}/help$$" <<< "`print $MSG`
"
					}
					textbox "$TITLE" "${gv_WorkDir}/help$$"
				else
					no_help_msg
				fi
				# Hilfe die von mehreren Scripts genutzt werden koennen.
			elif [ ${1%/*} = share ] ; then
				if [ -f ${HELP_PATH}/${1} ] ; then
					. ${HELP_PATH}/${1}
					> "${gv_WorkDir}/help$$" <<< "`print $MSG`"
					textbox "$TITLE" "${gv_WorkDir}/help$$"
				else
					no_help_msg
				fi
			else
				# Hilfe der Scripts.
				for i in ${=1} ; {
					for f in ${HELP_PATH}/${gv_ScriptName}/${i}(.N) ; {
						. $f
						>> "${gv_WorkDir}/help$$" <<< "`print $MSG`
"
					}
				}
				if [ -s "${gv_WorkDir}/help$$" ] ; then
					textbox "$TITLE" "${gv_WorkDir}/help$$"
				else
					no_help_msg
				fi
			fi
			rm -rf ${gv_WorkDir}/help$$ &>/dev/null
		else
			no_para_msg $0
		fi
	}	
	#}}}
	# Funktion (textbox), zum anzeigen einer Datei{{{
	#
	# usage: textbox "$TITLE" "$FILE"
	#
	textbox() {
		if [ "$#" -eq 2 ] ; then
			# Berechnung der Fenstergroesse (Zeilen).
			count_display_line 7 "`wc -l < "$2"`"
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"
	
			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--clear --cr-wrap --tab-correct --tab-len 8 --textbox ${2} $DisplayLines $DisplayColumns"
			eval $Dialog $DialogTitle $DialogPara
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (timebox), zum einstellen der Uhr{{{
	#
	# usage: timebox [TIME]
	#		 TIME - Uhrzeit (hhmm).
	#
	timebox() {
		local Anz Time
		unset -- Anz
		TITLE=$(gettext 'Uhrzeit')
		MSG=$(gettext 'Stellen Sie bitte Ihre Zeit ein und bestaetigen Sie diese.')
		if [ "$#" -eq 1 ] ; then
			if [ "${(c)#1}" -ge 3 -a "${(c)#1}" -le 4 ] ; then
				Time="`date -d $1 +%H:%M`"
			fi
		fi

		# Berechnung der Fenstergroesse (Zeilen)
		count_display_line -l 4 "$MSG"
		
		DialogTitle="--title \"${gv_ScriptName}::${TITLE}\" $DialogBackTitle"
		DialogPara="--clear --timebox \"$MSG\" $DisplayLines 35 `print ${(s,:,)${Time}}`"
		eval $Dialog $DialogTitle $DialogPara $DialogReDirect
		
		return_check
	}
	#}}}
	# Funktion (view_file), fuer die Anzeige einer Datei{{{
	#
	# benoetigt die Funktion textbox
	# usage: view_file FILE [ TITLE ]
	# FILE - Datei die angezeigt werden soll.
	# TITLE - (optional) Titel der angezeigt werden soll.
	#
	view_file() {
		if [[ ${#argv} -ge 1 ]] ; then
			if [ -f "$1" -a -z "$2" ] ; then
				textbox "$gv_Info" "$1"
			elif [ -f "$1" -a ! -z "$2" ] ; then
				textbox "$2" "$1"
			else
				no_para_msg $0
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (yesno), Ja/Nein Abfrage{{{
	#
	# Man kann die Funktion "yesno_option" benutzen um
	# eine Vorauswahl für diese Funktion zu treffen.
	# Die Variable ist dann YN_OPT für "yesno".
	#
	# usage: yesno "TITLE" "MSG" "" [ Anzahl ]
	# usage: yesno "TITLE" "MSG" "VALUE" [ Anzahl ]
	#        VALUE  - no, yes oder Wert für --default-label. Kann auch leer sein.
	#        Anzahl - die Anzahl der Zeilen die zusätzlich mit Extra_Overhead
	#                 berechnet werden sollen, sonst wird als Overhead nur 7
	#                 (Zeilen) angezeigt. Ist optional.
	#
	yesno() {
		local Extra_Overhead E_Lines Label
		integer Extra_Overhead E_Lines
		if [ "${#argv}" -ge 3 ] ; then
			if [[ ${#argv} == 4 ]] ; then
				Label="$3"
				E_Lines="$4"
			else
				Label="$3"
				E_Lines="0"
			fi
			case "$Label" in
				no|off|false)
					# Anzeige mit --default-label NO
					DialogLabel="--default-button NO"
					;;
				yes|on|true|\$*|[a-zA-Z0-9]*)
					# Anzeige mit --default-label YES
					DialogLabel="--default-button YES"
					;;
				*)
					# Anzeige mit --default-label YES
					DialogLabel="--default-button YES"
					;;
			esac
			# Berechnung der Fenstergroesse (Zeilen).
			(( Extra_Overhead = 7 + $E_Lines ))
			count_display_line -l "$Extra_Overhead" "$2"
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"

			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--yesno \"$2\" $DisplayLines $DisplayColumns"
			eval $Dialog $DialogLabel $DialogTitle $DialogPara
			
			# return check
			case "$?" in
				0)
					# Yes
					if [ ! -z "$Label" -a "$Label" != no ] ; then
						gv_Auswahl="$Label"
					else
						gv_Auswahl="yes"
					fi
					;;
				1)
					# No
					gv_Auswahl="no"
					;;
				255)
					# Abbruch
					if [ ! -z "$Label" ] ; then
						gv_Auswahl="$Label"
					else
						gv_Auswahl=""
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (yesno_exchange), um eine Variable mit unterschiedlichen Werten zu belegen.{{{
	#
	# usage: yesno_exchange TITLE MSG VARIABLE WERT1 WERT2
	#        VARIABLE - Variable die veraendert werden soll
	#        WERT* - meist yes & no, kann aber auch was anderes sein.
	#
	yesno_exchange() {
		if [ "$#" = 5 ] ; then
			VAR=$3
			(( DisplayColumns = COLUMNS-8 ))
			# Laenge des Titel berechnen
			count_title_string "$1" "$DisplayColumns"

			DialogTitle="--title \"$T_String\" $DialogBackTitle"
			DialogPara="--yesno \"$2\" 7 $DisplayColumns"
		    eval $Dialog $DialogTitle $DialogPara
			if [ "$?" = 0 ] ; then
				export $VAR=$4
			else
				export $VAR=$5
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	## }}}
	###### System ###### {{{
	# Funktion (access), fuer Zugriffsrechte{{{
	#
	# findet die Zugriffsrechte, den Besitzer und die Gruppe der Datei
	#
	# usage: access "$DATEI"
	access() {
		unset -- ACCESS
		local u_mod su_mod ug_mod g_mod o_mod a_mod Mod User Group
		if [ "$#" = 1 ] ; then
			Mod=${$(ls -ld "$1")[1]}
			User=${$(ls -ld "$1")[3]}
			Group=${$(ls -ld "$1")[4]}
			# User Rechte{{{
			case ${Mod[2,4]} in
				rws)	su_mod=47
					;;
				rwS)	su_mod=46
					;;
				r-s)	su_mod=45
					;;
				r-S)	su_mod=44
					;;
				-ws)	su_mod=43
					;;
				-wS)	su_mod=42
					;;
				--s)	su_mod=41
					;;
				--S)	su_mod=40
					;;
				rwx)	u_mod=7
					;;
				rw-)	u_mod=6
					;;
				r-x)	u_mod=5
					;;
				r--)	u_mod=4
					;;
				-w-)	u_mod=2
					;;
				--x)	u_mod=1
					;;
				---)	u_mod=0
					;;
			esac
			#}}}
			# Gruppen Rechte{{{
			case ${Mod[5,7]} in
				rws)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}7"
						else
							ug_mod=2${u_mod}7
						fi
					;;
				rwS)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}6"
						else
							ug_mod=2${u_mod}6
						fi
					;;
				r-s)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}5"
						else
							ug_mod=2${u_mod}5
						fi
					;;
				r-S)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}4"
						else
							ug_mod=2${u_mod}4
						fi
					;;
				-ws)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}3"
						else
							ug_mod=2${u_mod}3
						fi
					;;
				-wS)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}2"
						else
							ug_mod=2${u_mod}2
						fi
					;;
				--s)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}1"
						else
							ug_mod=2${u_mod}1
						fi
					;;
				--S)	if [ -n "$su_mod" ] ; then
							(( sg_mod = 2+${su_mod[1]} ))
							ug_mod="${sg_mod}1"
						else
							ug_mod=2${u_mod}1
						fi
					;;
				rwx)	g_mod=7
					;;
				rw-)	g_mod=6
					;;
				r-x)	g_mod=5
					;;
				r--)	g_mod=4
					;;
				-wx)	g_mod=3
					;;
				-w-)	g_mod=2
					;;
				--x)	g_mod=1
					;;
				---)	g_mod=0
					;;
			esac
			#}}}
			# Rechte von anderen{{{
			case ${Mod[8,10]} in
				rwt)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}7"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}7"
						else
							a_mod=${so_mod}${u_mod}${g_mod}7
						fi
					;;
				rwT)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}6"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}6"
						else
							a_mod=${so_mod}${u_mod}${g_mod}6
						fi
					;;
				r-t)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}5"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}5"
						else
							a_mod=${so_mod}${u_mod}${g_mod}5
						fi
					;;
				r-T)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}4"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}4"
						else
							a_mod=${so_mod}${u_mod}${g_mod}4
						fi
					;;
				-wt)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}3"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}3"
						else
							a_mod=${so_mod}${u_mod}${g_mod}3
						fi
					;;
				-wT)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}2"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}2"
						else
							a_mod=${so_mod}${u_mod}${g_mod}2
						fi
					;;
				--t)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}1"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}1"
						else
							a_mod=${so_mod}${u_mod}${g_mod}1
						fi
					;;
				--T)	so_mod=1
						if [ -n "$ug_mod" ] ; then
							(( so_mod = $so_mod+${ug_mod[1]} ))
							a_mod="${so_mod}1"
						elif [ -n "$su_mod" ] ; then
							(( so_mod = $so_mod+${su_mod[1]} ))
							a_mod="${so_mod}1"
						else
							a_mod=${so_mod}${u_mod}${g_mod}1
						fi
					;;
				rwx)	o_mod=7
					;;
				rw-)	o_mod=6
					;;
				r-x)	o_mod=5
					;;
				r--)	o_mod=4
					;;
				-wx)	o_mod=3
					;;
				-w-)	o_mod=2
					;;
				--x)	o_mod=1
					;;
				---)	o_mod=0
					;;
			esac
			#}}}
			# Variable ACCESS mit Werten belegen.
			if [ -n "$a_mod" ] ; then
				ACCESS="$a_mod $User $Group"
			elif [ -n "$ug_mod" ] ; then
				ACCESS="${ug_mod}${o_mod} $User $Group"
			elif [ -n "$su_mod" ] ; then
				ACCESS="${su_mod}${g_mod}${o_mod} $User $Group"
			else
				ACCESS="0${u_mod}${g_mod}${o_mod} $User $Group"
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (check_gv_Auswahl){{{
	#
	# loescht Variable $1, falls $gv_Auswahl leer ist und
	# fuehrt wenn angegeben eine Action aus.
	#
	# usage: check_gv_Auswahl [ VAR | VAR ACTION ]
	#
	check_gv_Auswahl() {
		if [ -z "$gv_Auswahl" ] ; then
			if [ -z "$2" ] ; then
				unset -- $1
			else
				export ${1}=${2##*=}
				${=2}
			fi
		fi
	}
	#}}}
	# Funktion (check_home_conf_dir), belegt die Variable gv_HomePath# {{{
	# zur Speicherung der Konfiguration 
	#
	# usage: check_home_conf_dir
	#
	check_home_conf_dir() {
		if [ "$UID" = 0 ] ; then
			gv_HomePath=${${(s,:,)${(M)${(f)"$(< /etc/passwd)"}##(s#)root*}}[6]}
			export HOME="$gv_HomePath"
		else
			gv_HomePath="$HOME"
		fi
		# kwtools Verzeichnis erstellen, falls nicht vorhanden.
		if [ ! -d ${gv_HomePath}/.kwtools ] ; then
			create_file -d ${gv_HomePath}/.kwtools
		fi
	}
	## }}}
	# Funktion (check_integer), pruefen auf Integer# {{{
	# und wenn dann uebernehmen.
	# Ansonsten kommt eine Fehlermeldung.
	#
	# usage: check_integer NUMBER [ Masseinheit ]
	# NUMBER - Integer Nummer die geprueft werden soll
	# Masseinheit - die eventuell an die Nummer wieder angehaengt werden soll
	#
	check_integer() {
		if [ "$#" -ge 1 ] ; then
			local Nr Me
			#integer Nr
			Nr="$1"
			Me="$2"
			# auf Integer pruefen
			if [[ $Nr = <-> ]] ; then
				NUMBER="${Nr}${Me}"
			else
				no_integer_msg
				unset -- NUMBER
			fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (check_mask)# {{{
	#
	# prueft die Anzahl der Zahlen und ob es die richtigen Access Zahlen sind.
	#
	# usage: check_mask
	check_mask() {
		if [ "${(c)#NUMBER}" = 4 -o "${(c)#NUMBER}" = 3 ] ; then
			case "$NUMBER" in
				[0-7][0-7][0-7][0-7]|[0-7][0-7][0-7])
					MASK="$NUMBER"
					;;
				*)	unset -- MASK
					no_input_msg
					;;
			esac
		else
			MSG=$(gettext 'Sie haben eine falsche Anzahl an Zeichen eingegeben. Sie muessen 4 oder 3 Integer Zahlen in Reihenfolge eingeben die die Rechte definieren (man 1 chmod).')
			msgbox "$gv_Attention" "$MSG"
		fi
	}
	## }}}
	# Funktion (check_memory), totaler Arbeitsspeicher# {{{
	#
	# usage: VAR=$(check_memory)
	#
	check_memory() {
		print ${${(s: :)${(M)${(f)"$(< /proc/meminfo)"}##MemTotal*}}[2]}
	}
	## }}}
	# Funktion (check_number), ueberpruft Zahleneingaben{{{
	#
	# benoetigt die Funktion no_dezimal_msg und check_integer
	#
	# usage: check_number [ -z ] "$NUMBER" [ Anhang ]
	# -z - Dezimalzahlen ueberpruefen
	# Anhang kann h (Stunde) oder so aehnlich sein.
	#
	check_number() {
		if [ "$#" -ge 1 ] ; then
			case "$1" in
				-z)	# Dezimalzahlen sind erlaubt (Bsp. 0.234)
					case "$2" in
						[0-9]*[.,]*[0-9]*)	# uebernehmen
							NUMBER="${2}${3}"
							;;
						[0-9]*)
							check_integer $2 $3
							;;
						*)
							unset -- NUMBER
							no_dezimal_msg
							;;
					esac
					;;
				*)	# pruefen auf Integer und wenn dann uebernehmen.
					check_integer $1 $2
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (check_fs), Filesystem heraus bekommen# {{{
	#
	# usage: check_fs FP
	# FP - Festplatten Partition/Laufwerk
	#
	check_fs() {
		if [[ ${#argv} == 1 ]] ; then
			# Pruefen, ob blkid vorhanden und ausführbar ist, ansonsten
			# wird abgebrochen.
			if [[ ! -x ${commands[blkid]} ]] ; then
				no_prog_exec_msg blkid
				exit 0
			fi
			#
			if [[ -b $1 ]] ; then
				local Fs_Dev Fs_Tmp Version
				Fs_Dev="$1"
				# Filesystem heraus bekommen.
				Fs_Tmp=$(blkid -o value -s TYPE -p $Fs_Dev)
				if [ ! -z "$Fs_Tmp" ] ; then
					case "$Fs_Tmp" in
#						LVM*|*_raid_*|crypto*)
#							gv_Fs="$gv_Unknown"
#							gv_NoFs="$Fs_Tmp"
#							;;
						*)
							case "$Fs_Tmp" in
								vfat)
									Version=$(blkid -o value -s VERSION -p $Fs_Dev)
									case "$Version" in
										FAT16) gv_Fs=fat16	;;
										FAT32) gv_Fs=fat32	;;
									esac
									;;
								*)
									gv_Fs="$Fs_Tmp"
									;;
							esac
							;;
					esac
				else
					gv_Fs="$gv_Unknown"
				fi
			else
				no_block_dev_msg "$1"
				return 1
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (check_size), prueft den vorhandenen Platz im jeweiligen Verzeichnis# {{{
	# wird in Bytes ausgegeben
	#
	# usage: check_size DIR
	check_size() {
		if [ "$#" -eq 1 ] ; then
			unset -- gv_Size Anz
			local Anz
			integer Anz
			gv_Size=0
			if [ -d "$1" ] ; then
				Anz=${${(s: :)$(export LC_ALL=C ; df -k $1)}[11]}	
				(( gv_Size = Anz * 1024 ))
			else
				no_dir_msg "$1"
			fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (compress_choice), um Kompressionsprogramme zur Auswahl anzubieten{{{
	#
	# usage: compress_choice Programmname Programmname
	#
	compress_choice() {
		if [[ ${#argv} -ge 1 ]] ; then
			unset -- K_Menue
			local No_Compress K_Menue
			No_Compress=$(gettext 'keine_Kompression')
			K_Menue="$No_Compress \"\""
			for i in $@ ; {
				if [[ -x ${commands[$i]} ]] ; then
					K_Menue="$K_Menue $i \"\""
				fi
			}
			#
			# Funktion compress_choice_menue{{{
			TITLE=$(gettext 'Kompression')
			MSG=$(gettext 'Waehlen Sie ein Kompressionsprogramm aus.')
			compress_choice_menue() {
				menubox "$1" "$TITLE" "$MSG" "$K_Menue"
			}
			#}}}
			compress_choice_menue "$COMPRESS"
			while [ "$gv_Auswahl" ] ; do
				case $gv_Auswahl in
					HELP*)	script_help compress_help
						compress_choice_menue "${gv_Auswahl#HELP }"
						;;
					b* | g* |co*)
						# Kompressionsart auswaehlen (gzip/bzip2/compress)
						#
						COMPRESS="${commands[$gv_Auswahl]}"
						if [ "${COMPRESS##*/}" = gzip ] ; then
							UNCOMPRESS="${commands[gunzip]}"
						elif [ "${COMPRESS##*/}" = bzip2 ] ; then
							UNCOMPRESS="${commands[bunzip2]}"
						else
							UNCOMPRESS="${commands[uncompress]}"
						fi
						break
						;;
					*)	#
						unset -- COMPRESS UNCOMPRESS
						break
						;;
				esac
			done
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (convert_drive_size), Laufwerks Groesse umrechnen.# {{{
	#
	# usage: convert_drive_size -i SIZE
	# usage: convert_drive_size [ kib|KiB|Kib | mib|MiB|Mib | gib|GiB|Gib | tib|TiB|Tib ] SIZE
	# usage: convert_drive_size [ pib|PiB|Pib | eib|EiB|Eib | zib|ZiB|Zib ] SIZE
	# usage: convert_drive_size [ yib|YiB|Yib ] SIZE
	# -i - inverse, Zahl wird in die best lesbare Form umgerechnet.
	# kib|KiB|Kib - KibiByte
	# mib|MiB|Mib - MebiByte
	# gib|GiB|Gib - GibiByte
	# tib|TiB|Tib - TebiByte
	# pib|PiB|Pib - PebiByte
	# eib|EiB|Eib - ExbiByte
	# zib|ZiB|Zib - ZebiByte # geht noch nicht, Zahlen zu lang
	# yib|YiB|Yib - YobiByte # geht noch nicht, Zahlen zu lang
	# nichts - Byte
	# SIZE - ZAHL
	#
	convert_drive_size() {
		unset -- Size_Kb_Tmp
		typeset -F3 Size_B_Tmp
		if [ "$#" -ge 2 ] ; then
			case "$1" in
				-i) 
					# Bytes umrechnen in die beste lesbare Form.# {{{
					unset -- SIZE_B SIZE_B_ME
					local Size
					Size="$2"
#					# nach YobiByte umrechnen# {{{
#					if [[ "$Size" -ge 1208925819614629174706176 ]] ; then
#						Size_B_Tmp=$Size/1208925819614629174706176.0
#						SIZE_B="$Size_B_Tmp"
#						SIZE_B_ME=YiB
#						## }}}
#					# nach ZebiByte umrechnen# {{{
#					if [[ "$Size" -ge 1180591620717411303424 ]] ; then
#						Size_B_Tmp=$Size/1180591620717411303424.0
#						SIZE_B="$Size_B_Tmp"
#						SIZE_B_ME=ZiB
#						## }}}
						# nach ExbiByte umrechnen# {{{
					if [[ "$Size" -ge 1152921504606846976 ]] ; then
						Size_B_Tmp=$Size/1152921504606846976.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=EiB
						## }}}
						# nach PebiByte umrechnen# {{{
					elif [[ "$Size" -ge 1125899906842624 ]] ; then
						Size_B_Tmp=$Size/1125899906842624.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=PiB
						## }}}
						# nach TebiByte umrechnen# {{{
					elif [[ "$Size" -ge 1099511627776 ]] ; then
						Size_B_Tmp=$Size/1099511627776.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=TiB
						## }}}
						# nach GibiByte umrechnen# {{{
					elif [[ "$Size" -ge 1073741824 ]] ; then
						Size_B_Tmp=$Size/1073741824.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=GiB
						## }}}
						# nach MebiByte umrechnen# {{{
					elif [[ "$Size" -ge 1048576 ]] ; then
						Size_B_Tmp=$Size/1048576.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=MiB
						## }}}
						# nach KibiByte umrechnen# {{{
					elif [[ "$Size" -ge 1024 ]] ; then
						Size_B_Tmp=$Size/1024.0
						SIZE_B="$Size_B_Tmp"
						SIZE_B_ME=KiB
						## }}}
					else
						SIZE_B="$Size"
						SIZE_B_ME=B
					fi
					## }}}
					;;
				*)	
					# MebiBytes, GibiBytes, ... nach Bytes umrechnen# {{{
					unset -- SIZE_B
					local Opt Size
					Opt="$1"
					Size="${2//,/.}"
#					Tmp="$Size:r"
#					# evtl. mit Nullen auffuellen
#					if [ ${#Size:e} -eq 1 ] ; then
#						Tmp1="${Size:e}00"
#					elif [ ${#Size:e} -eq 2 ] ; then
#						Tmp1="${Size:e}0"
#					else
#						Tmp1="$Size:e"
#					fi
					case "$Opt" in
						kib|KiB|Kib)	# in Byte umrechnen
							# 2hoch10 1KB=1024Byte# {{{
							(( SIZE_B = Size * 1024 ))
							## }}}
							;;
						mib|MiB|Mib)	# in Byte umrechnen
							# 2hoch20 1MB=1.048.576Byte# {{{
							(( SIZE_B = Size * 1048576 ))
							## }}}
							;;
						gib|GiB|Gib)	# in Byte umrechnen
							# 2hoch30 1GB=1.073.741.824Byte# {{{
							(( SIZE_B = Size * 1073741824 ))
							## }}}
							;;
						tib|TiB|Tib)	# in Byte umrechnen
							# 2hoch40 1TB=1.099.511.627.776Byte# {{{
							(( SIZE_B = Size * 1099511627776 ))
							## }}}
							;;
						pib|PiB|Pib)	# in Byte umrechnen
							# 2hoch50 1PB=1.125.899.906.842.624Byte# {{{
							(( SIZE_B = Size * 1125899906842624 ))
							## }}}
							;;
						eib|EiB|Eib)	# in Byte umrechnen
							# 2hoch60 1EB=1.152.921.504.606.846.976Byte# {{{
							(( SIZE_B = Size * 1152921504606846976 ))
							## }}}
							;;
#						zib|ZiB|Zib)	# in Byte umrechnen
#							# 2hoch70 1ZB=1.180.591.620.717.411.303.424Byte# {{{
#							(( SIZE_B = Size * 1180591620717411303424 ))
#							## }}}
#							;;
#						yib|YiB|Yib)	# in Byte umrechnen
#							# 2hoch80 1YB=1.208.925.819.614.629.174.706.176Byte# {{{
#							(( SIZE_B = Size * 1208925819614629174706176 ))
#							## }}}
#							;;
						*)	# ist schon Byte
							SIZE_B="$Size"
							;;
					esac
					## }}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	## }}}
#Funktion (convert_mib_size), YobiByte,..., TebiByte, GibiByte, nach MebiByte umrechnen# {{{
# siehe auch convert_drive_size
#
# usage: convert_mib_size [ Masseinheit | -i ] SIZE
#
convert_mib_size() {
	if [[ ${#argv} == 2 ]] ; then
		unset -- SIZE_MIB
		local Opt Size
		typeset -F3 Size_Part_Tmp
		Opt="$1"
		Size="${2//,/.}"
		case "$Opt" in
			-i)
#				# nach YobiByte umrechnen
#				if [[ $Size -ge 1152921504606846976 ]] ; then
#					(( Size_Part_Tmp = Size / 1152921504606846976.0 ))
#					SIZE_MIB="$Size_Part_Tmp"
#					SIZE_MIB_ME=YiB
#				# nach ZebiByte umrechnen
#				elif [[ $Size -ge 1125899906842624 ]] ; then
#					(( Size_Part_Tmp = Size / 1125899906842624.0 ))
#					SIZE_MIB="$Size_Part_Tmp"
#					SIZE_MIB_ME=ZiB
				# nach ExbiByte umrechnen
				if [[ $Size -ge 1099511627776 ]] ; then
					(( Size_Part_Tmp = Size / 1099511627776.0 ))
					SIZE_MIB="$Size_Part_Tmp"
					SIZE_MIB_ME=EiB
				# nach PebiByte umrechnen
				elif [[ $Size -ge 1073741824 ]] ; then
					(( Size_Part_Tmp = Size / 1073741824.0 ))
					SIZE_MIB="$Size_Part_Tmp"
					SIZE_MIB_ME=PiB
				# nach TebiByte umrechnen
				elif [[ $Size -ge 1048576 ]] ; then
					(( Size_Part_Tmp = Size / 1048576.0 ))
					SIZE_MIB="$Size_Part_Tmp"
					SIZE_MIB_ME=TiB
				# nach GibiByte umrechnen
				elif [[ $Size -ge 1024 ]] ; then
					(( Size_Part_Tmp = Size / 1024.0 ))
					SIZE_MIB="$Size_Part_Tmp"
					SIZE_MIB_ME=GiB
				else
				# ist schon MebiByte
					SIZE_MIB="$Size"
					SIZE_MIB_ME=MiB
				fi
				;;
			mib|MiB|Mib)	# ist schon MebiByte
				SIZE_MIB="$Size"
				;;
			gib|GiB|Gib)	# nach MebiByte umrechnen
				(( SIZE_MIB = Size * 1024 ))
				;;
			tib|TiB|Tib)	# nach MebiByte umrechnen
				(( SIZE_MIB = Size * 1048576 ))
				;;
			pib|PiB|Pib)	# nach MebiByte umrechnen
				(( SIZE_MIB = Size * 1073741824 ))
				;;
			eib|EiB|Eib)	# nach MebiByte umrechnen
				(( SIZE_MIB = Size * 1099511627776 ))
				;;
#			zib|ZiB|Zib)	# nach MebiByte umrechnen
#				(( SIZE_MIB = Size * 1125899906842624 ))
#				;;
#			yib|YiB|Yib)	# nach MebiByte umrechnen
#				(( SIZE_MIB = Size * 1152921504606846976 ))
#				;;
			*)	# Nachricht das diese Masseinheit nicht
				# unterstuetzt wird
				MSG=$(gettext 'Diese Masseinheit ($Opt) wird nicht unterstuetzt.')
				msgbox "$gv_Attention" "$MSG"
				return 1
				;;
		esac
	else
		no_para_msg $0
		return 1
	fi
	return 0
}
#}}}
	# Funktion (convert_si_size), Laufwerks Groesse nach SI System (Dezimal) umrechnen.# {{{
	#
	# usage: convert_si_size -i SIZE
	# usage: convert_si_size [ kb|KB|Kb | mb|MB|Mb | gb|GB|Gb | tb|TB|Tb ] SIZE
	# usage: convert_si_size [ pb||PB|Pb | eb|EB|Eb | zb|ZB|Zb ] SIZE
	# usage: convert_si_size [ yb|YB|Yb ] SIZE
	# -i - inverse, Zahl wird in die best lesbare Form umgerechnet.
	# kb||KB|Kb - KiloByte
	# mb|MB|Mb - MegaByte
	# gb|GB|Gb - GigaByte
	# tb|TB|Tb - TeraByte
	# pb|PB|Pb - PetaByte
	# eb|EB|Eb - ExaByte
	# zb|ZB|Zb - ZettaByte  # geht noch nicht, Zahlen zu lang
	# yb||YB|Yb - YottaByte # geht noch nicht, Zahlen zu lang
	# nichts - Byte
	# SIZE - ZAHL
	#
	convert_si_size() {
		unset -- Size_B_Tmp
		typeset -F3 Size_B_Tmp
		# Funktion (check_calc_suffix), ueberprueft ob nach# {{{
		# dem Komma der Wert zur Anzeige benoetigt wird und welche
		# Masseinheit angezeigt wird.
		# Ist die Zahl vor dem Komma/Punkt zweistellig und mehr wird
		# die uebergebene Masseinheit benutzt ansonsten die mit der
		# diese getauscht werden soll. So wird aus 4.252MB
		# 4252 MB und 23.008GB bleibt so erhalten
		#
		# usage: check_calc_suffix TARGET-UNIT REPLACEMENT-UNIT
		#
		# TARGET-UNIT - Normale Masseinheit
		# REPLACEMENT-UNIT - Ersatz Masseinheit
		check_calc_suffix() {
			unset -- Src_Unit Dst_Unit
			local Src_Unit Dst_Unit
			#
			if [ $# = 2 ] ; then
				Src_Unit="$1"
				Dst_Unit="$2"
				Size_B_Pre=$Size_B_Tmp:r
				Size_B_Suf=$Size_B_Tmp:e
				# Ist die Groesse vor dem Punkt/Komma >= 2
				# wird die Groesse nach dem Punkt/komma ueberprueft
				# ob sie ungleich 000 ist oder nicht.
				# Wenn sie gleich 000 ist wird keine Zahl nach dem Koma/Punkt
				# benoetigt.
				if [ "${#Size_B_Pre[@]}" -ge 2 ] ; then
					if [ "$Size_B_Suf" != 000 ] ; then
						SIZE_B="${Size_B_Tmp}${Src_Unit}"
					else
						SIZE_B="${Size_B_Pre}${Src_Unit}"
					fi
				else
					# andere Masseinheit uebergeben und Punkt/Komma entfernen.
					SIZE_B="${Size_B_Tmp//./}${Dst_Unit}"
				fi
			else
				no_para_msg $0
			fi
		}
		## }}}
		if [ "$#" -ge 2 ] ; then
			case "$1" in
				-i) 
					# Bytes umrechnen in die beste lesbare Form.# {{{
					unset -- SIZE_B
					local Size Size_Tmp
					Size=$2
#					# nach YByte umrechnen# {{{
#					if [[ "$Size" -ge 1000000000000000000000000 ]] ; then
#						(( Size_B_Tmp = Size/1000000000000000000000000.0 ))
#						check_calc_suffix YB ZB
#						## }}}
#						# nach ZByte umrechnen# {{{
#					if [[ "$Size" -ge 1000000000000000000000 ]] ; then
#						(( Size_B_Tmp = Size/1000000000000000000000.0 ))
#						check_calc_suffix ZB EB
#						## }}}
						# nach EByte umrechnen# {{{
					if [[ "$Size" -ge 1000000000000000000 ]] ; then
						(( Size_Tmp = Size/1000000000000000000.0 ))
						Size_B_Tmp=$Size_Tmp
						check_calc_suffix EB PB
						## }}}
						# nach PByte umrechnen# {{{
					elif [[ "$Size" -ge 1000000000000000 ]] ; then
						(( Size_Tmp = Size/1000000000000000.0 ))
						Size_B_Tmp=$Size_Tmp
						check_calc_suffix PB TB
						## }}}
						# nach TByte umrechnen# {{{
					elif [[ "$Size" -ge 1000000000000 ]] ; then
						(( Size_Tmp = Size/1000000000000.0 ))
						Size_B_Tmp=$Size_Tmp
						check_calc_suffix TB GB
						## }}}
						# nach GByte umrechnen# {{{
					elif [[ "$Size" -ge 1000000000 ]] ; then
						(( Size_Tmp= Size/1000000000.0 ))
						Size_B_Tmp=$Size_Tmp
						check_calc_suffix GB MB
						## }}}
						# nach MByte umrechnen# {{{
					elif [[ "$Size" -ge 1000000 ]] ; then
						(( Size_B_Tmp = Size/1000000.0 ))
						Size_Tmp=$Size_Tmp
						check_calc_suffix MB KB
						## }}}
						# nach KByte umrechnen# {{{
					elif [[ "$Size" -ge 1000 ]] ; then
						(( Size_Tmp = Size/1000.0 ))
						Size_B_Tmp=$Size_Tmp
						check_calc_suffix KB B
						## }}}
					else
						SIZE_B="${Size}B"
					fi
					## }}}
					;;
				*)
					# SI-Prefix Dezimal verwenden 1Megabyte = 1000Kilobyte# {{{
					unset -- SIZE_B
					local Size Size_B_Tmp Opt
					Opt="$1"
					Size="${2//,/.}"
					case "$Opt" in
						kb|KB|Kb)	#  KiloByte nach Byte umrechnen
							# 10hoch3 1KB=1.000Byte# {{{
							(( Size_B_Tmp = Size * 1000 ))
							SIZE_B="$Size_B_Tmp:r"
							## }}}
							;;
						mb|MB|Mb)	# nach Byte umrechnen
							# 10hoch6 1MB=1.000.000Byte# {{{
							(( SIZE_B = Size * 1000000 ))
							## }}}
							;;
						gb|GB|Gb)	# nach Byte umrechnen
							# 10hoch9 1GB=1.000.000.000Byte# {{{
							(( SIZE_B = Size * 1000000000 ))
							## }}}
							;;
						tb|TB|Tb)	# nach Byte umrechnen
							# 10hoch12 1MB=1.000.000.000.000Byte# {{{
							(( SIZE_B = Size * 1000000000000 ))
							## }}}
							;;
						pb|PB|Pb)	# nach Byte umrechnen
							# 10hoch15 1MB=1.000.000.000.000.000Byte# {{{
							(( SIZE_B = Size * 1000000000000000 ))
							## }}}
							;;
						eb|EB|Eb)	# nach Byte umrechnen
							# 10hoch18 1MB=1.000.000.000.000.000.000Byte# {{{
							(( SIZE_B = Size * 1000000000000000000 ))
							## }}}
							;;
#						zb|ZB|Zb)	# nach Byte umrechnen
#							# 10hoch21 1MB=1.000.000.000.000.000.000.000Byte# {{{
#							(( SIZE_B = Size * 1000000000000000000000 ))
#							## }}}
#							;;
#						yb|YB|Yb)	# nach Byte umrechnen
#							# 10hoch24 1MB=1.000.000.000.000.000.000.000.000Byte# {{{
#							(( SIZE_B = Size * 1000000000000000000000000 ))
#							## }}}
#							;;
						*)	# ist schon Byte
							SIZE_B="$Size:r"
							;;
					esac
					## }}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (convert_over_size), Groessen in eine lesbarere Form umrechnen{{{
	#
	# usage: convert_over_size BIG_SIZE IS_SIZE
	# BIG_SIZE - Groesse die IS_SIZE ueberschreitet
	# IS_SIZE - Groesse die nicht ueberschritten werden darf
	#
	convert_over_size() {
		if [[ ${#argv} == 2 ]] ; then
			unset -- IS_SIZE DATA_SIZE
			convert_drive_size -i "$1"
			DATA_SIZE="${SIZE_B}${SIZE_B_ME}"
			convert_drive_size -i "$2"
			IS_SIZE="${SIZE_B}${SIZE_B_ME}"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (count_char_to_line), zum zaehlen der Zeichen damit die# {{{
	# Groesse des dialog fensters (z.B) angepasst werden kann.
	#
	# usage: count_char_to_line TEXT
	# TEXT - Text der in Zeilen zur Spaltengroesse umgerechnet werden sollen
	#
	count_char_to_line() {
		unset -- gv_LineAnz
		if [ "$#" = 1 ] ; then
			echo -n "$1" | fold -s -w $[COLUMNS-12] > ${gv_WorkDir}/lines$$
			gv_LineAnz=$(wc -l < ${gv_WorkDir}/lines$$)
			rm -f${gv_WorkDir}/lines$$ &>/dev/null
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (count_display_col), Berechnung der Fenstergroesse, Spalten# {{{
	#
	# usage: count_display_col "$ANZEIGEWERTE"
	#
	count_display_col() {
		setopt localoptions shwordsplit
		if [ "$#" -ge 1 ] ; then
			unset -- DisplayCol1 DisplayCol
			local DisplayCol1 DisplayCol
			IFSBAK="$IFS"
			IFS=$'"\n'
			for i in $@ ; {
				Anz="${#i[@]}"
				if [ "$Anz" -gt "$COLUMNS" ] ; then
					(( DisplayCol1 = COLUMNS - 8 ))
				else
					if [ -n "$DisplayCol" ] ; then
						if [ "$DisplayCol" -lt "$Anz" ] ; then
							DisplayCol="$Anz"
						fi
					else
						DisplayCol="$Anz"
					fi
				fi
			}
			if [ -n "$DisplayCol1" ] ; then
				DisplayColumns="$DisplayCol1"
			else
				(( DisplayCol = DisplayCol + 35 ))
				if [ "$DisplayCol" -lt "$COLUMNS" ] ; then
					(( DisplayColumns = DisplayCol ))
				else
					(( DisplayColumns = COLUMNS - 8 ))
				fi
			fi
		else
			no_para_msg $0
		fi
		IFS="$IFSBAK"
	}
	## }}}
 	# Funktion (count_display_line), Berechnung der Fenstergroesse, Zeilen# {{{
	#
	# usage: count_display_line [ -f | -l | -m | -o ] OVERHEAD VAR
	# -f - Form Dialogboxen (form, mixedform)
	# -l - list, Dialogboxen, die den uebergebenen Text in Zeilen umrechnet
	# -m - Dialogboxen, die eine Auswahl bieten (radiolist, checklist)
	# -o - fuer die Dialogbox menubox
	# - - alle anderen Dialogboxen.
	# OVERHEAD - Zeilengroesse die zur normalen Groesse dazu addiert wird.
	# VAR -  Variable die die uebergebenen Darstellungswerte zur Berechnung beinhaltet.
	#
	count_display_line() {
		unset -- Elemente Overhead
		if [ "$#" -ge 2 ] ; then
			# Groesse des Fensters berechnen.
			case "$1" in
				-f)
					Overhead="$2"
					(( Elemente=+${(w)#3} ))
					(( Elemente = Elemente/9+1 ))
					if [ "$[Elemente+Overhead]" -lt "$[LINES-4]" ]; then
					    (( DisplayLines = Elemente+Overhead ))
					else
						(( DisplayLines = LINES-6 ))
						(( Elemente = DisplayLines-8 ))
					fi
					;;
				-o)
					Overhead="$2"
					(( Elemente=+${(w)#3} ))
					(( Elemente = Elemente/2+1 ))
					if [ "$[Elemente+Overhead]" -lt "$[LINES-4]" ]; then
					    (( DisplayLines = Elemente+Overhead ))
					else
						(( DisplayLines = LINES-6 ))
						(( Elemente = DisplayLines-8 ))
					fi
					;;
				-m)
					Overhead="$2"
					(( Elemente=+${(w)#3} ))
					(( Elemente = Elemente/3+1 ))
					if [ "$[Elemente+Overhead]" -lt "$[LINES-4]" ]; then
					    (( DisplayLines = Elemente+Overhead ))
					else
						(( DisplayLines = LINES-6 ))
						(( Elemente = DisplayLines-8 ))
					fi
					;;
				-l)
			        # Berechnung der uebergebenen Zeichen der Nachricht und
			        # dementsprechend die Zeilengroesse einstellen.
					Overhead="$2"
			        count_char_to_line "$3"
					if [ "$[gv_LineAnz+Overhead]" -lt "$[LINES-4]" ]; then
					    (( DisplayLines = gv_LineAnz+Overhead ))
					else
			            DisplayLines="$Overhead"
					fi
					;;
				*)
					Overhead="$1"
					Elemente="$2"
					if [ "$[Elemente+Overhead]" -lt "$[LINES-4]" ] ; then
					    (( DisplayLines = Elemente+Overhead ))
					else
						(( DisplayLines = LINES-6 ))
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (count_title_string), berechnet die Laenge des Titel# {{{
	# der angezeigt werden kann und ersetzt bei Ueberlaenge einen
	# Teil durch 3 Punkte
	#
	count_title_string() {
		if [ "${#argv}" -eq 2 ] ; then
			Title="$1"
			DisplayCol="$2"
			T_String="${gv_ScriptName}::${Title}"
			T_Char=${#T_String}
			if [ $DisplayCol -le $T_Char ] ; then
				(( Anz = DisplayCol / 2 - 4 ))
				(( Anz1 = T_Char - Anz ))
				T_String[Anz,Anz1]="..."
			fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (create_file), erstellt Dateien und Verzeichnisse{{{
	#
	# erstellt Dateien/Verzeichnisse falls sie noch nicht vorhanden sind.
	# Variable = Datei- oder Verzeichnisname.
	#
	# usage: create_file [ -d (Verzeichnisse) $Variable | $Variable (Dateien) ]
	create_file() {
		if [ $# -ge 1 ] ; then
			case $1 in
				-d)	# Verzeichnisse erzeugen
					#
					# Positionsvariablen, um den Parameter -d verschieben.
					shift
					for i in $@ ; {
						if [ ! -d "`print ${i/\~/\$HOME}`" ] ; then
							prog_exec mkdir "-p ${i/\~/\$HOME}"
						fi
					}
					;;
				*)	# Dateien erzeugen
					for i in $@ ; {
						if [ ! -f "`print ${i/\~/\$HOME}`" ] ; then
							prog_exec touch ${i/\~/\$HOME}
						fi
					}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (crontbconf), zur Einstellung der crontab Tabelle der User{{{
	#
	# usage: crontbconf [ -s $USER ] $CRONTAB_SCRIPT
	# -s $USER - Sudo Einstellungen fuer $USER taetigen.
	# CRONTAB_SCRIPT - Srciptname welches ausgefuehrt werden soll.
	crontbconf() {
		if [[ ${#argv} -ge 1 ]] ; then
			#
			# Variablen
			lv_Extra_Char=$(gettext 'Sonderzeichen')
			lv_Program=$(gettext 'Programm')
			lv_Minute=$(gettext 'Minute')
			lv_Hour=$(gettext 'Stunde')
			lv_Dom=$(gettext 'Monatstag')
			lv_Mon=$(gettext 'Monat')
			lv_Dow=$(gettext 'Wochentag')
			#
			# Die ersten 5 Zeichen, fuers loeschen
			CRONTAB_CHARS=(MIN STD DOM MON DOW)
			#
			# Funktion cron_main_menu{{{
			#
			cron_main_menu() {
				TITLE=$(gettext 'crontab::Ausfuehrungszeit')
				MSG=$(gettext 'Veraendern Sie hier die Ausfuehrungszeit.')
				MENU=($lv_Program \"$Prog_Wahl\" ------------ \"\"
					$lv_Extra_Char \"$EXTRA_CHAR\" $lv_Minute \"$MIN\" $lv_Hour \"$STD\"
					$lv_Dom \"$DOM\" $lv_Mon \"$MON\" $lv_Dow \"$DOW\"
					$gv_Save \"\" $gv_Delete \"\" $gv_Back \"\")
				menubox "$1" "$TITLE" "$MSG" "$MENU"
			}
			#}}}
			# Funktion, bestehende Ausfuehrungszeit herausfinden{{{
			check_time() {
				unset -- MIN STD DOM MON DOW
				crontab -u $USER -l > $Cron_File
				print ${${(s: :)${(R)${(M)"${(f)$(< $Cron_File)}"##*$Prog_Wahl*}##(#s)\#}}[1,5]} | \
					while read Min Std DoM Mon DoW ; do
						# Minuten berechnen, Sonderzeichen# {{{
						if [ -n "$Min" ] ; then
							case "$Min" in
								0-59/*)
									# Minuten Bereiche berechnen# {{{
									Anz=0
									Anz1=0
									Min_Repeat_Nr="${Min##*/}"
									while [ "$Anz1" -le 59 ] ; do
										(( Anz++ ))
										Min_Repeat[Anz]="$Anz1"
										(( Anz1 = Anz1+Min_Repeat_Nr ))
									done
									MIN="${Min_Repeat// /,}"
									## }}}
									;;
								@hourly)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								@daily|@midnight)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								@weekly)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								@monthly)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								@yearly|@annually)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								@reboot)
									# Sonderoptionen berechnen
									EXTRA_CHAR="$Min"
									;;
								*-*,*-*)
									# Minuten Bereiche berechnen# {{{
									Anz=1
									for i in ${Min//,/ } ; {
										First_Nr="${i%-*}"
										Last_Nr="${i#*-}"
										while [ "$First_Nr" -le "$Last_Nr" ] ; do
											Min_Repeat[Anz]="$First_Nr"
											(( First_Nr++ ))
											(( Anz++ ))
										done
									}
									MIN="${Min_Repeat// /,}"
									## }}}
									;;
								*,*)
									# Minuten Aufzaehlungen zusammenzaehlen# {{{
									Anz=0
									for i in ${Min//,/ } ; {
										(( Anz++ ))
										Min_Repeat[Anz]="$i"
									}
									MIN="${Min_Repeat// /,}"
									## }}}
									;;
								[0-9]|[0-5][0-9])	MIN="$Min"
									;;
							esac
						fi
						## }}}
						# Stunde berechnen# {{{
						if [ -n "$Std" ] ; then
							case "$Std" in
								0-23/*)
									# Stunden Bereiche berechnen# {{{
									Anz=0
									Anz1=0
									Std_Repeat_Nr="${Std##*/}"
									while [ "$Anz1" -le 23 ] ; do
										(( Anz++ ))
										Std_Repeat[Anz]="$Anz1"
										(( Anz1 = Anz1+Std_Repeat_Nr ))
									done
									STD="${Std_Repeat// /,}"
									## }}}
									;;
								*-*,*-*)
									# Stunden Bereiche berechnen# {{{
									Anz=1
									for i in ${Std//,/ } ; {
										First_Nr="${i%-*}"
										Last_Nr="${i#*-}"
										while [ "$First_Nr" -le "$Last_Nr" ] ; do
											Std_Repeat[Anz]="$First_Nr"
											(( First_Nr++ ))
											(( Anz++ ))
										done
									}
									STD="${Std_Repeat// /,}"
									## }}}
									;;
								*,*)
									# Stunden Aufzaehlungen zusammenzaehlen# {{{
									Anz=0
									for i in ${Std//,/ } ; {
										(( Anz++ ))
										Std_Repeat[Anz]="$i"
									}
									STD="${Std_Repeat// /,}"
									## }}}
									;;
								[0-9]|[1-2][0-9])	STD="$Std"
									;;
							esac
						fi
						## }}}
						# Tage des Monats berechnen# {{{
						if [ -n "$DoM" ] ; then
							case "$DoM" in
								1-31/*)
									# Monatstag Bereiche berechnen# {{{
									Anz=0
									Anz1=1
									DoM_Repeat_Nr="${DoM##*/}"
									while [ "$Anz1" -le 31 ] ; do
										(( Anz++ ))
										DoM_Repeat[Anz]="$Anz1"
										(( Anz1 = Anz1+DoM_Repeat_Nr ))
									done
									DOM="${DoM_Repeat// /,}"
									## }}}
									;;
								*-*,*-*)
									# Monatstag Bereiche berechnen# {{{
									Anz=1
									for i in ${DoM//,/ } ; {
										First_Nr="${i%-*}"
										Last_Nr="${i#*-}"
										while [ "$First_Nr" -le "$Last_Nr" ] ; do
											DoM_Repeat[Anz]="$First_Nr"
											(( First_Nr++ ))
											(( Anz++ ))
										done
									}
									DOM="${DoM_Repeat// /,}"
									## }}}
									;;
								*,*)
									# Monatstag Aufzaehlungen zusammenzaehlen# {{{
									Anz=0
									for i in ${DoM//,/ } ; {
										(( Anz++ ))
										DoM_Repeat[Anz]="$i"
									}
									DOM="${DoM_Repeat// /,}"
									## }}}
									;;
								[1-9]|[1-3][0-9])	DOM="$DoM"
									;;
							esac
						fi
						## }}}
						# Monat berechnen# {{{
						if [ -n "$Mon" ] ; then
							case "$Mon" in
								1-12/*)
									# Monats Bereiche berechnen# {{{
									Anz=0
									Anz1=1
									Mon_Repeat_Nr="${Mon##*/}"
									while [ "$Anz1" -le 12 ] ; do
										(( Anz++ ))
										Mon_Repeat[Anz]="$Anz1"
										(( Anz1 = Anz1+Mon_Repeat_Nr ))
									done
									MON="${Mon_Repeat// /,}"
									## }}}
									;;
								*-*,*-*)
									# Monats Bereiche berechnen# {{{
									Anz=1
									for i in ${Mon//,/ } ; {
										First_Nr="${i%-*}"
										Last_Nr="${i#*-}"
										while [ "$First_Nr" -le "$Last_Nr" ] ; do
											Mon_Repeat[Anz]="$First_Nr"
											(( First_Nr++ ))
											(( Anz++ ))
										done
									}
									MON="${Mon_Repeat// /,}"
									## }}}
									;;
								*,*)
									# Monats Aufzaehlungen zusammenzaehlen# {{{
									Anz=0
									for i in ${Mon//,/ } ; {
										(( Anz++ ))
										Mon_Repeat[Anz]="$i"
									}
									MON="${Mon_Repeat// /,}"
									## }}}
									;;
								[1-9]|[1][0-2])	MON="$Mon"
									;;
							esac
						fi
						## }}}
						# Tag der Woche berechnen# {{{
						if [ -n "$DoW" ] ; then
							case "$DoW" in
								0-7/*)
									# Tag der Woche - Bereiche berechnen# {{{
									Anz=0
									Anz1=1
									DoW_Repeat_Nr="${DoW##*/}"
									while [ "$Anz1" -le 7 ] ; do
										(( Anz++ ))
										DoW_Repeat[Anz]="$Anz1"
										(( Anz1 = Anz1+DoW_Repeat_Nr ))
									done
									DOW="${DoW_Repeat// /,}"
									## }}}
									;;
								[0-7]-[0-7],[0-7]-[0-7]*)
									# Tage der Woche - Bereiche berechnen# {{{
									Anz=1
									for i in ${DoW//,/ } ; {
										First_Nr="${i%-*}"
										Last_Nr="${i#*-}"
										while [ "$First_Nr" -le "$Last_Nr" ] ; do
											DoW_Repeat[Anz]="$First_Nr"
											(( First_Nr++ ))
											(( Anz++ ))
										done
									}
									DOW="${DoW_Repeat// /,}"
									## }}}
									;;
								[0-7],[0-7]*)
									# Tage der Woche - Aufzaehlungen zusammenzaehlen# {{{
									Anz=0
									for i in ${DoW//,/ } ; {
										(( Anz++ ))
										DoW_Repeat[Anz]="$i"
									}
									DOW="${DoW_Repeat// /,}"
									## }}}
									;;
								[0-7])	DOW="$DoW"
									;;
							esac
						fi
						## }}}
					done
			}
			#}}}
			# Funktion main_func{{{
			main_func() {
			cron_main_menu
			while [ "$gv_Auswahl" ] ; do
				case $gv_Auswahl in
					HELP*)
			    	    # Hilfe Messagebox
						#
						script_help share/cron_help
						cron_main_menu "${gv_Auswahl#HELP }"
						;;
					$lv_Program|-*)
						# Programmauswahl kann man nicht aendern
						cron_main_menu "$gv_Auswahl"
						;;
					$lv_Extra_Char)
						# Sonderzeichen# {{{
						EXTRA_MENU=(@reboot \"\" @hourly \"\" @daily \"\" @weekly \"\"
						@monthly \"\" @yearly \"\")
						menubox "$EXTRA_CHAR" "$TITLE" "$gv_Menupoint" "$EXTRA_MENU"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)
									script_help share/cron_help
									menubox "${gv_Auswahl#HELP }" "$TITLE" "$gv_Menupoint" "$EXTRA_MENU"
									;;
								*)
									# Auswahl übernehmen
									EXTRA_CHAR="$gv_Auswahl"
									unset -- $CRONTAB_CHARS
									break
									;;
							esac
						done
						## }}}
						cron_main_menu $lv_Extra_Char
						;;
					$lv_Minute)
						# Minutenauswahl# {{{
						CRON_MIN_MSG=$(gettext 'Waehlen Sie bitte die Minuten aus.')
						# vorherige Werte mit "on" belegen, fuer die Funktion checklist.
						generate_is_file "${MIN//,/ }"
						is_value "`print {0..59}`"
						#
						U_OPT=ok
						checklist "${DEFAULT_VALUE[1]}" "$CRON_TITLE" "$CRON_MIN_MSG" "$VALUE_ARRAY"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)	script_help share/cron_help
									U_OPT=ok
									checklist "${gv_Auswahl#HELP }" "$CRON_TITLE" "$CRON_MIN_MSG" "$VALUE_ARRAY"
									;;
								*)
									MIN="$gv_Auswahl"
									unset -- EXTRA_CHAR
									break
									;;
							esac
						done
						# check von $gv_Auswahl, falls leer wird Variable auch geloescht.
						check_gv_Auswahl MIN
						## }}}
						cron_main_menu $lv_Minute
						;;
					$lv_Hour)
						# Stundenauswahl# {{{
						CRON_STD_MSG=$(gettext 'Waehlen Sie bitte die Stunden aus.')
						# vorherige Werte mit "on" belegen, fuer die Funktion checklist.
						generate_is_file "${STD//,/ }"
						is_value "`print {0..23}`"
						#
						U_OPT=ok
						checklist "${DEFAULT_VALUE[1]}" "$CRON_TITLE" "$CRON_STD_MSG" "$VALUE_ARRAY"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)	script_help share/cron_help
									U_OPT=ok
									checklist "${gv_Auswahl#HELP }" "$CRON_TITLE" "$CRON_STD_MSG" "$VALUE_ARRAY"
									;;
								*)
									STD="$gv_Auswahl"
									unset -- EXTRA_CHAR
									break
									;;
							esac
						done
						# check von $gv_Auswahl, falls leer wird Variable auch geloescht.
						check_gv_Auswahl STD
						## }}}
						cron_main_menu $lv_Hour
						;;
					$lv_Dom)
						# Monatstagsauswahl# {{{
						CRON_DOM_MSG=$(gettext 'Waehlen Sie bitte die Monatstage aus.')
						# vorherige Werte mit "on" belegen, fuer die Funktion checklist.
						generate_is_file "${DOM//,/ }"
						is_value "`print {1..31}`"
						#
						U_OPT=ok
						checklist "${DEFAULT_VALUE[1]}" "$CRON_TITLE" "$CRON_DOM_MSG" "$VALUE_ARRAY"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)	script_help share/cron_help
									U_OPT=ok
									checklist "${gv_Auswahl#HELP }" "$CRON_TITLE" "$CRON_DOM_MSG" "$VALUE_ARRAY"
									;;
								*)
									DOM="$gv_Auswahl"
									unset -- EXTRA_CHAR
									break
									;;
							esac
						done
						# check von $gv_Auswahl, falls leer wird Variable auch geloescht.
						check_gv_Auswahl DOM
						## }}}
						cron_main_menu $lv_Dom
						;;
					$lv_Mon)
						# Monatsauswahl# {{{
						CRON_MON_MSG=$(gettext 'Waehlen Sie bitte die Monate aus.')
						# vorherige Werte mit "on" belegen, fuer die Funktion checklist.
						generate_is_file "${MON//,/ }"
						is_value "`print {1..12}`"
						#
						U_OPT=ok
						checklist "${DEFAULT_VALUE[1]}" "$CRON_TITLE" "$CRON_MON_MSG" "$VALUE_ARRAY"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)	script_help share/cron_help
									U_OPT=ok
									checklist "${gv_Auswahl#HELP }" "$CRON_TITLE" "$CRON_MON_MSG" "$VALUE_ARRAY"
									;;
								*)
									MON="$gv_Auswahl"
									unset -- EXTRA_CHAR
									break
									;;
							esac
						done
						# check von $gv_Auswahl, falls leer wird Variable auch geloescht.
						check_gv_Auswahl MON
						## }}}
						cron_main_menu $lv_Mon
						;;
					$lv_Dow)
						# Tag der Woche - Auswahl# {{{
						CRON_DOW_MSG=$(gettext 'Waehlen Sie bitte die Wochentage aus.')
						# vorherige Werte mit "on" belegen, fuer die Funktion checklist.
						generate_is_file "${DOW//,/ }"
						is_value "`print {0..7}`"
						#
						U_OPT=ok
						checklist "${DEFAULT_VALUE[1]}" "$CRON_TITLE" "$CRON_DOW_MSG" "$VALUE_ARRAY"
						while [ -n "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)	script_help share/cron_help
									U_OPT=ok
									checklist "${gv_Auswahl#HELP }" "$CRON_TITLE" "$CRON_DOW_MSG" "$VALUE_ARRAY"
									;;
								*)
									DOW="$gv_Auswahl"
									unset -- EXTRA_CHAR
									break
									;;
							esac
						done
						# check von $gv_Auswahl, falls leer wird Variable auch geloescht.
						check_gv_Auswahl DOW
						## }}}
						cron_main_menu $lv_Dow
						;;
					$gv_Save)
						# speichern der Einstellungen{{{
						#
						if [ -n "$EXTRA_CHAR" ] ; then
							TIME="$EXTRA_CHAR"
						else
							if [ -n "$MIN" ] ; then
								MIN_TIME="$MIN"
							else
								MIN_TIME="*"
							fi
							if [ -n "$STD" ] ; then
								STD_TIME="$STD"
							else
								STD_TIME="*"
							fi
							if [ -n "$DOM" ] ; then
								DOM_TIME="$DOM"
							else
								DOM_TIME="*" 
							fi
							if [ -n "$MON" ] ; then
								MON_TIME="$MON"
							else
								MON_TIME="*"
							fi
							if [ -n "$DOW" ] ; then
								DOW_TIME="$DOW"
							else
								DOW_TIME="*"
							fi
							# Zeit zusammen rechnen
							TIME="$MIN_TIME $STD_TIME $DOM_TIME $MON_TIME $DOW_TIME"
						fi
						#
						if [ -f "$Cron_File" ] ; then
							Prog_Wahl_X="${commands[$Prog_Wahl]}"
							IST=${(M)"${(qf)$(< $Cron_File)}"##*${Prog_Wahl}*}
							if [ "$IST" ] ; then
								print -l ${${(R)"${(qf)$(< $Cron_File)}"##*${Prog_Wahl}*}//\'\'/ } >${Cron_File}$$
								>> $Cron_File$$ <<< "$TIME test -x $Prog_Wahl_X && $Sudo $Prog_Wahl_X" 
								crontab -u $USER $Cron_File$$
							else
								>> $Cron_File <<< "$TIME test -x $Prog_Wahl_X && $Sudo $Prog_Wahl_X" 
								crontab -u $USER $Cron_File
							fi
						else	
							Prog_Wahl_X="${commands[$Prog_Wahl]}"
							> $Cron_File <<< "SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
#
# m h dom mon dow command
MAILTO="$USER"
$TIME test -x $Prog_Wahl_X && $Sudo $Prog_Wahl_X" 
							crontab -u $USER $Cron_File
						fi
						break
						#}}}
						;;
					$gv_Delete)	
						# loeschen von Eintraegen# {{{
						if [ -f "$Cron_File" ] ; then
							print -l ${${(R)"${(qf)$(< $Cron_File)}"##*${Prog_Wahl}*}//\'\'/ } >${Cron_File}$$
							crontab -u $USER ${Cron_File}$$
							unset -- $CRONTAB_CHARS EXTRA_CHAR
						fi
						## }}}
						break
						;;
					$gv_Back)	break
						;;
				esac
			done
			}
			#}}}
			#
			# Variablen lokal definieren
			local Cron_File Prog_Wahl Prog_Wahl_X Zeit Sudo
			# Funktionen registrieren
			autoload -U cron_atime
			# Variablen
			Cron_File="${gv_WorkDir}/crontab"
			case "$1" in
				-s)	Sudo=sudo
					# User veraendern
					if [ -n "$3" ] ; then
						if [[ -x ${commands[$3]} ]] ; then
							Prog_Wahl="$3"
							USER="$2"
							check_time
							main_func
						else
							no_prog_exec_msg "$3"
						fi
					else
						no_para_msg $0
					fi
					;;
				*)
					if [ -n "$1" ] ; then
						if [[ -x ${commands[$1]} ]] ; then
							Prog_Wahl="$1"
							check_time
							main_func
						else
							no_prog_exec_msg "$1"
						fi
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (dd_gauge), Fortschrittsanzeige fuer das Programm dd# {{{
	#
	# usage: dd_gauge DD_CMD DST_SIZE GAUGE_MSG
	# 
	# DD_CMD - Kompletter dd Befehl, koennen ja nebenbai noch andere dd
	#          Prozesse laufen.
	# DST_SIZE - gesamte Groesse des Laufwerks
	# GAUGE_MSG - Nachricht die angezeigt werden soll.
	#
	dd_gauge() {
		if [[ ${#argv} == 3 ]] ; then
			local Full_Size File_Size Dd_Pid Dd_Cmd TITLE
			TITLE="diskdump"
			Dd_Cmd="$1"
			Full_Size="$2"
			GAUGE_MSG="$3"
			Dd_Pid="`print ${${(ws: :)${(M)${(f)"$(ps ax)"}##*${Dd_Cmd}*}}[1]}`"
			# DD_LOG mit Daten fuellen
			File_Size=$(kill -USR1 $Dd_Pid ; print ${${(ws: :)$(tail -1 $gv_LogFile)}[1]})
			(( PERCENT = ${File_Size}00 / Full_Size ))
			if [ -n "$PERCENT" ] ; then
				while [ -n "$PERCENT" -a "$PERCENT" -lt 100 ] ; do
					print "$PERCENT" | gauge "$TITLE" "$GAUGE_MSG" ; Dd_Pid="`print ${${(ws: :)${(M)${(f)"$(ps ax)"}##*${Dd_Cmd}*}}[1]}`" ; if [ ! -z "$Dd_Pid" ] ; then ; File_Size=$(kill -USR1 $Dd_Pid ; print ${${(ws: :)$(tail -1 $gv_LogFile)}[1]}) ; (( PERCENT = ${File_Size}00 / Full_Size )) ; sleep 1 ; else ; break ; fi
				done
			fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (device_convert), Umrechnung von bis zu 10 CDRom Laufwerken{{{
	#
	# Es konvertiert 10 CD Laufwerke um.
	#
	# NOTIZ: Zur Zeit werden nur cdrom Laufwerke unterstuetzt.
	#
	# usage: device_convert [ -i ] DEVICE
	# -i - umgekehrtes konvertieren.
	# DEVICE - Variable mit dem Geraet 0,1,0 (SCSI).
	# bei keiner Option muss DEVICE volgendes enthalten:
	# DEVICE - kann /dev/scd* (SCSI) /dev/hd[a-z] (IDE) sein.
	#
	device_convert() {
		local s c t l v M Rest Anz
		unset -- Anz CDROM DESC
		integer Anz
		# Funktion scsi_convert{{{
		scsi_convert() {
			unset -- s c t l v M Rest
			Anz=$1
			if [ ! -f ${gv_WorkDir}/scsi-cd ] ; then
				grep -B2 CD-ROM /proc/scsi/scsi | grep Host: >${gv_WorkDir}/scsi-cd
			fi
			if [ ! -f ${gv_WorkDir}/scsi-desc ] ; then
				grep -B2 CD-ROM /proc/scsi/scsi | grep Vendor: >${gv_WorkDir}/scsi-desc
			fi
			#
			print ${(M)$(sed -n -e "${Anz}p" ${gv_WorkDir}/scsi-cd)##(scsi[0-9]|[0-9][0-9])} | \
			while read s c t l ; do
				# SCSIbus
				S="${s#scsi}"
				# Target
				if [ "${t[1]}" = 0 ] ; then
					T="${t[2]}"
				else
					T="$t"
				fi
				# Lun
				if [ "${l[1]}" = 0 ] ; then
					L="${l[2]}"
				else
					L="$l"
				fi
			done
			#
			print ${${(s: :)$(sed -n -e "${Anz}p" ${gv_WorkDir}/scsi-desc)}[2,5]} | \
			while read v M Rest ; do
				DESC="$v Rest"
			done
			CDROM="${S},${T},${L}"
		}
		#}}}
		if [ $# -ge 1 ] ; then
			case "$1" in
				-i)
					if [ -n "$2" ] ; then
						DEVICE="$2"
						# Das bus,target,lun Geraet wird in dem Array CD_DEV herraus gesucht.
						Anz=0
						for n in $STL_CD_DEV ; {
							(( Anz++ ))
							if [ "$n" = "$DEVICE" ] ; then
								CDROM=${CD_DEV[Anz]}
								break
							fi
						}
					else
						no_para_msg $0
					fi
					;;
				*)
					# SCSI/ATAPI CD/DVD Devices konvertieren in Target,Bus,Lun {{{
					DEV="$1"
					case $DEV in
						*hda)
							# ATAPI CD{{{
							CDROM="ATA:0,0,0"
							;;
						*hdb)
							CDROM="ATA:0,1,0"
							;;
						*hdc)
							CDROM="ATA:1,0,0"
							;;
						*hdd)
							CDROM="ATA:1,1,0"
							;;
						*hde)
							CDROM="ATA:2,0,0"
							;;
						*hdf)
							CDROM="ATA:2,1,0"
							;;
						*hdg)
							CDROM="ATA:3,0,0"
							;;
						*hdh)
							CDROM="ATA:3,1,0"
							;;
						*hdi)
							CDROM="ATA:4,0,0"
							;;
						*hdj)
							CDROM="ATA:4,1,0"
							#}}}
							;;
						*scd0)
							# SCSI Devices{{{
							scsi_convert 1
							;;
						*scd1)
							scsi_convert 2
							;;
						*scd2)
							scsi_convert 3
							;;
						*scd3)
							scsi_convert 4
							;;
						*scd4)
							scsi_convert 5
							;;
						*scd5)
							scsi_convert 6
							;;
						*scd6)
							scsi_convert 7
							;;
						*scd7)
							scsi_convert 8
							;;
						*scd8)
							scsi_convert 9
							;;
						*scd9)
							scsi_convert 10
							#}}}
							;;
						*sr[0-9])
							# generische SCSI Devices{{{
							CDROM="$DEV"
							#}}}
							;;
						*)
							hier_ist_noch_nichts "$Dev"
							;;
					esac
					#}}}
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (dialog_version){{{
	#
	# usage: dialog_version
	#
	dialog_version() {
		Dialog_Version=${${(s: :)$($Dialog --version)}[2]}
		if [[ "$Dialog_Version" < 1.1-20070227 ]] ; then
            MSG=$(gettext 'Sie benoetigen die dialog Version 1.1-20070227 oder groesser, um mit diesem Script arbeiten zu koennen.')
            msgbox "$gv_Attention" "$MSG"
            exit 0
		fi
	}
	#}}}
	# Function (dir_file_choice, veraltet), ganzes Verzeichnis oder{{{
	# nur einzelne Dateien auswaehlen
	#
	# usage: dir_file_choice Function
	# Wird nur noch vom Script kwgpgcrypt benutzt. Es werden dann entweder nur Verzeichnisse
	# oder nur Dateien angezeigt. Es muss eine Funktion uebergeben werden, die dann gestartet 
	# wird.
	#
	dir_file_choice() {
		if [ "$#" -eq 1 ] ; then
			lv_Directories=$(gettext 'Verzeichnisse')
			lv_Files=$(gettext 'Dateien')
			DIR_CHOICE_TITLE=$(gettext 'Verzeichnis- oder Dateiauswahl')
			DIR_CHOICE_MSG=($lv_Directories \"\" $lv_Files \"\")
			menubox "" "$DIR_CHOICE_TITLE" "$gv_Menupoint" "$DIR_CHOICE_MSG"
			while [ "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/data_help
						menubox "${gv_Auswahl#HELP }" "$DIR_CHOICE_TITLE" "$gv_Menupoint" "$DIR_CHOICE_MSG"
						;;
					$lv_Directories)
						# ganze Verzeichnisse auswaehlen
						#
						F_OPT="/"
						$1
						break
						;;
					$lv_Files)
						# Nur Dateien auswaehlen
						#
						F_OPT="."
						$1
						break
						;;
				esac
			done
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (dselect_check){{{
	#
	# benoetigt die Funktion yesno
	# usage: dselect_check [ -c | -v ] "$VERZ"
	# -c = create
	# -v = verify
	#
	dselect_check() {
		if [ "$#" -ge 1 ] ; then
			unset -- DIR
			case $1 in
				-c)	#
					# Solange $2 kein Verzeichnis ist, wird gefragt
					# ob dieses Verzeichnis angelegt werden soll.
					#
					DIR="$2"
					if [ ! -d "$DIR" ] ; then
						MSG=$(gettext 'Das Verzeichnis ${DIR%/} ist nicht vorhanden. Soll es angelegt werden?')
					    yesno "$gv_Attention" "$MSG" ""
						#
						# Verzeichnis anlegen?
						#
						if [ "$gv_Auswahl" = yes ] ; then
							VERZ="$DIR"
							create_file -d "$DIR" 2>/dev/null
							if [ $? != 0 ] ; then
								MSG=$(gettext 'Sie haben keine Rechte das Verzeichnis $DIR anzulegen.')
								msgbox "$gv_Attention" "$MSG"
								unset -- VERZ 
							fi
						else
							unset -- VERZ 
						fi
					else
						VERZ="$DIR"
					fi
					;;
				-v) # pruefen ob das Verzeichnis schon existiert. Wird benoetigt falls man Verzeichnisse
					# nicht mehrfach vergeben kann, wie zum Beispiel das Verzeichnis /home.
					#
					DIR="$2"
					if [ -d "$DIR" ] ; then
                        no_use_dir_msg "$DIR"
						unset -- VERZ
					else
						VERZ="$DIR"
					fi
					;;
				*)	#
					DIR="$1"
					if [ ! -d "$DIR" ] ; then
						MSG=$(gettext '$DIR ist kein Verzeichnis.')
						msgbox "$gv_Attention" "$MSG"
						unset -- VERZ
					elif [ ! -r "$DIR" ] ; then
						MSG=$(gettext 'Sie haben keine Leserechte fuer das Verzeichnis $DIR.')
						msgbox "$gv_Attention" "$MSG"
						unset -- VERZ
					else
						VERZ="$DIR"
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (edit_file)# {{{
	#
	# usage: edit_file [ TITLE ] FILE
	# TITLE - Titelname der Dialogbox editbox
	# FILE - Datei die zur bearbeitung geoeffnet werden soll
	#
	# Die Variable EDITOR kann man mit "kwadmin" konfigurieren
	# Sie beinhaltet - einen Editor oder es wird die Dialogbox
	# editbox verwendet.
	#
	edit_file() {
		unset -- EDIT_TITLE EDIT_FILE
		local EDIT_TITLE EDIT_FILE
		# Funktion exec_edit# {{{
		#
		exec_edit() {
			if [[ $EDITOR == dialog ]] ; then
				editbox "$EDIT_TITLE" "$EDIT_FILE"
			elif [[ -x ${commands[$EDITOR]} ]] ; then
				"$EDITOR" "$EDIT_FILE"
			else
				no_editor_msg
			fi
		}
		## }}}
		if [[ ${#argv} == 1 ]] ; then
			EDIT_TITLE="$gv_Configuration"
			EDIT_FILE="$1"
			exec_edit
		elif [[ ${#argv} == 2 ]] ; then
			EDIT_TITLE="$1"
			EDIT_FILE="$2"
			exec_edit
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (file_chmod), fuer die Dateirechte{{{
	#
	# benoetigt die Funktionen mask und user_group_check
	#
	# usage: file_chmod
	#
	file_chmod() {
		CHMOD_TITLE=$(gettext 'Rechteverwaltung')
		lv_Mode=$(gettext 'Mode')
		# Funktion fuer das Menue der Rechte Einstellung{{{
		#
		# usage: mode_menue
		#
		mode_menue() {
			MENU=($lv_Mode "$MOD" $gv_User "$U" $gv_Group "$G"
			$gv_Save "" $gv_Back "")
			menubox "$1" "$CHMOD_TITLE" "$gv_Menupoint" "$MENU"
		}
		#}}}
		#
		mode_menue
		while [ "$gv_Auswahl" ] ; do
			case "$gv_Auswahl" in
				HELP*)
					script_help chmod_help
					mode_menue "${gv_Auswahl#HELP }"
					;;
				$lv_Mode)
					# Datei Rechte auswaehlen{{{
					#
					mask "$MOD"
					if [ -n "$MASK" ] ; then
						MOD="$MASK"
					else
						MOD=""
					fi
					#}}}
					mode_menue $lv_Mode
					;;
				$gv_User)
					# Datei Besitzer auswaehlen{{{
					user_group_check -p
					MSG=$(gettext 'Waehlen Sie einen Benutzer aus.')
					menubox "$U" "$CHMOD_TITLE" "$MSG" "$U_G_ARRAY"
					#
					while [ "$gv_Auswahl" ] ; do
						case "$gv_Auswahl" in
							HELP*)	script_help share/user_help
								menubox "${gv_Auswahl#HELP }" "$CHMOD_TITLE" "$MSG" "$U_G_ARRAY"
								;;
							*)	# alles ok
								U="$gv_Auswahl"
								break
								;;
						esac
					done
					#}}}
					mode_menue $gv_User
					;;
				$gv_Group)
					# Gruppe auswaehlen{{{
					#
					user_group_check -g
					MSG=$(gettext 'Waehlen Sie eine Gruppe aus.')
					menubox "$G" "$CHMOD_TITLE" "$MSG" "$U_G_ARRAY"
					#
					while [ "$gv_Auswahl" ] ; do 
						case "$gv_Auswahl" in
							HELP*)	script_help share/group_help
								menubox "${gv_Auswahl#HELP }" "$CHMOD_TITLE" "$MSG" "$U_G_ARRAY"
								;;
							*)	#
								# alles ok
								#
								G="$gv_Auswahl"
								break
								;;
						esac
					done
					#}}}
					mode_menue $gv_Group
					;;
				$gv_Save)
					# nur wenn alle Variablen belegt sind wird die Konfiguration uebernommen.{{{
					#
					if [ "$MOD" -a "$U" -a "$G" ] ; then
						CHMOD=($MOD $U $G)
						break
					else
						MSG=$(gettext 'Sie muessen erst alle Menuepunkte auswaehlen und mit Werten belegen.')
						msgbox "$gv_Attention" "$MSG"
						mode_menue
					fi
					#}}}
					;;
				$gv_Back)	break
					;;
			esac
		done
	}
	#}}}
# Funktion (file_choice) um mittels file_filter{{{
# Dateien auszuwaehlen oder anzulegen.
#
# benoetigt die Variablen FORMAT (Dateiformat)
# und SUFFIX (Dateiendung, kann auch leer sein) und/oder AUSSCHLUSS.
#
# usage: file_choice VERZEICHNIS [ multi | create | only ] $VAR
#        multi - Mehrfachauswahl von Dateien.
#        create - Dateiname anlegen
#        only - Eine Datei auswaehlen
#        $VAR - vorheriger Wert
#
file_choice() {
	if [ $# -ge 2 ] ; then
		unset -- WERT VERZ
		VAR="$3"
		dselect "$1"
		if [ "$VERZ" ] ; then
			dselect_check "$VERZ"
			if [ "$VERZ" ] ; then
				cd "$VERZ"
				file_filter "$FORMAT" "$SUFFIX" "$AUSSCHLUSS"
				#
				if [ "${DF_ARRAY[1]}" ] ; then
					FILE_TITLE=$(gettext 'Dateiauswahl')
					case "$2" in 
						multi)
							FILE_MENU=($DF_ARRAY)
							FILE_MSG=$(gettext 'Waehlen Sie ein oder mehrere Dateien aus.')
							checklist "" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
							#
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	script_help share/file_help
										checklist "${gv_Auswahl#HELP }" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
										;;
									*)	# alles andere wird uebernommen und im neuen Array WERT
										# gespeichert
										set -A WERT $gv_LogFile$$
										break
										;;
								esac
							done
							;;
						create)
							#
							# Datei anlegen oder auswaehlen
							#
							FILE_MENU=($gv_Create \"\" on $DF_ARRAY)
							FILE_MSG=$(gettext 'Waehlen Sie eine Datei aus oder legen eine neue an.')
							radiolist "" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
							#
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	script_help share/file_help
										radiolist "${gv_Auswahl#HELP }" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
										;;
									$gv_Create)
										# Dateinamen vergeben
										MSG=$(gettext 'Geben Sie hier bitte einen neuen Namen fuer die Datei ein.')
										inputbox "$FILE_TITLE" "$MSG"
										#
										if [ "$gv_Auswahl" ] ; then
											WERT="$gv_Auswahl"
											create_file "$WERT"
										else
											no_input_msg
										fi
										break
										;;
									*)	# alles andere wird uebernommen und im neuen Array WERT
										# gespeichert
										set -A WERT $gv_Auswahl
										break
										;;
								esac
							done
							;;
						only)
							FILE_MENU=($DF_ARRAY)
							FILE_MSG=$(gettext 'Waehlen Sie eine Datei aus.')
							radiolist "" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
							#
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)	script_help share/file_help
										radiolist "${gv_Auswahl#HELP }" "$FILE_TITLE" "$FILE_MSG" "$FILE_MENU" "$VAR"
										;;
									*)	# alles andere wird uebernommen und im neuen Array WERT
										# gespeichert
										set -A WERT $gv_Auswahl
										break
										;;
								esac
							done
							;;
					esac
				else
					#############################################
					# TODO:
					# durch die Funktion filetype - andere Nachricht
					# allimg = keine Bilder vorhanden.
					# file --mime-type benutzen
					#############################################
					no_file_msg "$FORMAT"
				fi
			fi
		else
			no_input_msg
		fi
	else
		no_para_msg $0
	fi
}
#}}}
	# Funktion (file_filter){{{
	#
	# usage: file_filter OPTION "$FORMAT" "$SUFFIX" "$AUSCHLUSS"
	# AUSSCHLUSS ist optional, FORMAT und SUFFIX muessen belegt sein, ob leer oder
	# mit Werten.
	#
	# OPTION: -r = rekursiv, -d nur Verzeichnisse.
	# FORMAT: ASCII, MP3, siehe Funktion set_filetype.
	# SUFFIX: .mp3 oder "" (nach *Dateien suchen).
	# AUSSCHLUSS: mp3, mp3 Dateien ausnehmen.
	# AUSSCHLUSS: ZAHL, bei AUSSCHLUSS=ZAHL, Dateien die mit 
	#            einer Zahl enden ausnehmen von der Suche.
	# AUSSCHLUSS: LOG, bei AUSSCHLUSS=LOG, Logdateien die mit 
	#            eine Zahl beinhalten ausnehmen von der Suche.
	#
	# Gibt es ein $IST_FILE, wird verglichen, ob die gefundene Datei schon im $IST_FILE
	# vorgemerkt ist. Wenn ja wird die Datei mit on markiert, ansonsten mit off.
	#
	file_filter() {
		unset -- FUND DF_ARRAY DF_DIR_ARRAY DF_ARRAY_NULL DF_ARRAY_M
		if [ $# -ge 2 -o "$1" = -d ] ; then
			# Funktion (filetype), stellt die Dateitypen zur# {{{
			# Auswahl zur Verfuegung (assoziatives Array).
			#
			# usage: filetype
			#
			filetype() {
				unset -- gv_Filetype
				typeset -Ag gv_Filetype
				# Datei Typen	
				gv_Filetype=(\
					all "*"
					allimg "*image data*"
					ascii "ASCII *text*"
					avi "RIFF \(little-endian\) data*"
					data "data"
					elf "ELF*"
					gif "GIF image data*"
					gpg "PGP message*"
					gpgpub "PGP public key block"
					gzip "gzip compressed data*"
					iso "*ISO 9660 CD-ROM*"
					jpg "JPEG image data*"
					luks "LUKS encrypted file*"
					mp3 "Audio file with *MP3 *"
					mp3adts "MPEG ADTS, layer III*"
					ogg "Ogg data, Vorbis audio*"
					pls "PLS playlist text*"
					png "PNG image*"
					script "*text executable"
					sslprivkey "PEM * private key"
					sslcacert "PEM certificate"
					tar "POSIX tar archive*"
					text "*text"
					tif "TIFF image data*"
					udf "UDF filesystem data*"
					vcd	"*with CRLF line terminators*"
					wave "RIFF \(little-endian\) data, WAVE audio*"
				)
			}
			## }}}
			# Funktion (set_filetype), stellt den Dateityp ein zur# {{{
			# Auswahl fuer die Funktion file_filter.
			#
			# usage: set_filetype [ FILE_TYP ]
			#
			# FILE_TYP - Dateityp nach dem Dateien aufgelistet werden sollen.
			#
			set_filetype() {
				unset -- Filetype Opt
				typeset -ag Filetype
				# Datei Typen festlegen	
				if [ "$#" = 1 ] ; then
					Opt="$1"
					case "$Opt" in
						ASCII)
							# Ascii Dateien
							Filetype=(ascii)
							;;
						DATA)
							# Data Dateien
							Filetype=(data)
							;;
						ELF)
							# ELF binaere Dateien
							Filetype=(elf)
							;;
						GPG)
							# gpg verschluessellte Dateien
							Filetype=(gpg)
							;;
						GPGPUB)
							# gpg public key Dateien
							Filetype=(gpgpub)
							;;
						GZIP)
							# gzippte Dateien
							Filetype=(gzip)
							;;
						IMAGE)
							# Bild Dateien
							Filetype=(gif jpg png tif)
							;;
						ALL_IMAGE)
							# Bild Dateien
							Filetype=(allimg)
							;;
						ISO)
							# UDF und ISO 9660 Dateien
							Filetype=(iso udf)
							;;
						LUKS)
							# LUKS verschluesselte Dateien
							Filetype=(luks)
							;;
						MP3)
							# MP3 Dateien
							###################################
							# data gibts auch, warum auch immer
							###################################
							Filetype=(mp3 mp3adts data)
							;;
						OGG)
							# Ogg Dateien
							Filetype=(ogg)
							;;
						PLS)
							# Playlist Dateien
							Filetype=(pls)
							;;
						SCRIPT)
							# Script Dateien
							Filetype=(script)
							;;
						SSLCACERT)
							# openssl erzeugtes Zertifikat oder CA
							Filetype=(sslcacert)
							;;
						SSLPRIVKEY)
							# openssl erzeugter privater Schluessel
							Filetype=(sslprivkey)
							;;
						TAR)
							# Tar Archiv Dateien
							Filetype=(tar)
							;;
						TEXT)
							# Text Dateien
							Filetype=(text)
							;;
						VCD)
							# Video-CD Dateien
							Filetype=(vcd)
							;;
						WAVE)
							# Wav Dateien
							Filetype=(wave)
							;;
						*)
							# alle Dateien
							Filetype=(all)
							;;
					esac
				else
					# alle Dateien
					Filetype=(all)
				fi
			}
			## }}}
			# Funktion ist_file{{{
			#
			ist_file() {
				if [ -f "$IST_FILE" ] ; then
					IST=`print ${(M)${(f)"$(< $IST_FILE)"}##*"${file#./}"*}`
					if [ "$IST" -a "${file#./}" != . ] ; then
						DF_ARRAY[Anz]="${(qq)file#./} \"\" on"
					else
						DF_ARRAY[Anz]="${(qq)file#./} \"\" off"
					fi
				else
					DF_ARRAY[Anz]="${(qq)file#./} \"\" off"
				fi
			}
			#}}}
			# Funktion (create_value)# {{{
			#
			create_value() {
				for Ft in $Filetype ; {
					case "$Filetest" in
						# Array Index nicht Wert
						( ${~gv_Filetype[$Ft]} )
							ist_file
							DF_ARRAY_NULL[Anz]="${(qq)file#./}"
							DF_ARRAY_M[Anz]="${(qq)file#./} \"\""
							(( Anz++ ))
							;;
					esac
				}
			}
			## }}}
			# Dateitypen einlesen
			filetype
			case $1 in
				-r)
					# rekusive Dateisuche# {{{
					set_filetype "$2"
					Anz=1
					for i in "${(ws: :)${3}}" ; {
						for file in ./(*/)#*${i}(.N) ; { 
							if [ -f "$file" ] ; then
								if [ "$4" ] ; then
									# Ausschluss bearbeiten
									case "$4" in
										LOG)
											# Ist eine Zahl vorhanden so wird diese 
											# Datei nicht genommen, nur fuer Logdateien
											case "$file" in
												*[0-9]*)
													;;
												*)
													Filetest=$( file -b "$file" )
													create_value
													;;
											esac
											;;
										ZAHL)
											# Ist am Ende eine Zahle so wird diese 
											# Datei nicht genommen
											if [[ ${file##*.} != <->* ]] ; then
												Filetest=$( file -b "$file" )
												create_value
											fi
											;;
										*)
											# Dateien mit diesem Datei.Suffix nicht nehmen
											if [ ${file##*.} != "$4" ] ; then
												Filetest=$( file -b "$file" )
												create_value
											fi
											;;
									esac
								else
									Filetest=$( file -b "$file" )
									create_value
								fi
							fi
						}
					}
					## }}}
					;;
				-d)
					# nur Verzeichnisse suchen# {{{
					Anz=1
					ls -d * >${gv_WorkDir}/files$$
					while read file ; do
						if [ -d "$file" ] ; then
							if [ -f "$IST_FILE" ] ; then
								IST=${(M)${(f)"$(< $IST_FILE)"}##*"${file#./}"*}
								if [ "$IST" -a "${file#./}" != . ] ; then
									DF_DIR_ARRAY[Anz]="${(qq)file#./} \"\" on"
								else
									DF_DIR_ARRAY[Anz]="${(qq)file#./} \"\" off"
								fi
							else
								DF_DIR_ARRAY[Anz]="${(qq)file#./} \"\" off"
							fi
							(( Anz++ ))
						fi
					done < ${gv_WorkDir}/files$$
					## }}}
					;;
				*)	
					# alles andere# {{{
					set_filetype "$1"
					Anz=1
					for i in "${(ws: :)${2}}" ; {
						#for file in ./(*/)#*${i}(.N) ; { 
						#for file in ./*${i}(.N) ; { 
						for file in ./*${i}(N) ; { 
							if [ -f "$file" ] ; then
								if [ "$3" ] ; then
									# Ausschluss bearbeiten
									case "$3" in
										LOG)
											# Ist eine Zahl vorhanden so wird diese 
											# Datei nicht genommen, nur fuer Logdateien
											case "$file" in
												*[0-9]*)
													;;
												*)
													Filetest=$( file -b "$file" )
													create_value
													;;
											esac
											;;
										ZAHL)
											# Ist am Ende eine Zahle so wird diese 
											# Datei nicht genommen
											if [[ ${file##*.} != <->* ]] ; then
												Filetest=$( file -b "$file" )
												create_value
											fi
											;;
										*)
											# Dateien mit diesem Datei.Suffix nicht nehmen
											if [[ ${file##*.} != $3 ]] ; then
												Filetest=$( file -b "$file" )
												create_value
											fi
											;;
									esac
								else
									Filetest=$( file -b "$file" )
									create_value
								fi
							fi
						}
					}
					#}}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (fselect_check){{{
	#
	# benoetigt die Funktion yesno
	# usage: fselect_check [ -c ] "$DATEI"
	# -c = create
	#
	fselect_check() {
		if [ "$#" -ge 1 ] ; then
			unset -- File FILE
            local File Anz
            integer Anz
			case $1 in
				-c)	#
					# Solange $2 keine Datei ist, wird gefragt
					# ob diese angelegt werden soll.
					#
					File="$2"
					if [ ! -d $File ] ; then
						if [ ! -f "$File" ] ; then
							MSG=$(gettext 'Die Datei $File ist nicht vorhanden. Soll sie angelegt werden (ja/nein)?')
							# Vorschlag "yes" für die Funktion "yesno", siehe Funktion
							# "yesno".
						    yesno "$gv_Attention" "$MSG" ""
							#
							# Datei anlegen?
							#
							if [ "$gv_Auswahl" = yes ] ; then
								FILE="$File"
								create_file "$FILE" 2>/dev/null
								if [ $? != 0 ] ; then
									MSG=$(gettext 'Sie haben keine Rechte die Datei $FILE anzulegen.')
									msgbox "$gv_Attention" "$MSG"
									unset -- FILE
								fi
							else
								unset -- FILE
							fi
						else
							FILE="$File"
						fi
					else
						is_dir_msg "$File"
					fi
					;;
				*)	# hier kann man auch mehrere Dateien ueber regulaere
                    # Ausdruecke ueberpruefen
					File="$1"
                    setopt globsubst
                    Anz=0
                    for i in $File ; {
                        # erst pruefen ob es ein Verzeichniss ist und wenn dann auslassen
                        if [ -d "$i" ] ; then
                            continue
						elif [ ! -f "$i" ] ; then
                            # Wenn es keine Datei ist gibts ne Fehlermeldung.
                            unsetopt globsubst
							MSG=$(gettext 'Die Datei $i ist nicht vorhanden.')
							msgbox "$gv_Attention" "$MSG"
						else
                            # Dateien aufzaehlen
                            (( Anz++ ))
							FILE[Anz]="$i"
						fi
                    }
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (generate_is_file){{{
	# gv_IsValue_File wird von der Funktion file_filter benoetigt.
	# Dient zum Vergleich was schon vorher ausgewaehlt wurde
	# und dann mit "on" gekennzeichnet wird.
	#
	# usage: generate_is_file WERT [SUFFIX]
	# WERT - vorherige Werte
	# SUFFIX - optional z.B. Dateinamen Suffix
	#
	generate_is_file() {
		if [ "$#" -ge 1 ] ; then
			gv_IsValue_File="$gv_LogFile"
			rm -rf $gv_IsValue_File &>/dev/null
			for i in ${=1} ; {
				>> $gv_IsValue_File <<< "${i}${2} "
			}
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (gen_keys), generiert Passwoerter/Passphrasen{{{
	#
	# usage: gen_keys
	#
	gen_keys() {
		PASSWD_MSG=$(gettext 'Geben Sie bitte eine Zeichenkette zur Erzeugung des Passwortes ein.')
		INPUT=""
		CHAR="8"
		# Funktion (gen_key_menu){{{
		#
		lv_Charlength=$(gettext 'Zeichenlaenge')
		gen_key_menu() {
			GEN_KEY_MENU=($gv_Input \"$INPUT\" $lv_Charlength \"$CHAR\"
			$gv_Create \"\" $gv_Back \"\")
			menubox "$1" "$lv_Charlength" "$gv_Menupoint" "$GEN_KEY_MENU"
		}
		#}}}
		gen_key_menu
		while [ -n "$gv_Auswahl" ] ; do
			case "$gv_Auswahl" in
				HELP*)	script_help gen_key_help
					gen_key_menu "${gv_Auswahl#HELP }"
					;;
				$gv_Input)
					# Wort zur Erstellung eines Passworts eingeben{{{
					inputbox "$gv_Input" "$PASSWD_MSG" "$INPUT"
					if [ -n "$gv_Auswahl" ] ; then
						INPUT="$gv_Auswahl"
					else
						INPUT=""
					fi
					#}}}
					gen_key_menu "$gv_Input"
					;;
				$lv_Charlength)
					# Zeichenlaenge zur Erstellung eines Passworts eingeben{{{
					CHAR_MSG=$(gettext 'Geben Sie bitte die Laenge des zu erstellenden Passwortes an.')
					number_input "$lv_Charlength" "$PASSWD_MSG" "${CHAR:-8}"
					if [ -n "$NUMBER" ] ; then
						CHAR="$NUMBER"
					else
						CHAR="8"
					fi
					#}}}
					gen_key_menu "$lv_Charlength"
					;;
				$gv_Create)
					# Schluessel erstellen{{{
					unset -- P_PASS
					if [ -n "$CHAR" -a -n "$INPUT" ] ; then
						P_PASS="${$(openssl passwd $INPUT)[0,CHAR]}"
						unset -- INPUT
						break
					else
						MSG=$(gettext 'Sie muessen erst die Menuepunkte $gv_Input und $lv_Charlength mit Werten belegen.')
						msgbox "$gv_Attention" "$MSG"
						gen_key_menu
					fi
					#}}}
					;;
				$gv_Back)	break
					;;
			esac
		done
	}
	#}}}
	# Funktion (gpg_getkeys_id), holt die User Schluessel-ID# {{{
	# Standard_Schluessel_ID auswaehlen, mit der unterschrieben wird.# {{{
	# und stellt sie zur Auswahl
	#
	# usage: gpg_getkeys_id [ USER ]
	# USER - nach User/Name/Mailadresse schauen
	#
	gpg_getkeys_id() {
		if [[ "$#" == 1 ]] ; then
			User="$1"
		else
			User="$USER"
		fi
		#
		local Anz
		integer Anz
		Anz=1
		Gpg_Home="${gv_HomePath}/.gnupg"
		print -l ${(u)${(M)${(f)"$(gpg --homedir $Gpg_Home --list-keys "$User" 2>/dev/null)"}##(s#)pub*}} | \
		while read a Key Rest ; do
			if [ -z ${(M)${ID}##*${Key#*/}*} ] ; then
				ID[Anz]="${Key#*/} \"\""
				(( Anz++ ))
			fi
		done
		# Wurden Schluessel gefunden, werden sie zur Auswahl angeboten.
		if [ ! -z "$ID" ] ; then
			KEY_ID_TITLE=(${gv_Configuration}::${lv_Default_Keyid})
			KEY_ID_MSG=$(gettext 'Waehlen Sie die Standard Schluessel ID aus.')
			menubox "$DEFAULT_KEY" "$KEY_ID_TITLE" "$KEY_ID_MSG" "$ID"
			while [ "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/id_help
						menubox "${gv_Auswahl#HELP }" "$KEY_ID_TITLE" "$KEY_ID_MSG" "$ID"
						;;
					*)	#
						# Schluessel ID uebernehmen
						#
						DEFAULT_KEY="$gv_Auswahl"
						TRUSTED_KEY=${${(s.:.)${(u)${(M)${(f)"$(gpg --homedir $Gpg_Home --list-keys --with-colons "$User")"}##*${DEFAULT_KEY}}}}[5]}
						break
						;;
				esac
			done
		else
			MSG=$(gettext 'Es wurde kein oeffentlicher Schluessel fuer den User "$User" gefunden. Vielleicht eine falsche Konfiguration des eigenen Schluessels. Lesen Sie Bitte die Hilfe.')
			msgbox "$gv_Attention" "$MSG"
		fi
	}
	#}}}
	# Funktion (if_conf_file) um zu pruefen fuer welches OS {{{
	# die jeweilige Datei existiert,
	# und wennn ja dann einlesen
	#
	# benoetigt die Function os_check
	#
	# usage: if_conf_file "$OS" (dhcp|grub2|init|initrc|net|nisclient|ntp|proxy|raid)
	#
	if_conf_file() {
		if [ "$#" -ge 2 ] ; then
			IF_OPT="$2"
			#
	# RPM Init Sym Links erstellen/loeschen{{{
	#
	# usage: initrc_config
	initrc_config() {
		local Anz RL_Prefix Start_RC
		integer Anz
		unset -- Start_RC
		Anz=1
		if [ -f "${gv_WorkDir}/runlevconf_startstop" ] ; then
			while read Init_Script RunLevel ; do
				INIT_SCRIPT="$Init_Script"
				RUN_LEVEL="$RunLevel"
				# vorherige Links loeschen
				if [ "$Anz" = 1 ] ; then
					rm ${ETC_PATH}/rc[0-6].d/???${Init_Script} &>/dev/null
					rm -f /usr/sbin/rc${INIT_SCRIPT} &>/dev/null
					(( Anz++ ))
				fi
			done <${gv_WorkDir}/runlevconf_startstop
			rm -rf ${gv_WorkDir}/runlevconf_startstop &>/dev/null
			# Variable RUN_LEVEL auswerten
			for i in $RUN_LEVEL ; {
				case $i in
					[0-9][0-9])
						# Start/Stopnummer ermitteln
						SK_NR="$i"
						;;
					[0-9])
						# Runlevel ermitteln
						pushd ${ETC_PATH}/rc${i}.d
						ln -sf ${INITD_PREFIX}/${INIT_SCRIPT} ${RL_Prefix}${SK_NR}${INIT_SCRIPT}
						popd
						;;
					start)
						# Runlevel Prefix S (start)
						RL_Prefix=S
						Start_RC=yes
						if [ ! -L /usr/sbin/rc${INIT_SCRIPT} ] ; then
							ln -sf ${INITD_PATH}/${INIT_SCRIPT} /usr/sbin/rc${INIT_SCRIPT}
						fi
						;;
					stop)
						# Runlevel Prefix K (stop)
						RL_Prefix=K
						# Links loeschen falls nur Stop ausgewaehlt wurde.
						if [ -L /usr/sbin/rc${INIT_SCRIPT} -a -z "$Start_RC" ] ; then
							rm -f /usr/sbin/rc${INIT_SCRIPT} &>/dev/null
							break
						fi
						;;
				esac
			}
			# Prozesse starten/stoppen (init-Scripts)
			init_start_stop
		fi
	}
	#}}}
			# Funktion Prozesse starten/stoppen (init-Scripts)# {{{
			#
			init_start_stop() {
				# Prozesse starten/stoppen (init-Scripts)
				unset -- Nr RunLevelNr Start_Stop
				local Nr RunLevelNr Start_Stop
				# Runlevel Nummer herrausfinden
				RunLevelNr=${=$(runlevel)[2]}
				# Wurde fur dieses Runlevel etwas ausgewaehlt wird das
				# Init Script gestartet oder gestopt
				Nr=${${(M)${(ws: :)${RUN_LEVEL}}##${RunLevelNr}}// /}
				#Nr=${${(M)${${(s:.:)${RUN_LEVEL}}[1]}##${RunLevelNr}}[1]}
				Start_Stop=${${(M)${${(s:.:)${RUN_LEVEL}}[1]}##(start|stop)}// */}
				if [ "$Start_Stop" = start -a ! -z "$Nr" ] ; then
					${INITD_PATH}/${INIT_SCRIPT} start &>/dev/null
				elif [ "$Start_Stop" = stop -a ! -z "$Nr" ] ; then
					${INITD_PATH}/${INIT_SCRIPT} stop &>/dev/null
				else
					${INITD_PATH}/${INIT_SCRIPT} stop &>/dev/null
				fi
			}
			## }}}
			# Funktion (read_proxy), liest die Proxy Konfiguration ein# {{{
			# usage: read_proxy
			#
			read_proxy() {
			if [ -f "$PROXY_FILE" ]; then
				read_file -f "$PROXY_FILE"
				gv_Http_Proxy="$http_proxy"
				gv_Ftp_Proxy="$ftp_proxy"
			fi
			}
			## }}}
			# Funktion (rpm_ntp_conf), ntpdate Konfigurationsdatei# {{{
			# von CentOS und Fedora einlesen
			# usage: rpm_ntp_conf
			#
			rpm_ntp_conf() {
				# Fedora8, centos 5 benutzen /etc/ntp/step_tickers
				# (server, ! 127.127.1.0)
				NTPDATE_FILE=/etc/ntp/ntpservers
				NTPCONF_FILE=/etc/ntp.conf
				NTPDATE_OPTION_FILE=/etc/sysconfig/ntpd
				if [ -s "$NTPDATE_FILE" ] ; then
					read_file -n $NTPDATE_FILE
					if [ "$VAR" ] ; then
						NTPSERVERS="$VAR"
					fi
				else
					NTPSERVERS="`print $(awk '$1=="peer"||$1=="server"{print $2}' $NTPCONF_FILE | fgrep -v 127.127.1.0)`"
				fi
				# ntpdate Optionen einlesen
				if [ -s "$NTPDATE_OPTION_FILE" ] ; then
					read_file -f "$NTPDATE_OPTION_FILE"
					NTPOPTIONS="$NTPDATE_OPTIONS"
				fi
			}
			## }}}
			#
			case $OS in
				Deb*)
					# Debians Konfiguration{{{
					case $IF_OPT in
						grub2)
							# Grub2 Variablen belegen# {{{
							GRUB_DEFAULT_CONFFILE="/etc/default/grub"
							GRUB_DIR="/boot/grub"
							GRUB_CONFFILE="${GRUB_DIR}/grub.cfg"
							GRUB_LIBDIR="/usr/lib/grub"
							## }}}
							;;
						dhcp)
							# Leases Verzeichnis fuer dhcp.# {{{
							DHCLIENT_LEASES_DIR=/var/lib/dhcp
							if [ ! -d "$DHCLIENT_LEASES_DIR" ] ; then
								create_file -d "$DHCLIENT_LEASES_DIR"
							fi
							DHCLIENT_LEASES_TR="."
							## }}}
							;;
						init)
							# Pfade fuer das Initsystem{{{
							RCD_PATH=/etc
							ETC_PATH=/etc
							INITD_PATH="/etc/init.d"
							#}}}
							;;
						initrc)
							# Init Sym Links erstellen/loeschen{{{
							if [ -f "${gv_WorkDir}/runlevconf_startstop" ] ; then
								while read Init_Script RunLevel ; do
									INIT_SCRIPT="$Init_Script"
									RUN_LEVEL="$RunLevel"
									# alle vorherigen Links loeschen
									################################
									# INFO: sysv-rc >=2.88dsf-42
									################################
									update-rc.d -f $INIT_SCRIPT remove &>/dev/null
									if [[ $PACKAGE == sysv-rc ]] ; then
										update-rc.d $INIT_SCRIPT defaults &>/dev/null
										if [[ ${RUN_LEVEL%% *} == start ]] ; then
											RL_Tmp="${${(ws: :)${RUN_LEVEL%% .*}}[3,$]}"
											update-rc.d $INIT_SCRIPT enable ${=RL_Tmp} &>/dev/null
										fi
										if [[ ${${RUN_LEVEL#*. }%% *} == stop ]] ; then
											RL_Tmp="${${(ws: :)${${RUN_LEVEL#*. }% .*}}[3,$]}"
											update-rc.d $INIT_SCRIPT disable ${=RL_Tmp} &>/dev/null
										fi
									else
										update-rc.d $INIT_SCRIPT ${=RUN_LEVEL} &>/dev/null
									fi
								done <${gv_WorkDir}/runlevconf_startstop
								rm -rf ${gv_WorkDir}/runlevconf_startstop &>/dev/null
								#
								if [ "${(M)${RUN_LEVEL}##start}" ] ; then
									ln -sf ${INITD_PATH}/${INIT_SCRIPT} \
									/usr/sbin/rc${INIT_SCRIPT}
									# Prozesse starten/stoppen (init-Scripts)
									init_start_stop
								else
									# Prozess stoppen (init-Scripts)
									rm -f /usr/sbin/rc${INIT_SCRIPT} &>/dev/null
									${INITD_PATH}/${INIT_SCRIPT} stop &>/dev/null
								fi
							fi
							#}}}
							;;
						net)
							# Netzwerk Datei einlesen, falls sie existiert{{{
							# und vorhandene Variablen loeschen
							unset -- gv_Ip gv_Netmask gv_Broadcast gv_Gateway gv_Nameserver gv_Boot
							NET_CONF_PATH=/etc/network
							NET_CONF_FILE=${NET_CONF_PATH}/interfaces
							# Nameserver
							if [ -f /etc/resolv.conf ] ; then
								gv_Nameserver="`print $(awk '/nameserver/{print $2}' /etc/resolv.conf)`"
							fi
							#
							if [ -f "$NET_CONF_FILE" ] ; then
								awk '/iface/{if(/'"$ETH"'/){found=1}else{found=0}}
	        						/address/{if(found){address=$NF}}
									/netmask/{if(found){netmask=$NF}}
									/broadcast/{if(found){broadcast=$NF}}
									/gateway/{if(found){gateway=$NF}}
									END{print address" "netmask" "broadcast" "gateway}' \
									/etc/network/interfaces >${gv_WorkDir}/interface
								read gv_Ip gv_Netmask gv_Broadcast gv_Gateway <${gv_WorkDir}/interface
							fi
							local Auto
							unset -- Auto
							Auto=${(M)${(f)"$(< ${NET_CONF_FILE})"}##(#s)(auto*$ETH)}
							if [ ! -z "$Auto" ] ; then
								gv_Boot=yes
							else
								gv_Boot=no
							fi
							#}}}
							;;
						nisclient)
							# Netzwerk NIS Einstellungen einlesen, falls sie existieren{{{
							# und vorhandene Variablen loeschen
							unset -- NIS_CLIENT_SERVER
							NIS_YPCONF=/etc/yp.conf
							DEFAULTDOMAIN_CONF=/etc/defaultdomain
							DEFAULT_NIS_CONF=/etc/default/nis
							# NIS Client - NIS server Konfiguration einlesen
							if [ -f "$NIS_YPCONF" ] ; then
								NIS_CLIENT_SERVER=${${(ws: :)${(M)${(f)"$(< $NIS_YPCONF)"}##(#s)ypserver*}}[2]}
							fi
							if [ -f "$DEFAULTDOMAIN_CONF" ] ; then
								NIS_CLIENT_DOMAIN=$(< $DEFAULTDOMAIN_CONF)
							fi
							# mus in der $DEFAULT_NIS_CONF auf false gestzt werden.
							NISSERVER=false
							#}}}
							;;
						ntp)
							# Zeitserver Konfigurationsdatei
							NTPDATE_FILE=/etc/default/ntpdate
							read_file -f $NTPDATE_FILE
							;;
						proxy)
							# Proxy Einstellungen
							#
							PROXY_FILE=/etc/default/proxy
							read_proxy
							;;
						raid)
							# RAID Einstellungen
							RAIDTAB=/etc/mdadm/mdadm.conf
							;;
					esac
					#}}}
					;;
				SUSE)
					# SuSE Konfiguration{{{
					case $IF_OPT in
						grub2)
							# Grub2 Variablen belegen# {{{
							GRUB_DEFAULT_CONFFILE="/etc/default/grub"
							GRUB_DIR="/boot/grub2"
							GRUB_CONFFILE="${GRUB_DIR}/grub.cfg"
							GRUB_LIBDIR="/usr/lib/grub2"
							## }}}
							;;
						init)
							# SuSE's Yast benutzen, und dann abbrechen.
							if_conf_prog "$OS" runlevel
							;;
						ntp)
							# SuSE hat ein eigenes Konf-Programm
							# yast2 ntp-client
							if_conf_prog "$OS" ntp
							;;
						proxy)
							# SuSE hat ein eigenes Konf-Programm
							# yast2 proxy
							# Proxy Einstellungen
							if_conf_prog "$OS" proxy
							;;
						raid)
							# RAID Einstellungen# {{{
							if [ -f /etc/sysconfig/mdadm ] ; then
								source /etc/sysconfig/mdadm
								if [ ! -z "$MDADM_CONFIG" ] ; then
									RAIDTAB="$MDADM_CONFIG"
								else
									RAIDTAB=/etc/mdadm.conf
								fi
							else
								RAIDTAB=/etc/mdadm.conf
							fi
							## }}}
							;;
					esac
					#}}}
					;;
				cent*)
					# CentOS Konfiguration{{{
					case $IF_OPT in
						grub2)
							# Grub2 Variablen belegen# {{{
							GRUB_DEFAULT_CONFFILE="/etc/grub2.cfg"
							GRUB_DIR="/boot/grub2"
							GRUB_CONFFILE="${GRUB_DIR}/grub.cfg"
							GRUB_LIBDIR="/usr/lib/grub"
							## }}}
							;;
						init)
							# Pfade fuer das Initsystem.{{{
							ETC_PATH=/etc/rc.d
							RCD_PATH="$ETC_PATH"
							INITD_PATH="/etc/init.d"
							INITD_PREFIX="../init.d"
							#}}}
							;;
						initrc)
							# Init Sym Links erstellen/loeschen
							initrc_config
							;;
						ntp)
							# Zeitserver Konfigurationsdatei.
							rpm_ntp_conf
							;;
						proxy)
							# Proxy Einstellungen
							PROXY_FILE=/etc/sysconfig/proxy
							read_proxy
							;;
						raid)
							# RAID Einstellungen
							RAIDTAB=/etc/mdadm.conf
							;;
					esac
					#}}}
					;;
				fedora)
					# Fedora Konfiguration{{{
					case $IF_OPT in
						grub2)
							# Grub2 Variablen belegen# {{{
							GRUB_DEFAULT_CONFFILE="/etc/grub2.cfg"
							GRUB_DIR="/boot/grub2"
							GRUB_CONFFILE="${GRUB_DIR}/grub.cfg"
							GRUB_LIBDIR="/usr/lib/grub"
							## }}}
							;;
						init)
							# Pfade fuer das Initsystem.{{{
							ETC_PATH=/etc/rc.d
							RCD_PATH="$ETC_PATH"
							INITD_PATH="/etc/init.d"
							INITD_PREFIX="../init.d"
							#}}}
							;;
						initrc)
							# Init Sym Links erstellen/loeschen
							initrc_config
							;;
						ntp)
							# Zeitserver Konfigurationsdatei.
							rpm_ntp_conf
							;;
						proxy)
							# Proxy Einstellungen
							PROXY_FILE=/etc/sysconfig/proxy
							read_proxy
							;;
						raid)
							# RAID Einstellungen
							RAIDTAB=/etc/mdadm.conf
							;;
					esac
					#}}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (if_conf_prog), um zu pruefen fuer welches OS,{{{
	# welches Konfiguration Programm zustaendig 
	# ist und dann starten. Ist keines vorhanden wird der kwtools Code benutzt.
	#
	# usage: if_conf_prog "$OS" PARAMETER
	# PARAMETER - Parametr welcher konfiguriert werden soll.
	#             [auth|libpam-ldap|mail|net|raid]
	#
	if_conf_prog() {
		local If_Opt Os
		# Funktion (mdmonitor_rh_msg), Nachricht das CentOS, Fedora das Startscript# {{{
		# mdmonitor aktivieren muessen.
		# usage: mdmonitor_rh_msg
		#
		mdmonitor_rh_msg() {
			MSG=$(gettext 'Bei "$Os" muessen Sie nur das Startscript (mdmonitor) aktivieren.')
			msgbox "$gv_Attention" "$MSG"
		}
		## }}}
		# Funktion (no_quickly_mailconf_msg), Nachricht das CentOS, Fedora# {{{
		# kein Konfigurationstool fuer postfix haben.
		# usage: no_quickly_mailconf_msg
		#
		no_quickly_mailconf_msg() {
			MSG=$(gettext 'Es gibt kein Quickly-Konfigurationstool fuer das Paket "postfix" unter "$Os".')
			msgbox "$gv_Attention" "$MSG"
		}
		## }}}
		if [ "$#" -ge 2 ] ; then
			Os="$1"
			If_Opt="$2"
			#
			case "$Os" in
				Deb*)
					# Debians dpkg-reconfigure benutzen# {{{
					case "$If_Opt" in
						ldap-client)
							# LDAP Authentifizierung# {{{
							prog_check dpkg-reconfigure
							if [[ -n $PROGS ]] ; then
								dpkg-reconfigure libpam-ldap
							fi
							## }}}
							;;
						mail)
							# Postfix Mailserver Konfiguration# {{{
							prog_check dpkg-reconfigure
							if [[ -n $PROGS ]] ; then
								dpkg-reconfigure postfix
							fi
							## }}}
							;;
						raid)
							# Raid Monitor Konfiguration# {{{
							prog_check dpkg-reconfigure
							if [[ -n $PROGS ]] ; then
								dpkg-reconfigure mdadm
							fi
							## }}}
							;;
					esac
					## }}}
					;;
				SUSE)
					# yast2 benutzen# {{{
					# Funktion (if_yast2_modules), nach yast2 Modulen suchen# {{{
					#
					# usage: if_yast2_modules MODUL
					# MODUL - Modul nach dem gesucht werden soll
					#
					if_yast2_modules() {
						if [[ ${=argv} == 1 ]] ; then
							MODUL="`print ${(M)$(yast2 -l)##${1}}`"
						else
							no_para_msg $0
						fi
					}
					## }}}
					case "$If_Opt" in
						auth)
							# Authentifizierung Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								yast2
							fi
							## }}}
							;;
						mail)
							# Mail Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules mail
								if [[ -n $MODUL ]] ; then
									yast2 mail
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-mail\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
						net)
							# Netzwerk Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules lan
								if [[ -n $MODUL ]] ; then
									yast2 lan
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-network\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
						ntp)
							# NTP Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules ntp-client
								if [[ -n $MODUL ]] ; then
									yast2 ntp-client
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-ntp-client\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
						proxy)
							# Proxy Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules proxy
								if [[ -n $MODUL ]] ; then
									yast2 proxy
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-network\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
						raid)
							# Raid/mdadm Monitor Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules sysconfig
								if [[ -n $MODUL ]] ; then
									yast2 sysconfig
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-sysconfig\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
						runlevel)
							# runlevel Konfiguration# {{{
							prog_check yast2
							if [ -n "$PROGS" ] ; then
								# Module suchen ob verfuegbar.
								if_yast2_modules runlevel
								if [[ -n $MODUL ]] ; then
									yast2 runlevel
								else
									MSG=$(gettext 'Sie muessen erst das Paket \"yast2-runlevel\" installieren.')
									msgbox "$gv_Attention" "$MSG"
								fi
							fi
							## }}}
							;;
					esac
					## }}}
					;;
				cent*)
					# CentOS Konfigurationstools# {{{
					case "$If_Opt" in
						auth)
							prog_check authconfig-tui
							if [ -n "$PROGS" ] ; then
								authconfig-tui
							fi
							;;
						mail)
							no_quickly_mailconf_msg
							;;
						net)
							prog_check system-config-network-tui
							if [ -n "$PROGS" ] ; then
								system-config-network-tui
							fi
							;;
						raid)
							mdmonitor_rh_msg
							;;
					esac
					## }}}
					;;
				fedora)
					# Fedora Konfigurationstools# {{{
					case "$If_Opt" in
						auth)
							prog_check authconfig-tui
							if [ -n "$PROGS" ] ; then
								authconfig-tui
							fi
							;;
						mail)
							no_quickly_mailconf_msg
							;;
						net)
							prog_check system-config-network-tui
							if [ -n "$PROGS" ] ; then
								system-config-network-tui
							fi
							;;
						raid)
							mdmonitor_rh_msg
							;;
					esac
					## }}}
					;;
				*)	hier_ist_noch_nichts $If_Opt	;;
			esac
		else
			no_para_msg $0
		fi
	}
	# }}}
# Funktion (is_value), Werte mit denen in gv_IsValue_File vergleichen.{{{
#
# usage: is_value "VALUE VALUE1 ..."
# VALUE - Werte mit denen in $gv_IsValue_File vergleichen
#
is_value() {
	unset -- VALUE_ARRAY DEFAULT_VALUE
	if [ "$#" -eq 1 ] ; then
		Values="$1"
		local Is
		for i in ${=Values} ; {
			if [ -f "$gv_IsValue_File" ] ; then
				Is="`print ${(u)${(M)${(f)"$(< $gv_IsValue_File)"}##$i *}}`"
				if [[ ${Is%% *} == $i ]] ; then
					VALUE_ARRAY+=(${(qq)i} \"\" on)
					DEFAULT_VALUE+=($i)
				else
					VALUE_ARRAY+=(${(qq)i} \"\" off)
				fi
			else
				VALUE_ARRAY+=(${(qq)i} \"\" off)
			fi
		}
	else
		no_para_msg $0
	fi
}
#}}}
	# Funktion (kernel_release), Infos ueber den laufenden kernel{{{
	#
	# usage: kernel_release
	# globale Variablen sind
	# gv_K_Release
	# gv_K_Major
	# gv_K_Minor
	# gv_K_S_Minor
	# gv_K_Suffix
	#
	kernel_release() {
		export gv_K_Release gv_K_Suffix gv_K_Major gv_K_Minor gv_K_S_Minor
		#
		gv_K_Release="`uname -r`"
		print ${(s:.:)${gv_K_Release}} | while read a b c d ; do
			if [[ $a -ge 3 ]] ; then
				gv_K_Major="$a"
				gv_K_Minor="$b"
				gv_K_S_Minor="${c%%-*}"
				gv_K_Suffix=".ko"
			else
				case "$b" in
					[56])
						gv_K_Major="$a"
						gv_K_Minor=6
						gv_K_S_Minor="${c%%-*}"
						gv_K_Suffix=".ko"
						;;
					[34])
						gv_K_Major="$a"
						gv_K_Minor=4
						gv_K_S_Minor="${c%%-*}"
						gv_K_Suffix=".o"
						;;
				esac
			fi
		done
	}
	#}}}
	# Funktion (list_shell), verfuegbare shells auflisten{{{
	# und zur Auswahl anbieten.
	#
	# usage: list_shell [ Shell ]
	# Shell - Variable mit vorher eingestellter Shell
	#
	list_shell() {
		unset -- gv_Shell Shell Opt
		local Shell Opt

		if [[ ${#argv} == 1 ]] ; then
			Opt="$1"
		fi

		for i in /bin/false ${(o)${(M)${(f)"$(< /etc/shells)"}##(#s)/*}} ; {
			if [ -x "$i" ] ; then
				Shell+=( $i \"\" )
			fi
		}

		if [ -n "${Shell[2]}" ] ; then
			unset -- LOCAL_SHELL_MENU
			LOCAL_SHELL_MENU="$Shell"
			LOCAL_SHELL_TITLE=$(gettext 'Shell-Auswahl')
			LOCAL_SHELL_MSG=$(gettext 'Waehlen Sie eine der installierten Shells aus.')
			# Funktion (list_shell_menu)# {{{
			#
			list_shell_menu() {
				menubox "$1" "$LOCAL_SHELL_TITLE" "$LOCAL_SHELL_MSG" "$LOCAL_SHELL_MENU"
			}
			## }}}
			list_shell_menu "$Opt"
			while [ "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/shell_help
						list_shell_menu "${gv_Auswahl#HELP }"
						;;
					*)	# uebernehmen
						gv_Shell="$gv_Auswahl"
						break
						;;
				esac
			done
		else
			MSG=$(gettext 'Es sind keine lokalen shells installiert (?).')
			msgbox "$gv_Info" "$MSG"
		fi
	}
	#}}}
	# Funktion (load_module), um Kernelmodule zu laden{{{
	#
	# usage: load_module $MODULE
	#
	load_module() {
		if [ "$#" -ge 1 -a -n "$gv_K_Release" ] ; then
			for i in ${=1} ; {
				if [ -f /lib/modules/${gv_K_Release}/**/${i}${gv_K_Suffix} ] ; then 
					case $i in
						dm-mod|dm-crypt)
							if [ -z ${(M)$(lsmod)[(fr)${i//-/_}]} ] ; then
								modprobe -qb $i &>/dev/null || return 1
							fi
							;;
						*)
							if [ -z ${(M)$(lsmod)[(fr)$i]} ] ; then
								modprobe -qb $i &>/dev/null || return 1
							fi
							;;
					esac
				fi
			}
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	#}}}
	# Funktion (lock){{{
	#
	# Sperrt Devices (locken), benoetigt die Funktion create_file.
	#
	# usage: lock [ -r ][ -s | nichts ] "$DEVICES"
	# -r - lockfile loeschen
	# -s - Scriptname locken
	# nichts - Device locken
	#
	lock() {
		case $1 in
			-r)	# lock loeschen
				for i in $2 ; {
					rm -f /var/tmp/${i##*/}.lock &>/dev/null
				}
				;;
			-s)	# Script lock anlegen
				# Wird das Script schon benutzt kommt eine Nachricht das das Script
				# gerade benutzt wird und 2 Ebenen hoeher gesprungen, ohne Terminal
				# wird das Script beendet.
				for i in $2 ; {
					if [ -e /var/tmp/${i##*/}.lock ] ; then
						# Nachricht nur wenn ein Terminal offen ist anzeigen.
						if [[ -n $gv_Terminal ]] ; then
							MSG=$(gettext '$i wird gerade benutzt. Versuchen Sie es spaeter nochmal.')
							msgbox "$gv_Attention" "$MSG"
							break 2
						else
							print "$MSG"
							exit 0
						fi
					else
						create_file "/var/tmp/${i##*/}.lock"
					fi
				}
				;;
			*)	# Device lock anlegen
				# Wird das Device schon benutzt kommt eine Nachricht das das Device
				# gerade benutzt wird und 2 Ebenen hoeher gesprungen.
				for i in $1 ; {
					if [ -e /var/tmp/${i##*/}.lock ] ; then
						MSG=$(gettext 'Das Device (${i}) wird gerade benutzt. Versuchen Sie es spaeter nochmal.')
						# Nachricht nur wenn ein Terminal offen ist anzeigen.
						if [[ -n $gv_Terminal ]] ; then
							msgbox "$gv_Attention" "$MSG"
						else
							print "$MSG"
						fi
						break 2
					else
						create_file "/var/tmp/${i##*/}.lock"
					fi
				}
				;;
		esac
	}
	#}}}
	# Funktion (lo_setup), um nach freien loop Devices zu suchen,# {{{
	# bzw. ein loop Device entfernen.
	#
	# usage: lo_setup [ -r ] [ LOOPDEVICE ]
	# -r - entferne das uebergebene Loop Device
	# LOOPDEVICE - Variable die das zu entfernende Loop Device enthaelt
	#
	lo_setup() {
		unset -- gv_Loop_Dev
		if [[ ${#argv} == 2 ]] && [[ $1 == -r ]] ; then
			# detaching loopback devices
			if [[ -b $2 ]] && [[ $2 == /dev/loop* ]] ; then
				gv_Loop_Dev="$2"
				if ! losetup -d $gv_Loop_Dev ; then
					MSG=$(gettext 'Das loopback Geraet ($gv_Loop_Dev) konnte nicht ausgebunden werden.')
					msgbox "$gv_Attention" "$MSG"
					return 1
				fi
			fi
		else
			# Set up loopback devices
			unset -- gv_Loop_Dev
			gv_Loop_Dev=$(losetup -f 2>/dev/null)
			if [ -z "$gv_Loop_Dev" ] ; then
				MSG=$(gettext 'Es sind keine freien loop Schnittstellen mehr vorhanden.')
				msgbox "$gv_Attention" "$MSG"
				return 1
			fi
		fi
		return 0
	}
	## }}}
	# Funktion (mask)# {{{
	#
	# benoetigt die Funktion number_input, check_mask
	#
	# usage: mask [ -u ] [ VAR ]
	# VAR - vorheriger Wert
	#
	mask() {
		# Uebersetzung mittels gettext
		MASK_TITLE=$(gettext 'Zugriffsrechte')
		MASK_MSG=$(gettext 'Geben Sie bitte die Zugriffsrechte ein. (1=ausfuehren , 2=schreiben, 4=lesen) Man kann diese Zahlen unterschiedlich zusammenrechnen (Bsp. 0640, man 1 chmod).')
		UMASK_MSG=$(gettext 'Geben Sie hier bitte die 3 oder 4 Oktalzifern fuer die Zugriffsrechte ein (Bsp. 0022 oder 022, man 2 umask).')
		#
		if [ -z "$1" ] ; then
			number_input "$MASK_TITLE" "$MASK_MSG"
			if [ "$NUMBER" ] ; then
				check_mask
			fi
		else
			OPT="$1"
			case "$OPT" in
				-u)
					MODE="$2"
					number_input "$MASK_TITLE" "$UMASK_MSG" "$MODE"
					if [ "$NUMBER" ] ; then
						check_mask
					fi
					;;
				*)
					number_input "$MASK_TITLE" "$MASK_MSG" "$OPT"
					if [ "$NUMBER" ] ; then
						check_mask
					fi
					;;
			esac
		fi
	}
	## }}}
	# Funktion (mount_check), um Laufwerke zu (u)mounten{{{
	#
	# usage: mount_check [ -a | -c | -m | -s | -u ] DEVICE
	# -a - automatisch ohne Fragen umounten
	# -c - checken, ob gemountet ist oder nicht.
	# -m - Dateisystem mounten
	# -s - Swap Dateisystem mounten
	# -u - Dateisystem umounten, mit Nachfrage
	#
	# Variablen:
	# MOUNTPOINT - Verzeichnis wo die Partition gemountet ist (nur bei umount)
	# MOUNT - eingebunden oder nicht (yes/no)
	# U_MOUNT - ausgebunden oder nicht (yes/no)
	# 
	mount_check() {
		if [ "$#" -eq 2 ] ; then
			# Funktion no_umount_os_msg# {{{
			no_umount_os_msg() {
				MSG=$(gettext '$MOUNTPOINT wird nicht aus dem Verzeichnisbaum ausgebunden, da es vom Betriebssystem benoetigt wird.')
				msgbox "$gv_Attention" "$MSG"
			}
			## }}}
			# Funktion no_umount_msg# {{{
			no_umount_msg() {
				MSG=$(gettext '$PART_DEV konnte(n) nicht aus dem Dateisystem entfernt werden.')
				msgbox "$gv_Attention" "$MSG"
			}
			## }}}
			# Funktion umount_part_omit_msg# {{{
			umount_part_omit_msg() {
				MSG=$(gettext '$PART_DEV wird ausgelassen.')
				msgbox "$gv_Attention" "$MSG"
			}
			## }}}
			YES_NO_MOUNT_MSG=$(gettext '$PART_DEV ist ins Dateisystem eingebunden. Es muss oder kann entfernt werden. Soll dies jetzt geschehen (ja/nein)?')
			unset -- MOUNTPOINT MOUNT U_MOUNT PART_DEV PART_DEV1
			export MOUNTPOINT
			PART_DEV="$2"
			# Pruefen ob es ein LVM Device ist und dementsprechend
			# die Variable PART_DEV1 belegen.
            if [ "${#${(ws:/:)$(print ${PART_DEV})}}" = 3 ] && \
				[ "/${${(ws:/:)$(print ${PART_DEV})}[1]}" = /dev ] ; then
				print ${(ws:/:)$(print ${PART_DEV})} | while read Dev Vg Lv ; do
					if [ $Vg != mapper ] ; then
						PART_DEV1="/${Dev}/mapper/${Vg}-${Lv}"
					fi
				done
			fi
            # bei loop Devices muss man den Device Pfad neu einstellen.
            if [ "${${${(s:/:)${PART_DEV}}[2]}%%[-|0-9]*}" = loop ] ; then
                Part_Nr="${${PART_DEV##*/}##loop}"
                PART_DEV1="/dev/loop${Part_Nr}"
            fi
			# wenn die Variable PART_DEV1 leer ist wird sie jetzt
			# mit dem Wert der Variablen PART_DEV belegt.
			if [ -z "$PART_DEV1" ] ; then
				PART_DEV1="$PART_DEV"
			fi
			case $1 in
				-a)	
					# ohne fragen Partitionen umounten.# {{{
					unset -- U_MOUNT
					MOUNTPOINT="`print ${${(s: :)${(M)${(f)"$(mount)"}##*${PART_DEV1}[[:space:]]*}}[3]}`"
					SW_DEV="`print ${$(swapon -s)[(fr)${PART_DEV1}]}`"
					if [ "$MOUNTPOINT" ] ; then
						case $MOUNTPOINT in
							/|/bin|/dev|/etc|/lib|/proc|/run|/sbin|/sys|/tmp|udev)
								no_umount_os_msg
								U_MOUNT=no
								;;
							*)	# Falls die Partition gemountet, ist ohne nachfragen umounten.
								umount "$PART_DEV" 
								if [ $? != 0 ] ; then
									no_umount_msg
									U_MOUNT=no
								else
									U_MOUNT=yes
								fi
								;;
						esac
						# Swap bearbeiten
					elif [ -n "$SW_DEV" ] ; then
						swapoff "$SW_DEV"
						if [ $? != 0 ] ; then
							no_umount_msg
							U_MOUNT=no
						else
							U_MOUNT=yes
						fi
					else
						U_MOUNT=yes
					fi
					## }}}
					;;
				-c)
					# Pruefen, ob Verzeichnis/Partition/... eingebunden ist# {{{
					unset -- MOUNT MOUNTPOINT
					MOUNTPOINT="`print ${${(s: :)${(M)${(f)"$(mount)"}##*${PART_DEV1}[[:space:]]*}}[3]}`"
					if [ -z "$MOUNTPOINT" ] ; then
						MOUNT=no
					else
						MOUNT=yes
					fi
					## }}}
					;;
				-m)
					# Partition einbinden# {{{
					unset -- MOUNT
					if [ -z "`print ${${(s: :)${(M)${(f)"$(mount)"}##(#s)*${PART_DEV1}[[:space:]]*}}[3]}`" ] ; then
						mount "$PART_DEV" &>/dev/null
						if [ $? != 0 ] ; then
							MSG=$(gettext '$PART_DEV konnte nicht ins Dateisystem eingebunden werden. Das Laufwerk muss in der Datei /etc/fstab konfiguriert, beziehungsweise an den Rechner angestoepselt sein.')
							msgbox "$gv_Attention" "$MSG"
							MOUNT=no
						fi
					fi
					## }}}
					;;
				-s)
					# Swap einbinden# {{{
					unset -- MOUNT
					SW_DEV="`print ${$(swapon -s)[(fr)${PART_DEV1}]}`"
					if [[ -z $SW_DEV ]] ; then
						swapon "$PART_DEV" &>/dev/null
						if [ $? != 0 ] ; then
							MSG=$(gettext '$PART_DEV konnte nicht ins Dateisystem eingebunden werden. Das Laufwerk muss in der Datei /etc/fstab konfiguriert, beziehungsweise an den Rechner angestoepselt sein.')
							msgbox "$gv_Attention" "$MSG"
							MOUNT=no
						fi
					fi
					## }}}
					;;
				-u)	
					# Partition ausbinden# {{{
					unset -- U_MOUNT
					MOUNTPOINT="`print ${${(s: :)${(M)${(f)"$(mount)"}##*${PART_DEV1}[[:space:]]*}}[3]}`"
					SW_DEV="`print ${$(swapon -s)[(fr)${PART_DEV1}]}`"
					if [ -n "$MOUNTPOINT" ] ; then
						case $MOUNTPOINT in
							/|/bin|/dev|/etc|/lib|/proc|/run|/sbin|/sys|tmp|/udev)
								no_umount_os_msg
								U_MOUNT=no
								;;
							*)	# Falls die Partition gemountet, ist nachfragen ob sie
								# umountet werden soll.
								# Vorschlag "yes" für die Funktion "yesno", siehe Funktion
								# "yesno".
								yesno "$gv_Attention" "$YES_NO_MOUNT_MSG" ""
								# Wenn ja, umounten
								if [ "$gv_Auswahl" = yes ] ; then
									umount "$MOUNTPOINT" 
									if [ $? != 0 ] ; then
										no_umount_msg
										U_MOUNT=no
									else
										U_MOUNT=yes
									fi
								else 
									umount_part_omit_msg
									U_MOUNT=no
								fi
								;;
						esac
						# Swap bearbeiten
					elif [ -n "$SW_DEV" ] ; then
						# Falls die Partition gemountet, ist nachfragen ob sie
						# umountet werden soll.
						# Vorschlag "yes" für die Funktion "yesno", siehe Funktion
						# "yesno".
						yesno "$gv_Attention" "$YES_NO_MOUNT_MSG" ""
						# Wenn ja, umounten
						if [ "$gv_Auswahl" = yes ] ; then
							swapoff "$SW_DEV"
							if [ $? != 0 ] ; then
								no_umount_msg
								U_MOUNT=no
							else
								U_MOUNT=yes
							fi
						else 
							umount_part_omit_msg
							U_MOUNT=no
						fi
					else
						U_MOUNT=yes
					fi
					## }}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (mount_path), um ein MountVerzeichnis einzustellen# {{{
	# Dieses muss in der /etc/fstab bereits angelegt worden sein.
	#
	# benoetigt die Funktion mount_check, dselect und dselect_check.
	#
	# usage: mount_path MOUNT_PATH
	#
	mount_path() {
		if [ -n "$1" ] ; then
			MOUNT_PATH="$1"
		fi
		dselect "$MOUNT_PATH"
		if [ "$VERZ" ] ; then
			dselect_check "$VERZ"
			if [ "$VERZ" ] ; then
				MOUNT_PATH="$VERZ"
				mount_check -m "$MOUNT_PATH"
				# Rechte checken
				if [ "$MOUNT" = yes ] ; then
					user_device_check "$MOUNT_PATH" AE
				fi
			else
				MOUNT_PATH=""
			fi
		else
			MOUNT_PATH=""
		fi
	}
	## }}}
	# Funktion (os_check), um das Linux oder (irgendwann *BSD) OS herauszubekommen{{{
	# Es geht dabei um die jeweiligen Konfigurationsdateien und deren Syntax,
	# von verschiedenen Distributionen.
	# Diese kann man dann mit den Funktionen if_conf_{file,prog} benutzen.
	# (Bsp. if_conf_file "$OS" Parameter)
	#
	# usage: os_check
	#
	os_check() {
		# Diese Distris werden unterstuetzt. Bei Debian gibt es noch die
		# Unterstutzung fuer die Live-CD grml.
		for i in centos Debian fedora SUSE ; {
			if [ ! -z "`print ${(M)${(f)"$(< /proc/version)"}##*${i}}`" ] ; then
				OS="$i"
				break
			fi
		}
		#
		if [ ! -z "$OS" ] ; then
			case $OS in
				centos)
					if [ -e /etc/redhat-release ] ; then
						OS_D=${$(< /etc/redhat-release)[1]}
						case "$OS_D" in
							CentOS)
								# CentOS
								VERSION=${$(< /etc/redhat-release)[3]}
								if [[ $VERSION -lt 7.0 ]] ; then	
									MSG=$(gettext 'Sie benoetigen eine CentOS 5.0 oder hoeher um mit diesem Modul arbeiten zu koennen.')
									msgbox "$gv_Info" "$MSG"
								fi
								;;
						esac
					else
						no_release_msg
					fi
					;;
				Debian)
					# Wenn Debian gleich grml ist, erst Version von grml checken.
					if [ -e /etc/debian_version -a -e /etc/grml_version ] ; then
						VERSION=${${(ws: :)$(< /etc/grml_version)}[2]}
						if [[ $VERSION -lt 2014.11 ]] ; then
							MSG=$(gettext 'Sie benoetigen ein grml 2014.11 oder hoeher um mit diesem Modul arbeiten zu koennen.')
							msgbox "$gv_Info" "$MSG"
						fi
					# Debian normal checken
					elif [ -e /etc/debian_version ] ; then
						MSG=$(gettext 'Sie benoetigen ein Debian 8.0 oder hoeher um mit diesem Modul arbeiten zu koennen.')
						VERSION=${${(M)$(< /etc/debian_version)[(fr)(#s)[0-9]*]}%%.*}
						if [ ! -z $VERSION ] ; then
							if [[ $VERSION -lt 8 ]] ; then
								msgbox "$gv_Info" "$MSG"
							fi
						else
							VERSION=${(M)$(< /etc/debian_version)[(fr)*(testing|unstable|sid)*]}
							if [ -z $VERSION ] ; then
								msgbox "$gv_Info" "$MSG"
							fi
						fi
					else
						no_release_msg
					fi
					;;
				fedora)
					if [ -e /etc/fedora-release ] ; then
						# Fedora8
						VERSION=${$(< /etc/fedora-release)[3]}
						if [[ $VERSION -lt 21 ]] ; then	
							MSG=$(gettext 'Sie benoetigen eine Fedora 21 oder hoeher um mit diesem Modul arbeiten zu koennen.')
							msgbox "$gv_Info" "$MSG"
						fi
					else
						no_release_msg
					fi
					;;
				SUSE)
					if [ -e /etc/SuSE-release ] ; then
						VERSION=${${(s: :)${(M)${(f)"$(< /etc/SuSE-release)"}##VERSION*}}[3]}
						if [[ $VERSION -lt 13.2 ]] ; then	
							MSG=$(gettext 'Sie benoetigen eine SuSE 13.2 oder hoeher um mit diesem Modul arbeiten zu koennen.')
							msgbox "$gv_Info" "$MSG"
						fi
					else
						no_release_msg
					fi
					;;
			esac
		else
			MSG=$(gettext 'Diese Distribution wird noch nicht unterstuetzt. Sie arbeiten auf eigene Gefahr.')
			msgbox "$gv_Info" "$MSG"
		fi
	}
	#}}}
	# Funktion (password_display), Passwortzeichen in Sternchen umwandeln{{{
	#
	# usage: password_display PASSPHRASE
	#
	password_display() {
		if [[ ${#argv} == 1 ]] ; then
			local Passphrase Pass_Anz Anz
			integer Pass_Anz Anz
			Pass="$1"
			Pass_Anz="${(c)#Pass}"
			Anz=1
			while [ "$Anz" -le "$Pass_Anz" ] ; do
				Passphrase[Anz]="*"
				(( Anz++ ))
			done
			gv_Star_Passphrase="${Passphrase// /}"
			unset -- Passphrase
		else
			no_para_msg "$0"
		fi
	}
	#}}}
	# Funktion (print_file), Datei Drucken ja/nein{{{
	#
	# benoetigt die Funktion yesno
	# usage: print_file File
	# Es wird bisher nur der Standard-Drucker benutzt.
	#
	print_file() {
		unset -- File
		local File
		if [ $# -eq 1 ] ; then
			#
			# Soll die Datei gedruckt werden?
			#
			File="$1"
			TITLE=$(gettext 'Drucken')
			MSG=$(gettext 'Soll die Datei $File gedruckt werden (ja/nein)?')
			yesno "$TITLE" "$MSG" ""
			if [ "$gv_Auswahl" = yes ] ; then
				lpr "$File"
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (prog_check), Programm auf Rechte und vorhanden/ausfuehrbar pruefen{{{
	#
	# usage: prog_check [ -p PERM ] "Programm Programm ..."
	# -p - zur Zeit geht nur:
	# PERM=s - setuid Eigentuemer ausfuehrbar (Bsp. cdrdao)
	#
	prog_check() {
		unset -- PROGS PROGS_E NO_PROGS
		local Perm
		if [ "$#" -ge 1 ] ; then
			case $1 in
				-p)
					# Pruefen der Rechte, ob Programm ausfuehrbar ist.{{{
					if [ "$2" -a "$3" ] ; then
						case $2 in
							s)
								# Rechte des ausfuehrbaren Programs checken.
								Perm=$2
								for i in $3 ; {
									P="${commands[$i]}"
									if [ -x "$P" ] ; then
										if [ "$UID" != 0 -a n "${P}($Perm)" ] ; then
											PROGS+=($i)
											PROGS_E+=($i \"\")
							                PROGS_L+=($P)
										elif [ "$UID" = 0 ] ; then
											PROGS+=($i)
											PROGS_E+=($i \"\")
							                PROGS_L+=($P)
										else
											autoload -U no_perm_prog_msg
											no_perm_prog_msg "$i"
										fi
									else
										no_prog_exec_msg "$i"
									fi
								}
								;;
							*)	# falscher Parameter
								wrong_parameter_msg "$0"
								;;
						esac
					else
						no_para_msg $0
					fi
					#}}}
					;;
				*)
					# Pruefen ob Programm ausfuehrbar ist.{{{
					for i in $@ ; {
						if [[ -x ${commands[$i]} ]] ; then
							PROGS+=($i)
							PROGS_E+=($i \"\")
							PROGS_L+=(${commands[$i]})
						else
							if [[ -z $NO_PROGS ]] ; then
								NO_PROGS+=($i)
							else
								NO_PROGS+=(, $i)
							fi
						fi
					}
					if [ -n "$NO_PROGS" ] ; then
						no_prog_exec_msg "$NO_PROGS"
					fi
					#}}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (prog_exec), Programm ausfuehren{{{
	#
	# usage: prog_exec [ -i | -p ] "$PROG" "$PROG_OPT"
	# -i - inverse Darstellung
	# -p - Darstellung mittels progressbox (andere Fehlermeldung)
	#
	prog_exec() {
		RET=0
		if [ "${#argv}" -ge 2 ] ; then
			case $1 in
				-i)
					# inverse Darstellung im Terminal.
					Prog="$2"
					# pruefen, ob Programm ausfuehrbar ist.
					if [[ -x ${commands[$Prog]} ]] ; then
						if [[ -n $gv_Terminal ]] ; then
							setterm --clear all
							setterm --inversescreen on
							eval "$Prog" "$3"
							if [ "$?" != 0 ] ; then
								prog_failure
							fi
							setterm --inversescreen off
							setterm --clear all
						else
							eval "$Prog" "$3"
							if [ "$?" != 0 ] ; then
								prog_failure
							fi
						fi
					else
						# Wenn nicht gibts ne Fehlermeldung.
						no_prog_exec_msg "$Prog"
					fi
					;;
				-p)
					# Darstellung mit progressbox
					Prog="$2"
					# pruefen, ob Programm ausfuehrbar ist.
					if [[ -x ${commands[$Prog]} ]] ; then
						if [[ -n $gv_Terminal ]] ; then
							setterm --clear all
							eval "$Prog" "$3"
						else
							eval "$Prog" "$3"
						fi
					else
						# Wenn nicht gibts ne Fehlermeldung.
						no_prog_exec_msg "$Prog"
					fi
					;;
				*)
					# pruefen, ob Programm ausfuehrbar ist.
					Prog="$1"
					if [[ -x ${commands[$Prog]} ]] ; then
						if [[ -n $gv_Terminal ]] ; then
							setterm --clear all
							eval "$Prog" "$2"
							if [ "$?" != 0 ] ; then
								prog_failure
							fi
						else
							eval "$Prog" "$2"
							if [ "$?" != 0 ] ; then
								prog_failure
							fi
						fi
					else
						# Wenn nicht gibts ne Fehlermeldung.
						no_prog_exec_msg "$Prog"
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (prog_exec_only), um Programme nur auszufuehren{{{
	#
	# usage: prog_exec_only "$PROGRAMM" (meistens $gv_Auswahl)
	# prog_exec_only "$PROGRAMM" "$OPT"
	# Ist aehnlich der Funktion prog_exec bloss dass hier alles
	# im Hintergrund laufen sollte.
	#
	prog_exec_only() {
		RET=0
		if [ ${#argv} -ge 1 ] ; then
			# pruefen, ob Programm ausfuehrbar ist.
			Prog="$1"
			if [ -x "${commands[$Prog]}" ] ; then
				eval "$Prog" "$2"
				if [ "$?" != 0 ] ; then
					prog_failure
				fi
			else
				# Wenn nicht gibts ne Fehlermeldung.
				no_prog_exec_msg "$Prog"
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (raid_gauge), Fortschrittsanzeige# {{{
	#
	# usage: raid_gauge
	#
	raid_gauge() {
		if [[ ${#argv} == 1 ]] ; then
			local Dev
			Dev="$1"
			RAID_CONF_TITLE=$gv_Create
			FINISH="`print ${${(ws:=:)${(M)$(< /proc/mdstat)##finish*}}[2]}`"
			GAUGE_MSG=$(gettext '$DEV wird erstellt und/oder syncronisiert - ')
			RAID_GAUGE_MSG="${GAUGE_MSG}${FINISH}"
			Tmp="-1"
			PERCENT1="`print ${${(s: :)${${(s:%:)${(M)${(f)"$(< /proc/mdstat)"}##*(recovery|resync|reshape)*}}[1]}}[4]}`"
			PERCENT="${PERCENT1%%.*}"
			if [ -n "$PERCENT" ] ; then
				while [ -n "$PERCENT" -a "$PERCENT" -le 100 ] ; do
					if [ "$Tmp" != "$PERCENT" ] ; then
						Tmp="$PERCENT"
						print "$PERCENT" | gauge "$RAID_CONF_TITLE" "$RAID_GAUGE_MSG" ; PERCENT1="`print ${${(s: :)${${(s:%:)${(M)${(f)"$(< /proc/mdstat)"}##*(recovery|resync|reshape)*}}[1]}}[4]}`" ; PERCENT="${PERCENT1%%.*}" ; FINISH="`print ${${(ws:=:)${(M)$(< /proc/mdstat)##finish*}}[2]}`" ; RAID_GAUGE_MSG="${GAUGE_MSG}${FINISH}"
					else
						PERCENT1="`print ${${(s: :)${${(s:%:)${(M)${(f)"$(< /proc/mdstat)"}##*(recovery|resync|reshape)*}}[1]}}[4]}`"
						PERCENT="${PERCENT1%%.*}"
						FINISH="`print ${${(ws:=:)${(M)$(< /proc/mdstat)##finish*}}[2]}`"
						RAID_GAUGE_MSG="${GAUGE_MSG}${FINISH}"
					fi
				done
			fi
		else
			no_para_msg $0
			return 1
		fi
		return 0
	}
	## }}}
	# Funktion (read_file), Datei(en) einlesen{{{
	#
	# usage: read_file [ -f ] [ DATEI | DATEI DATEI DATEI ... ]
	#        read_file [ -n ] DATEI
	#        read_file [ -s Splitzeichen Ersatzzeichen ] DATEI
	#        -f individuelle Konf.-Dateien
	#        -n Konf.-Dateien die nicht mittels "source" eingelesen werden koennen,
	#           sondern reine Daten sind.
	#
	# read ohne Option, dann wird versucht, die uebergebenden "$Konfigurationsdateien"
	# im Verzeichnis ~/.kwtools zu finden und einzulesen.
	# Ist die Variable MOUNT_PATH, nach dem einlesen der K.-Datei, belegt wird diese Partition
	# ins Dateisystem eingebunden, falls sie es nicht schon ist. Sie muss in der /etc/fstab
	# stehen.
	#
	read_file() {
		if (( ${#argv} > 0 )) ; then
			case "$1" in
				-f)
					# individuelle Dateien einlesen# {{{
					#
					shift
					while (( ${#argv} > 0 )) ; do
						if [[ -r ${1} ]] ; then
							source ${1} 2>/dev/null
							if [ ! -z "$MOUNT_PATH" ] ; then
								for point in $MOUNT_PATH ; { 
									mount_check -m "$point"
								}
							fi
						fi
						shift
					done
					## }}}
					;;
				-n)
					# keine Variablen einlesen, sondern nur reine Daten.# {{{
					# Es geht nur eine Dateiuebergabe.
					#
					if [ -r "$2" ] ; then
						VAR="`print $(egrep -v "^[[:space:]]*(#|$)" $2)`"
					fi
					## }}}
					;;
				-s)
					# -s - Splitzeichen der Konfigurationsvariablen# {{{
					# $2 - Splitzeichen
					# $3 - Datei
					# Variablen einlesen, durch Konvertierung der Daten
					# (Bsp.: VAR = Value - VAR=Value).
					# Es geht nur eine Dateiuebergabe.
					#
					if [ "$#" = 3 ] ; then
						local Split_Char Subst_Char Work_File
						unset -- Split_Char Subst_Char Work_File
						Split_Char=($2)
						Subst_Char=(=)
						Work_File=($3)
						#
						if [ -r "$Work_File" ] ; then
							grep -v '^[#;]' "$Work_File" | grep -v '^$' | sed -e "s#${Split_Char}#${Subst_Char}#" >${gv_WorkDir}/file_tmp
							source ${gv_WorkDir}/file_tmp
						fi
					else
						no_para_msg $0
					fi
					## }}}
					;;
				*)
					# Dateien im Verzeichnis ~/.kwtools einlesen# {{{
					# Die Variable gv_HomePath wird von der funktion check_home_conf_dir
					# belegt.
					while (( ${#argv} > 0 )) ; do
						if [[ -r ${gv_HomePath}/.kwtools/${1} ]] ; then
							source ${gv_HomePath}/.kwtools/${1} 2>/dev/null
							if [ ! -z $MOUNT_PATH ] ; then
								for point in $MOUNT_PATH ; { 
									mount_check -m "$point"
								}
							fi
						fi
						shift
					done
					## }}}
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (read_fstab), liest die /etc/fstab ein{{{
	#
	# Liest die Datei /etc/fstab ein.
	# usage: read_fstab [ PATTER ]
	# PATTER - Suchmuster
	#
	read_fstab() {
		integer Anz
		unset -- FS_DRIVE MOUNT_POINT FILESYSTEM MOUNT_OPTION DUMP CHECK Var FSTAB_ALL FSTAB_VALUES
		if [ "$#" = 1 ] ; then
			Var="$1"
		fi
		#
		Anz=0
		print -l ${(M)${(R)${(f)"$(< /etc/fstab)"}##\#*}##*} | \
			while read Fsd Mp Fs Mo D C ; do
				(( Anz++ ))
				FS_DRIVE[Anz]="$Fsd"
				MOUNT_POINT[Anz]="$Mp"
				FILESYSTEM[Anz]="$Fs"
				MOUNT_OPTION[Anz]="$Mo"
				DUMP[Anz]="$D"
				CHECK[Anz]="$C"
				FSTAB_ALL[Anz]="$Fsd $Mp $Fs $Mo $D $C"
			done
		#
		if [ -n "$Var" ] ; then
			for i in {1..${#FSTAB_ALL[@]}} ; {
				if [ ! -z "${(M)${FSTAB_ALL[i]}##*${Var}*}" ] ; then
					FSTAB_VALUES+=(${FSTAB_ALL[i]})
					FSTAB_VALUES_E+=($Anz \"${FSTAB_ALL[i]}\")
					FSTAB_VALUES_M+=($Anz \"${FSTAB_ALL[i]}\" off)
				fi
			}
		fi
	}
	#}}}
	# Funktion (return_check) um den Rueckgabewert zu pruefen{{{
	#
	# usage: return_check mit der Variable U_OPT
	# U_OPT=- Apostrophe werden zwischen den Woertern geloescht, Leerzeichen
	#          bleiben nicht erhalten
	# U_OPT=hk Hochkommata werden zwischen den Werten geloescht.
	# U_OPT=k Bis auf das letzte Wort bekommt jedes Wort 1 Komma und 1 Leerzeichen angehaengt.
	# U_OPT=ok Bis auf das letzte Wort bekommt jedes Wort 1 Komma angehaengt, keine Leerzeichen.
	# U_OPT=regexp_file Alles wird so eingelesen wie gespeichert und etwas anders
	#          in eine Datei geschrieben. Heisst mit Apostrophe ausser
	#          Apostroph+Leerzeichen+Apostroph wird ersetzt durch nur ein EOL-Zeichen.
	# nichts - Alles wird in die Variable gv_Auswahl mit jedem Wert in eine Zeile geschhrieben plus
	#          in der Datei $gv_LogFile$$ gespeichert. Desweiteren gibt es die Variable gv_Auswahl_Display
	#          die die Werte ohne Steuerzeichen (neue Zeile) enthaelt.
	#
	return_check() {
		case $? in
			0)	if [ "$U_OPT" = - ] ; then
					Tmp=${$(< ${DialogReDirect##*>})//\"/}
					gv_Auswahl=${Tmp// /}
				elif [ "$U_OPT" = hk ] ; then
					gv_Auswahl=${$(< ${DialogReDirect##*>})//\'/}
				elif [ "$U_OPT" = k ] ; then
					gv_Auswahl=${$(< ${DialogReDirect##*>})//\"/}
					ANZ="${(w)#gv_Auswahl}"
					while [ "$ANZ" -gt 1 ] ; do
						(( ANZ-- ))
						gv_Auswahl="`echo "$gv_Auswahl" | sed -e "s/\>./, /${ANZ} ; s/  / /"`"
					done
				elif [ "$U_OPT" = ok ] ; then
					gv_Auswahl=${$(< ${DialogReDirect##*>})//\"/}
					ANZ="${(w)#gv_Auswahl}"
					while [ "$ANZ" -gt 1 ] ; do
						(( ANZ-- ))
						gv_Auswahl="`echo "$gv_Auswahl" | sed -e "s/\>./,/${ANZ} ; s/  / /"`"
					done
				elif [ "$U_OPT" = regexp_file ] ; then
					gv_Auswahl="`print $(< ${DialogReDirect##*>}) | sed -e 's#\" \"#\n#g' | tee ${gv_LogFile}$$`"
				else
					gv_Auswahl="$(< ${DialogReDirect##*>} | tee ${gv_LogFile}$$)"
					gv_Auswahl_Display="${gv_Auswahl//[[:cntrl:]]/ }"
				fi
				;;
			1 | 255 )
				if [ -n "$V_WERT" ] ; then
					gv_Auswahl="$V_WERT"
				else
					gv_Auswahl=""
					if [ "$BREAK" ] ; then
						break $BREAK
						unset -- BREAK
					fi
				fi
				;;
			2)	# Hilfe
				gv_Auswahl=$(< ${DialogReDirect##*>})
				;;
			3)	
				# dialog Extra
				# alle Tags muessen mit einem : enden.
				Tmp=$(< ${DialogReDirect##*>})
				gv_Auswahl="${Tmp##RENAMED }"
				;;
			4)	
				######################################
				# TODO:
				######################################
				# dialog item Hilfe
				#gv_Auswahl=$(< ${DialogReDirect##*>})
				;;
		esac
		unset -- U_OPT
	}
	#}}}
	# Funktion (root_check), zum checken der root Rechte{{{
	#
	# Die Variable gv_Opt muss vorher im Script erstellt
	# werden (Bsp.: gv_Opt="$1"). Je nach dem welche Optionen
	# das Script benoetigt oder uebergeben werden kann.
	#
	# usage: root_check
	#
	root_check() {
		if [ "`id -u`" != 0 ] ; then
			MSG=$(gettext 'Fuer diese Aktion benoetigen Sie root Rechte. In den Administrator Modus wechseln (ja/nein)?')
			yesno "$gv_Attention" "$MSG" ""
			#
			if [ "$gv_Auswahl" = yes ] ; then
				# sudo only
				if which sudo >/dev/null && ( sudo -l -S < /dev/null &>/dev/null ) ; then
					exec sudo -E "$gv_ScriptName" $gv_Opt || exit 0
				elif which su-to-root >/dev/null; then
					# debian, su-to-root
					exec su-to-root -c "$gv_ScriptName $gv_Opt" || exit 0
				else
					# su
					echo enter root passwd:
					while ! su -p root -c "$gv_ScriptName $gv_Opt" ; do
						echo -n 'Incorrect password or command failed. Try again? (y/n)'
						read ans
						if test "$ans" != "y" -a "$ans" != "Y"; then
							exit 0
						fi
					done
				fi
			else
				exit 0
			fi
		else
			export TMP_PATH="/root/tmp"
			create_file -d $TMP_PATH
			gv_Script_Lock=${TMP_PATH}/${gv_ScriptName}.lock
			if [ -e "$gv_Script_Lock" ] ; then
				MSG=$(gettext 'Scripte mit root Rechten duerfen nur in einer Instanz laufen. Das Script beendet sich jetzt.')
				msgbox "$gv_Attention" "$MSG"
				unset -- gv_Script_Lock
				exit 0
			else
				create_file $gv_Script_Lock
			fi
		fi
	}			
	#}}}
# Funktion (search_fdisks), um nach Partitionierungstools zu suchen{{{
#
# In dieser Reihenfolge werden die Partitionierungs-tools gesucht:
# parted, kwparted, cfdisk, fdisk.
#
# usage: search_fdisks
#
search_fdisks() {
	local Disk
	PART_DISK_TITLE=$(gettext 'Partitionierung')
	PART_DISK_MSG=$(gettext 'Waehlen Sie eine Festplatte zum partitionieren aus.')
	#
	# Funktion (exec_part_cmd), Partitionierungstool ausfuehren# {{{
	exec_part_cmd() {
		if [ -n "${DISK_DEV_E[1]}" ] ; then
			menubox "$Disk" "$PART_DISK_TITLE" "$PART_DISK_MSG" "$DISK_DEV_E $gv_Back \"\""
			while [ "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/disk_only_help
						menubox "${gv_Auswahl#HELP }" "$PART_DISK_TITLE" "$PART_DISK_MSG" "$DISK_DEV_E $gv_Back \"\""
						;;
					/dev*)
						Disk="$gv_Auswahl"
						$Cmd "$Disk"
						menubox "$Disk" "$PART_DISK_TITLE" "$PART_DISK_MSG" "$DISK_DEV_E $gv_Back \"\""
						;;
					$gv_Back) break
						;;
				esac
			done
		else
			no_disk_msg
		fi
	}
	## }}}
	#
	if [ -x "${commands[kwparted]}" ] ; then
		kwparted
	elif [ -x "${commands[parted]}" ] ; then
		disk
		Cmd="parted"
		exec_part_cmd
	elif [ -x "${commands[cfdisk]}" ] ; then
		disk
		Cmd="cfdisk"
		exec_part_cmd
	elif [ -x "${commands[fdisk]}" ] ; then
		disk
		Cmd="fdisk"
		exec_part_cmd
	else
		MSG=$(gettext 'Es wurde keines der Programme, kwparted, parted, cfdisk oder fdisk gefunden.')
		msgbox "$gv_Attention" "$MSG"
	fi
}
#}}}
	# Funktion (sys_logger), um syslog Eintraege zu erstellen# {{{
	#
	# usage: sys_logger [ -a | -c | -d | -e | -i | -n | -r | -w ] FACILITY PROG MESSAGE
	# -a - alert
	# -c - critical
	# -d - debug
	# -e - emerg
	# -i - info
	# -n - notice
	# -r - err
	# -w - warning
	# FACILITY - auth, authpriv, cron, daemon, ftp, kern, lpr,
	#            mail, mark, news, syslog, user, uucp und local0 bis local7.
	#            see man 5 syslog.conf
	# PROG - Programmname
	# MESSAGE - Nachricht die im Log erscheinen soll.
	#
	sys_logger() {
		if [ "$#" -eq 4 ] ; then
			local Log_Opt="$1"
			local Facility="$2"
			local Log_Prog="$3"
			local Log_Msg="$4"
	        if [ -x "${commands[logger]}" ] ; then
		        case "$Log_Opt" in
		            -a) # alert
					    eval logger "-p ${Facility}.alert -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -c) # critical
					    eval logger "-p ${Facility}.crit -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -d) # debug
					    eval logger "-p ${Facility}.debug -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -e) # emerg
					    eval logger "-p ${Facility}.emerg -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -i) # info
					    eval logger "-p ${Facility}.info -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -n) # notice
					    eval logger "-p ${Facility}.notice -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -r) # error
					    eval logger "-p ${Facility}.err -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            -w) # warning
					    eval logger "-p ${Facility}.warning -t "$Log_Prog" -i \"$Log_Msg\""
		                ;;
		            *)  # falsche Parameter
				        wrong_parameter_msg $0
		                ;;
		        esac
	        else
				no_prog_exec_msg logger
		        if [ "$BREAK" ] ; then
			        break $BREAK
	        		unset -- BREAK
	        	else
			        break
		        fi
	        fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (terminal) terminal-Aufloesung ueberpruefen {{{
	terminal() {
	# Bildschirmaufloesung testen. Kleiner als 55x20 funktioniert nicht gut.
	# Da bekommt dialog kein Fenster hin oder es ist ziehmlich gequetscht.
	# 
	if [ $COLUMNS -le 79 -o $LINES -le 20 ] ; then
		MSG=$(gettext "${B_ERROR}Ihre Bildschirmaufloesung ist zu klein (${GREEN}${COLUMNS}x${LINES}${B_ERROR}). Um vernuenftig arbeiten zu koennen, benoetigen Sie mindestens ${GREEN}80x20${B_ERROR}, besser ${GREEN}80x40${B_ERROR}. Druecken Sie jetzt ENTER.${NORMAL}")
		print
		print "${B_ERROR}${gv_Attention}!"
		print "$MSG"
		print
		read
		exit 0
	fi
	}
	#}}}
	# Funktion (user_device_check), um Rechte des Devices/Datei, fuer User zu pruefen{{{
	#
	# usage: user_device_check "$DEVICE" RECHTE
	# Rechte: r = Leserechte der Eigentuemer pruefen
	#         w = Schreibrechte der Eigentuemer pruefen
	#         x = Ausfuehrrechte der Eigentuemer pruefen
	#         A = Leserechte der Eigentuemergruppe pruefen
	#         I = Schreibrechte der Eigentuemergruppe pruefen
	#         E = Ausfuehrrechte der Eigentuemergruppe pruefen
	#         R = Leserechte fuer alle anderen pruefen
	#         W = Schreibrechte fuer alle anderen pruefen
	#         X = Ausfuehrrechte fuer alle anderen pruefen
	#
	user_device_check() {
		if [ "$#" = 2 ] ; then
			SYS_DEV="$1"
			PERM="$2"
			MSG=$(gettext 'Sie duerfen auf dem Device/Datei ($SYS_DEV) nicht lesen/schreiben. Sie muessen die Rechte auf Lesen/Schreiben setzen, beziehungsweise der richtigen Gruppe angehoeren.')
			#
			# Rechte checken
			# Funktion user_check{{{
			#
			user_check() {
				# U = gehört dem aktuellen User
				# N = Null_Glob
				if [ "${SYS_DEV}(UN)" ] ; then
					unset -- r w x u_perm
					for i in 1 2 3 ; {
						case ${PERM[$i]} in
							A) r=r
							;;
							I)	w=w
							;;
							E)	x=x
							;;
						esac
						u_perm="${r}${w}${x}"
					}
					if [ -z "`ls -dl "$SYS_DEV"($u_perm) 2>/dev/null`" ] ; then
						msgbox "$gv_Attention" "$MSG"
						break
					fi
				else
					msgbox "$gv_Attention" "$MSG"
					break
				fi
			}	
			#}}}
			#
			case "$PERM" in
				[AEI]*)
					if [ "$UID" != 0 ] ; then
						Group=${$(ls -dl "$SYS_DEV"($PERM) 2>/dev/null)[4]}
						if [ -z "$Group" ] ; then
							#
							# Hat die eigene Gruppe keine angegebenen Rechte, wird geprueft
							# ob der eingeloggte User diese hat
							#
							user_check
						else
							if [ "$Group" != "`print ${(M)$(id -nG)[(r)$Group]}`" ] ; then
								msgbox "$gv_Attention" "$MSG"
								break
							fi
						fi
					fi
					;;
				[rwx]*)
					if [ "$UID" != 0 ] ; then
						if [ ${$(ls -dl "$SYS_DEV"($PERM) 2>/dev/null)[3]} != "$USER" ] ; then
							msgbox "$gv_Attention" "$MSG"
							break
						fi
					fi
					;;
				[RWX]*)
					if [ "$UID" != 0 ] ; then
						if [ -z "`ls -dl "$SYS_DEV"($PERM) 2>/dev/null`" ] ; then
							user_check
						fi
					fi
			esac
		else
			# falsche Parameter Anzahl oder falsches Device konfiguriert.
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (user_group_check), um herauszufinden welche User, Gruppen und{{{
	# deren IDs angelegt sind.
	#
	# usage: user_group_check [ -p | -g ]
	# -p - Datei /etc/passwd einlesen
	# -g - Datei /etc/group einlesen
	#
	user_group_check() {
	# Funktion zum einlesen der /etc/group oder /etc/passwd{{{
	#
	read_passwd_group() {
		unset -- U_G_ARRAY_S U_G_ARRAY U_G_ARRAY_M U_G_ID_ARRAY U_G_ID_ARRAY_M U_U_ID_ARRAY U_U_ID_ARRAY_M
		# Flags: o=sortieren aufsteigend, M=Muster, q=quoten, f=zeilenweise, #s=Zeilenanfang
		# s=Trennzeichen
		#
		# Liest Datei ein und nimmt den User|Groupnamen um die uid|gid herauszufinden
		# und speichert diese alle in Arrays.
		print -l ${${(oMq)"${(f)$(< /etc/${2})}"##(#s)[a-zA-Z0-9]*}%%:*} | \
		while read u ; do
			U_G_ARRAY_S+=($u)
			U_G_ARRAY+=($u \"\")
			U_G_ARRAY_M+=($u \"\" off)
			if [ "$1" = -g ] ; then
				U_G_ID_ARRAY+=(${(s: :)${(s,:,)${(Mq)"${(qf)$(< /etc/${2})}"##(#s)${u}*}}[3]} $u)
				U_G_ID_ARRAY_M+=(${(s: :)${(s,:,)${(Mq)"${(qf)$(< /etc/${2})}"##(#s)${u}*}}[3]} $u off)
			elif [ "$1" = -p ] ; then
				U_U_ID_ARRAY+=(${(s: :)${(s,:,)${(Mq)"${(qf)$(< /etc/${2})}"##(#s)${u}*}}[3]} $u)
				U_U_ID_ARRAY_M+=(${(s: :)${(s,:,)${(Mq)"${(qf)$(< /etc/${2})}"##(#s)${u}*}}[3]} $u off)
			fi
		done
	}
	#}}}
	case $1 in
		-g)	#
			# vorhandene Gruppen herausfinden.
			#
			if [ -f /etc/group ] ; then
				read_passwd_group -g group
			else
				MSG=$(gettext 'Es ist keine /etc/group Datei vorhanden.')
				msgbox "$gv_Attention" "$MSG"
				return 1
			fi
			;;
		-p)	#
			# vorhandene User herausfinden.
			#
			if [ -f /etc/passwd ] ; then
				read_passwd_group -p passwd
			else
				MSG=$(gettext 'Es ist keine /etc/passwd Datei vorhanden.')
				msgbox "$gv_Attention" "$MSG"
				return 1
			fi
			;;
	esac
	# Pruefen, ob die Variable U_G_ARRAY belegt ist.
	if [ -z "${U_G_ARRAY[1]}" ] ; then
		MSG=$(gettext 'Es ist kein(e) Benutzer/Gruppe vorhanden.')
		msgbox "$gv_Attention" "$MSG"
		return 1
	fi
	return 0
	}
	#}}}
	# Funktion (user_group_passwd), user und group Passwoerter eingeben# {{{
	#
	# usage: user_group_passwd [ -u | -g ] PASSWD_MSG
	# -u - User
	# -g - Group
	# PASSWD_MSG - Nachricht in der Dialogbox
	#
	user_group_passwd() {
		if [[ ${#argv} == 2 ]] ; then
			local Opt
			Opt="$1"
			PASSWD_MSG="$2"
			#
			# Pruefen auf cracklib Programm
			CRACKLIB_CHECK="${commands[cracklib-check]}"
			#
			# Funktion (passwd_conf_menu), Hauptmenue# {{{
			passwd_conf_menu() {
				if [ "$Opt" = -u ] ; then
					PASSWD_MENU=(\"$gv_Passwd_User\" "1 1 \"$NUSER\" 1 20 20 0 2"
					\"$gv_New_Passwd\" "2 1 \"\" 2 20 20 0 1"
					\"$gv_New_Passwd\" "3 1 \"\" 3 20 20 0 1")
				elif [ "$Opt" = -g ] ; then
					PASSWD_MENU=(\"$gv_Passwd_Group\" "1 1 \"$NGROUP\" 1 20 20 0 2"
					\"$gv_New_Passwd\" "2 1 \"\" 2 20 20 0 1"
					\"$gv_New_Passwd\" "3 1 \"\" 3 20 20 0 1")
				else
					no_para_msg $0
					unset -- gv_Auswahl
				fi
				mixedform -i "$gv_Passwd_TITLE" "$PASSWD_MSG" "$PASSWD_MENU"
			}
			## }}}
			passwd_conf_menu
			while [ -n "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help share/passwd_help
						passwd_conf_menu
						;;
					*)
						Anz="${(w)#gv_Auswahl}"
						NPW="${${(ws: :)${=gv_Auswahl}}[2]}"
						NNPW="${${(ws: :)${=gv_Auswahl}}[3]}"
						if [ "$Anz" -eq 3 ] ; then
							if [ "$NPW" = "$NNPW" ] ; then
								# Pruefen, ob cracklib installiert ist
								# und das neue Passwort pruefen ob schon vorhanden
								if [ -x "$CRACKLIB_CHECK" ] ; then
									PW_OK="`print ${(M)$(export LC_ALL=C ; echo "$NPW" | $CRACKLIB_CHECK)##OK}`"
									if [[ $PW_OK = OK ]] ; then
										# Die Funktion password_display
										# erzeugt die  Variable
										# gv_Star_Passphrase zur
										# Sternchenanzeige des Passwortes
										password_display $NPW
										gv_Pass="$NPW"
										unset -- NPW NNPW
										break
									else
										# Passwort basiert auf einem Woerterbucheintrag.
										DICT_MSG=$(gettext 'Das Passwort basiert auf einem Woerterbucheintrag.\nPassworteingabe wiederholen (ja/nein)?')
										yesno "$gv_Attention" "$DICT_MSG" ""
										if [ "$gv_Auswahl" = yes ] ; then
											passwd_conf_menu
										else
											password_display $NPW
											gv_Pass="$NPW"
											unset -- NPW NNPW
											break
										fi
									fi
								else
									password_display $NPW
									gv_Pass="$NPW"
									unset -- NPW NNPW
									break
								fi
							else
								different_passwd
								passwd_conf_menu
							fi
						else
							failed_entry_msg
							passwd_conf_menu
						fi
						;;
				esac
			done
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Diese Funktion (yesno_option) prüft eine Optionsvariable auf ihren Wert# {{{
	# und vergleicht sie mit einem vorgegebenen Ziel-Wert. Sind diese
	# Werte gleich wird die Variable "YN_OPT" mit "yes" belegt ansonsten
	# mit "no".
	#
	# Diese Funktion dient der Dialogbox "yesno".
	# Beispiel: yesno TITLE MSG YN_OPT
	#
	# usage: yesno_option "VAR" "TARGET-VALUE"
	#
	# VAR          - werdende oder vorhandende Variable.
	# TARGET-VALUE - Standard Wert für "yes" zum Vergleich.
	#
	yesno_option() {
		if [[ ${#argv} == 2 ]] ; then
			if [ ! -z "$1" -a "$1" = "$2" ] ; then
				YN_OPT=yes
			else
				YN_OPT=no
			fi
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (zsh_modload), laedt zsh Module# {{{
	#
	# usage: zsh_modload [ -OPTION MODUL MODUL | MODUL MODUL ...]
	#
	zsh_modload() {
		unset -- Opt Mod
		local Opt Mod
		#
		if [ "$#" -ge 1 ] ; then
			case "$1" in
				-*)
					# mit Option module laden
					Opt="$1"
					Mod="$2"
					;;
				*)
					# normal - module laden
					Mod="$1"
					;;
			esac
			# laden
			for i in $Mod ; {
				if [ -z ${(M)$(zmodload)##(#s)zsh/${i}} ] ; then
					zmodload $Opt zsh/${i}
				fi
			}
		else
			no_para_msg $0
		fi
	}
	## }}}
	## }}}
	###### allgemeine System Nachrichten ###### {{{
	# Funktion (del_file_msg), Nachricht zum Dateien loeschen{{{
	#
	# wird von del_file benoetigt.
	#
	# usage: del_file_msg
	#
	del_file_msg() {
		TITLE=$(gettext 'Dateien loeschen')
		MSG=$(gettext 'Soll(en) die (Original) Datei(en) geloescht werden (ja/nein)? Dies kann ein soeben erstelltes Image sein oder Dateien die in andere Dateien umgewandelt worden sind.')
		yesno "$TITLE" "$MSG" ""
	}
	#}}}
	# Funktion (different_passwd){{{
	#
	# usage: different_passwd
	#
	different_passwd() {
		MSG=$(gettext 'Die Passworteingaben waren unterschiedlich.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (failed_entry_msg), fehlende Menuepunkte Belegung# {{{
	#
	# usage: failed_entry_msg
	failed_entry_msg() {
		MSG=$(gettext 'Sie haben einige Menuepunkte vergessen zu belegen, die benoetigt werden. Lesen Sie bitte die Hilfe.')
		msgbox "$gv_Attention" "$MSG"
	}
	## }}}
	# Funktion (file_existed_msg){{{
	#
	# usage: file_existed_msg FILE
	#
	file_existed_msg() {
		if [ "$#" = 1 ] ; then
			FILE="$1"
			MSG=$(gettext 'Die Datei $FILE existiert bereits.')
			if [[ -n $gv_Terminal ]] ; then
				msgbox "$gv_Attention" "$MSG"
			else
				print "$MSG"
			fi
		else
			no_para_msg "$0"
		fi
	}
	#}}}
	# Funktion (hier_ist_noch_nichts), Hier ist noch keine Einstellung moeglich{{{
	#
	# usage: hier_ist_noch_nichts "$WAS_IST_NOCH_NICHT"
	#
	hier_ist_noch_nichts() {
		if [ $# -eq 1 ] ; then
			What="$1"
			MSG=$(gettext 'Hier ist noch nichts ($What).')
			msgbox "$gv_Info" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (input_all_field_msg), alle Felder muessen# {{{
	# belegt sein.
	#
	# usage: input_all_field_msg
	input_all_field_msg() {
		MSG=$(gettext 'Sie muessen alle Felder mit Werten belegen.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (is_dir_msg), Nachricht wenn die Auswahl ein Verzeichnis ist.# {{{
	#
	# usage: is_dir_msg DIR
	#
	is_dir_msg() {
		if [ "$#" -eq 1 ] ; then
			local Dir
			Dir="$1"
			MSG=$(gettext '$Dir ist ein Verzeichnis und keine Datei.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (it_to_take_msg), Info-Nachricht das es etwas dauern kann.# {{{
	#
	# usage: it_to_take_msg
	#
	it_to_take_msg() {
		MSG=$(gettext 'Dieser Vorgang kann einige Minuten dauern.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
# Funktion (no_backup_path_msg){{{
#
# usage: no_backup_path_msg
no_backup_path_msg() {
	MSG=$(gettext 'Sie haben kein Backup Verzeichnis angegeben. Konfigurieren Sie dies erst.')
	msgbox "$gv_Attention" "$MSG"
}
#}}}
	# Funktion (no_block_dev_msg){{{
	#
	# usage: no_block_dev_msg DEV
	no_block_dev_msg() {
		if [ "$#" = 1 ] ; then
			local Block_Dev
			Block_Dev="$1"
			MSG=$(gettext '$Block_Dev ist kein blockorientiertes Geraet.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg "$0"
		fi
	}
	#}}}
	# Funktion (no_dezimal_msg)# {{{
	#
	# usage: no_dezimal_msg
	no_dezimal_msg() {
		MSG=$(gettext 'Sie muessen eine Dezimal Zahl eingeben (Bsp. 0.9 oder 0,9).')
		msgbox "$gv_Attention" "$MSG"	
	}
	# }}}
	# Funktion (no_dir_msg), Nachricht wenn die Auswahl kein Verzeichnis ist{{{
	#
	# usage: no_dir_msg DIR
	#
	no_dir_msg() {
		if [ "$#" -eq 1 ] ; then
			local Dir
			Dir="$1"
			MSG=$(gettext '$Dir ist kein Verzeichnis.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (no_editor_msg){{{
	#
	# usage: no_editor_msg
	no_editor_msg() {
		MSG=$(gettext 'Sie muessen die Variable EDITOR, mit einem Editor ihrer Wahl belegen (Bsp.: EDITOR=vim).')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (no_entry_msg), kein Eintrag vorhanden{{{
	# Zur Anzeige falls es keinen Eintrag in einer Datei gibt.
	#
	# usage: no_entry_msg
	#
	no_entry_msg() {
		MSG=$(gettext 'Es ist kein Eintrag vorhanden.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (no_file_msg), Nachricht wenn keine Dateien{{{
	# mit vorgegeben FORMAT vorhanden sind.
	#
	# usage: no_file_msg "$FORMAT"
	#        Format kann zum Beispiel ASCII sein
	#
	no_file_msg() {
		if [ $# -ge 1 ] ; then
			FM="$1"
			MSG=$(gettext 'Es sind keine ($FM) Dateien vorhanden.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (no_fs_type_msg), konnte den Dateisystemtyp nicht feststellen# {{{
	#
	# usage: no_fs_type_msg DEVICE
	# DEVICE - Variable die das Geraet enthaelt
	#
	no_fs_type_msg() {
		if [ "$#" -eq 1 ] ; then
			unset -- Lw
			local Lw
			Lw="$1"
			MSG=$(gettext 'Es konnte kein Dateisystemtyp fuer das Laufwerk ($Lw) festgestellt werden. Lesen Sie bitte die Hilfe.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (no_help_msg), hier ist noch keine hilfe# {{{
	#
	no_help_msg() {
		MSG=$(gettext 'Hier ist noch keine Hilfe verfuegbar.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_id_range_msg), Nachricht ueber schon vergebene User ID.{{{
	#
	# usage: no_id_range_msg ID
	no_id_range_msg() {
		unset -- Nr
		local Nr
		if [ "$#" = 1 ] ; then
			Nr=$1
			MSG=$(gettext 'Diese User ID ($Nr) ist schon vergeben. Bitte nehmen Sie eine andere.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (no_input_msg), Nachricht wenn etwas nicht eingegeben wurde{{{
	#
	# benoetigt die Funktion msgbox
	#
	# usage: no_input_msg
	#
	no_input_msg() {
		MSG=$(gettext 'Sie muessen auch etwas ordentliches eingeben oder auswaehlen, ausser Sie wollten den Vorgang abbrechen.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (no_integer_msg)# {{{
	#
	# usage: no_integer_msg
	no_integer_msg() {
		MSG=$(gettext 'Sie muessen eine Integer Zahl eingeben.')
		msgbox "$gv_Attention" "$MSG"	
	}
	# }}}
	# Funktion (no_memory_msg)# {{{
	#
	# usage: no_memory_msg
	#
	no_memory_msg() {
		MSG=$(gettext 'Es ist nicht genug Arbeitsspeicher vorhanden.')
		msgbox "$gv_Attention" "$MSG"
	}
	## }}}
# Funktion (no_option_msg), Optionen die nicht zusammen funktionieren{{{
# Gibt eine Fehlermeldung aus, wenn einige Optionen nicht
# zusammen ausgefuehrt werden koennen.
#
# usage: no_option_msg
no_option_msg() {
	OPT_MSG=$(gettext 'Diese Optionen funktionieren nicht zusammen.')
	msgbox "$gv_Attention" "$OPT_MSG"
}
#}}}
	# Funktion (no_pager_msg)# {{{
	#
	# usage: no_pager_msg
	no_pager_msg() {
		MSG=$(gettext 'Die Variable "PAGER" ist nicht belegt (z.B. PAGER=less). Erledigen Sie dies mit dem Script \"kwadmin\".')
		msgbox "$gv_Attention" "$MSG"
	}
	# }}}
	# Funktion (no_para_msg){{{
	#
	# usage: no_para_msg $0
	no_para_msg() {
		FUNC="$1"
		MSG=$(gettext 'Sie haben falsche oder nicht genuegend Parameter der Funktion $FUNC uebergeben.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (no_perm_prog_msg){{{
	#
	# usage: no_perm_prog_msg Programm
	no_perm_prog_msg() {
		if [ "$#" = 1 ] ; then
			Prog="$1"
			MSG=$(gettext 'Sie duerfen das Script/Programm ($Prog) nicht ausfuehren. Lesen Sie die Hilfe zu $Prog.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (no_prog_exec_msg){{{
	#
	# usage: no_prog_exec_msg Programm
	#
	no_prog_exec_msg() {
		if [[ ${#argv} == 1 ]] ; then
			Prog="$1"
			MSG=$(gettext 'Kann das/die Script(s)/Programm(e) ($Prog) nicht finden oder\nausfuehren. Stellen Sie sicher das es/sie installiert ist/sind.')
			if [[ -n $gv_Terminal ]] ; then
				msgbox "$gv_Attention" "$MSG"
			else
				print "$MSG"
			fi
		else
			no_para_msg $0
		fi
	}
	#}}}
	# Funktion (no_release_msg)# {{{
	no_release_msg() {
		MSG=$(gettext 'Es konnte keine Version dieser Distribution ($OS) festgestellt werden.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_special_character_msg) {{{
	#
	# usage: no_special_character_msg
	no_special_character_msg() {
		MSG=$(gettext 'Sie duerfen keine Sonderzeichen benutzen.')
		msgbox "$gv_Attention" "$MSG"	
	}
	# }}}
# Funktion (no_use_dir_msg), Nachricht wenn das angegebene Verz.{{{
# nicht doppelt vergeben werden darf.
#
# benoetigt die Funktion msgbox
#
# usage: no_use_dir_msg DIR
#
no_use_dir_msg() {
    if [ "$#" = 1 ] ; then
        unset -- Value
        local Value
        Value="$1"
        MSG=$(gettext 'Das Verzeichnis $Value darf in diesem Fall nicht doppelt vergeben werden.')
        msgbox "$gv_Attention" "$MSG"
    else
        no_para_msg $0
    fi
}
#}}}
	# Funktion (over_size_msg), Groesse wird ueberschritten{{{
	#
	# usage: over_size_msg
	over_size_msg() {
		MSG=$(gettext 'Die angegebene Groesse ueberschreitet den verfuegbaren Platz. Geben Sie bitte eine andere Groesse an.')
		msgbox "$gv_Attention" "$MSG"
	}
	#}}}
	# Funktion (prog_failure) fuer Fehlermeldungen bei der {{{
	# Ausfuehrung eines Programms
	#
	# Die Variable BREAK, falls benoetigt muss in den einzelnen Scripten
	# oder Funktionen gesetzt werden. Bsp.: BREAK=2
	#
	# usage: prog_failure
	#
	prog_failure() {
		RET=1
		if [[ -n $DEVICES ]] ; then
			lock -r $DEVICES
		fi
		print ${ERROR_BG}${B_ERROR}
		MSG=$(gettext 'Achtung Fehler:\nSchauen Sie sich bitte die letzten Meldungen an.\nMit shift+bild (hoch/runter) koennen Sie scrollen.\nDruecken sie ENTER danach.')
		print "$MSG"
		print $NORMAL
		setterm --clear all
		read
		#
		if [ "$BREAK" ] ; then
			break $BREAK
			unset -- BREAK
		fi
	}
	#}}}
	# Funktion (wrong_parameter_msg), falscher Parameter{{{
	#
	# usage: wrong_parameter_msg Funktion
	wrong_parameter_msg() {
		if [ "$#" = 1 ] ; then
			local Func="$1"
			MSG=$(gettext 'Sie haben einen falschen Parameter der Funktion ($Func) uebergeben.')
			msgbox "$gv_Attention" "$MSG"
		else
			no_para_msg $0
		fi
	}
	#}}}
	## }}}
	###### allgemeine Funktionen die wegen xgettext ans Ende gehoeren ###### {{{
	# Funktion (del_file), um die urspruenglichen Dateien zu loeschen{{{
	#
	# usage: del_file [ -f | -r | -s | -A ] "$WERT" oder  del_file "$SUFFIX"
	# -f = aus Datei einlesen
	# -r = rekursiv loeschen auch Verzeichnisse und Unterverzeichnisse
	# -s = Dateien einzeln loeschen
	# -A = ein ARRAY loeschen
	# nichts = alle Dateien auf die das Suffix passt loeschen
	# WERT - kann Datei(en), Verzeichnis(se) oder Arrayname(n) sein.
	# Suffix ist das Dateiende, z.B. .mp3, .ogg, .txt. Kann aber auch leer sein.
	#
	del_file() {
		if [ "$#" -ge 1 ] ; then
			case $1 in
				-f)	#
					# aus Datei einlesen
					#
					del_file_msg
					if [ "$gv_Auswahl" = yes ] ; then
                        while read a ; do
                            rm -rf "$a"
                        done < "$2"
					fi
					;;
				-r)	#
					# rekursives loeschen
					#
					del_file_msg
					if [ "$gv_Auswahl" = yes ] ; then
						shift
						for i in $@ ; {
							rm -rf ./(*/)*$i(.N)
						}
					fi
					;;
				-A)	#
					# ARRAY Inhalt loeschen
					#
					del_file_msg
					if [ "$gv_Auswahl" = yes ] ; then
						rm -rf ${(ws: :)${2//\'/}}
					fi
					;;
				-s)	#
					# Dateien/Verzeichnisse einzeln loeschen
					#
					del_file_msg
					if [ "$gv_Auswahl" = yes ] ; then
						shift
						for i in $@ ; {
							rm -rf $i(.N)
						}
					fi
					;;
				*)	#
					# alle Dateien, auf die das Suffix passt, loeschen
					#
					del_file_msg
					if [ "$gv_Auswahl" = yes ] ; then
						for i in *$1 ; {
							rm -rf *$i(.N)
						}
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	#}}}
	## }}}
}
# }}}
### Modeline {{{
### vim:ft=zsh:foldmethod=marker
### vim:set ts=4:                                                                               
### }}}
